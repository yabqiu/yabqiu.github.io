---
title: Quartz Job Scheduling Framework［翻译］第六章. Job 存储和持久化 (第二部分)
url: /quartz-job-scheduling-framework-6-2/
date: 2008-05-11T07:54:00-05:00
featured: false
draft: false
type: post
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/quartz-logo.jpeg"
categories:
  - Quartz
tags: 
  - Quartz
  - 翻译
comment: true
codeMaxLines: 50
# additional
wpPostId: 398 
wpStatus: publish
views: 1781
lastmod: 2020-03-22T11:41:40-05:00
---

<strong>四. 使用持久性的 <span style="color: #800080;">JobStore</span><br />
</strong></p>
<br/>
在很多方面，<span style="color: #800080;">JobStore</span> 有用内存来存储的，还有些使用某种能长期持久的方式来共享相拟的特征。这不该有什么惊奇的，因为他们都服务于同一目的。<br/><br/>
和 <span style="color: #800080;">RAMJobStore</span> 一样，特久性的 <span style="color: #800080;">JobStore</span> 有优点也有其缺点。在你选择持久性的 <span style="color: #800080;">JobStore</span> 之前应该认真理解其利与弊。这节就来解释它们的区别，以及在什么情况下你会希望使用持久性的 <span style="color: #800080;">JobStore</span>。<br/><br/>
目前，Quartz 提供了两种类型的持久性 <span style="color: #800080;">JobStore</span>，每一种类型都有其独特的持久化机制。<!--more--><br/><br/>
<table style="border: 1px;" border="1" width="70%" align="center">
<tbody>
<tr>
<td><strong>持久性 JobStore = JDBC + 关系型数据库<br />
</strong><br />
尽管有几种不同的持久化机制可被 Quartz 用于持久化 Scheduler 信息，Quartz 依赖于一个关系型数据库管理系统(RDMS) 来持久化存储。假如你想用某种别的而不是数据库来持久化存储，那么你必须通过实现 JobStore 接口自己构建它。假定你想用文件系统来持久化存储。你可以创建一个类，这个类要实现 <span style="color: #800080;">JobStore</span> 接口，在本章中，当我们说 "持久化"，我们隐式的是说用 JDBC 来持久化 Scheduler 状态到数据库中</td>
</tr>
</tbody>
</table>
<br/>
Quartz 所带的所有的持久化的 <span style="color: #800080;">JobStore</span> 都扩展自 <span style="color: #800080;">org.quartz.impl.jdbcjobstore.JobStoreSupport</span> 类。<br/><br/>
<strong>·<span style="color: #800080;">JobStoreSupport</span> 类<br />
</strong><br />
<span style="color: #800080;">JobStoreSupport</span> 是个抽象类，并实现了 <span style="color: #800080;">JobStore</span> 接口，在此章前面就讨论过的。它为所有基于 JDBC 的 <span style="color: #800080;">JobStore</span> 提供了基本的功能。图 6.1 显示了 <span style="color: #800080;">JobStore</span> 类型的层次关系。<br/><br/>
<div><strong>图 6.1. <span style="color: #800080;">JobStore</span> 类型层次</strong>如图 6.1 所描绘的，<span style="color: #800080;">JobStoreSupport</span> 实现了 <span style="color: #800080;">JobStore</span> 接口，是作为 Quartz 提供的两个具体的持久性 JobStore 类的基类。<br/><br/>
<table style="border: 1px;" border="1" width="70%" align="center">
<tbody>
<tr>
<td><strong><span style="color: #800080;">JobStoreSupport</span> 本该名之为 <span style="color: #800080;">JDBCJobStoreSupport</span></strong>作为这个类的一个更好的名字本应该是 <span style="color: #800080;">JDBCJobStoreSupport</span>，因为这个类专门是为基于 JDBC 存储方案而设置的，然而，这个名并没有减损到它为持久性 <span style="color: #800080;">JobStore</span> 所提供的功能。</td>
</tr>
</tbody>
</table>
因为 <span style="color: #800080;">JobStoreSupport</span> 类是抽象的，因此 Quartz 提供了两种不同类型的具体化的 <span style="color: #800080;">JobStore</span>，每一个设计为针对特定的数据库环境和配置：
·<span style="color: #800080;">org.quartz.impl.jdbcjobstore.JobStoreTX</span>
·<span style="color: #800080;">org.quartz.impl.jdbcjobstore.JobStoreCMT</span>
这两个持久性 <span style="color: #800080;">JobStore</span> 前面简单讨论过。但现在，我们来讨论两个版本所需要的数据库。
<strong>五. 为 Job 存储使用数据库</strong>
Quartz 中的持久性 <span style="color: #800080;">JobStore</span> 有时候就是指 JDBC <span style="background-color: #ffffff; color: #800080;">JobStore</span>，因为他们基本是依赖于一个 JDBC  驱动和一个关系型数据库通信。持久性 <span style="color: #800080;">JobStore</span> 会用到许多的 JDBC 特性，包括支持事特，锁定和隔离级别，只列了这几个特性罢。
  <br/><br/>
<table style="border: 1px;" border="1" width="70%" align="center">
<tbody>
<tr>
<td><strong>要是我的数据库不支持 JDBC 呢？</strong>假如你的数据库不支持 JDBC，那你肯定是碰到什么问题了。并不能全归咎于你运气不好，只是在这之前你还有很多工作要做。你最好是切换到某一种支持的数据库平台上来。假如你的数据库不支持 JDBC，你将需要创建一个新的实现(实现了 <span style="color: #800080;">JobStore</span> 接口)。你也许想检查一下 Quartz 用户论坛里的用户，看谁是否已经做了这样的工作，并是否愿意共享他们的代码或者至少告诉你实现的方法。</td>
</tr>
</tbody>
</table>
<strong>·持久性 <span style="color: #800080;">JobStore</span> 所支持的数据库</strong>
Quartz 中的持久性 <span style="color: #800080;">JobStore</span> 被设计能与如下数据库平台一同使用：
    ·Oracle
    ·MySQL
    ·MS SQL Server 2000
    ·HSQLDB
    ·PostgreSQL
    ·DB2
    ·Cloudscape/Derby
    ·Pointbase
    ·Informix
    ·Firebird
    ·大多数别的有完全 JDBC 兼容性驱动的 RDBMS
<strong>·独立环境中的持久性存储</strong>
<span style="color: #800080;">JobStoreTX</span> 类设计为用于独立环境中。这里的 "独立"，我们是指这样一个环境，在其中不存在与应用容器的事物集成。这里并不意味着你不能在一个容器中使用 <span style="color: #800080;">JobStoreTX</span>，只不过，它不是设计来让它的事特受容器管理。区别就在于 Quartz 的事物是否要参与到容器的事物中去。
<strong>·程序容器中的持久性存储</strong>
<span style="color: #800080;">JobStoreCMT</span> 类设计为当你想要程序容器来为你的 <span style="color: #800080;">JobStore</span> 管理事物时，并且那些事物要参与到容器管理的事物边界时使用。它的名字明显是来源于容器管理的事物(Container Managed Transactions (CMT))。
<strong>六. 创建 Quartz 数据库结构</strong>
<span style="color: #800080;">JobStore</span> 是基于 JDBC 的，它需要一个数据用于 Scheduler 信息的持久化。Quartz  需要创建 12 张数据库表。表的名字和描述在表 6.1 中列出。
<table width="650" cellspacing="5"><br/><br/>
<caption><strong>表 6.1. Quartz 需要下列表用于所有的 JDBC 的持久性 <span style="color: #800080;">JobStore</span></strong></caption>
<tbody>
<tr>
<td><strong>表名</strong></td>
<td><strong>描述</strong></td>
</tr>
<tr>
<td>QRTZ_CALENDARS</td>
<td>以 Blob 类型存储 Quartz 的 Calendar 信息</td>
</tr>
<tr>
<td>QRTZ_CRON_TRIGGERS</td>
<td>存储 Cron Trigger，包括 Cron 表达式和时区信息</td>
</tr>
<tr>
<td>QRTZ_FIRED_TRIGGERS</td>
<td>存储与已触发的 Trigger 相关的状态信息，以及相联 Job 的执行信息</td>
</tr>
<tr>
<td>QRTZ_PAUSED_TRIGGER_GRPS</td>
<td>存储已暂停的 Trigger 组的信息</td>
</tr>
<tr>
<td>QRTZ_SCHEDULER_STATE</td>
<td>存储少量的有关 Scheduler 的状态信息，和别的 Scheduler 实例(假如是用于一个集群中)</td>
</tr>
<tr>
<td>QRTZ_LOCKS</td>
<td>存储程序的非观锁的信息(假如使用了悲观锁)</td>
</tr>
<tr>
<td>QRTZ_JOB_DETAILS</td>
<td>存储每一个已配置的 Job 的详细信息</td>
</tr>
<tr>
<td>QRTZ_JOB_LISTENERS</td>
<td>存储有关已配置的 <span style="color: #800080;">JobListener</span> 的信息</td>
</tr>
<tr>
<td>QRTZ_SIMPLE_TRIGGERS</td>
<td>存储简单的 Trigger，包括重复次数，间隔，以及已触的次数</td>
</tr>
<tr>
<td>QRTZ_BLOG_TRIGGERS</td>
<td>Trigger 作为 Blob 类型存储(用于 Quartz 用户用 JDBC 创建他们自己定制的 Trigger 类型，<span style="color: #800080;">JobStore</span> 并不知道如何存储实例的时候)</td>
</tr>
<tr>
<td>QRTZ_TRIGGER_LISTENERS</td>
<td>存储已配置的 <span style="color: #800080;">TriggerListener</span> 的信息</td>
</tr>
<tr>
<td>QRTZ_TRIGGERS</td>
<td>存储已配置的 Trigger 的信息</td>
</tr>
</tbody>
</table>
中表 6.1 中，所有的表都是以前缀 <span style="color: #800080;">QRTZ_</span> 开始。这是默认的，但是你可以通过在 <span style="color: #800080;">quartz.properties</span> 文件中提供一个替代的前缀来改变它。如果你对不同的 Scheduler 实例使用了多套的表，那么改变这个前缀则是必须的。这在你需要用到多个非集群的 Scheduler，但只想用一个单独的数据库实例时也是要做的。
  <br/><br/>
<strong>·安装 Quartz 数据库表</strong>
  <br/><br/>
Quartz 包括了所有被支持的数据库平台的 SQL 脚本。你能在 <span style="color: #800080;">&lt;quartz_home&gt;/docs/dbTables</span> 目录下找到那些 SQL 脚本，这里的 <span style="color: #800080;">&lt;quartz_home&gt;</span> 是解压 Quartz 分发包后的目录。
  <br/><br/>
大约有 18 种不同的数据库平台的脚本。这差不多能覆盖到你所能想出来的任何数据库。假如你的不在其列，你可以使用其中一个已存在的脚本，略做修改以适应你的数据库平台。
    <br/><br/>
要安装必须的数据库表，先打开那个专为你的数据库平台制作的 .sql 文件并用你喜爱的查询工具执行其中的命令。比如说是 MS SQL Server，你需要用数据库所带的查询分析器(Quary Analyzer) 运行文件 <span style="color: #800080;">tables_sqlServer.sql</span> 中的命令。SQL 命令不负责创建数据库。你还要特别留意 SQL 文件最前面的注释。通常，在运行命令之前都必须执行几条指令。例如，还是 MS SQL Server 的 SQL 文件，你需要修改文件顶端的这条命令，填入数据库名称，在你刚创建它的时候还是一个空数据库。
<br/><br/>
<span style="color: #800080;">USE [enter_db_name_here]</span>
  <br/><br/>
SQL 文件创建了必须的表结构，还给表加上了基本的约束和索引。在本章后面，我们会讨论如何通过对表结构做些额外的变动来改进性能。
</div>
<br/>
{{< bundle-image src="QuartzFigure6.1.jpg" width="314px" >}}
