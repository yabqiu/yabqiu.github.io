---
title: Quartz Job Scheduling Framework［翻译］第六章. Job 存储和持久化 (第四部分)
url: /quartz-job-scheduling-framework-6-4/
date: 2008-05-30T21:03:00-05:00
featured: false
draft: false
type: post
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/quartz-logo.jpeg"
categories:
  - Quartz
tags: 
  - Quartz
  - 翻译
comment: true
codeMaxLines: 50
# additional
wpPostId: 386 
wpStatus: publish
views: 731
lastmod: 2020-03-22T11:46:57-05:00
---

<strong>八. 为 <span style="color: #800080;">JobStroreTX</span> 创建数据源</strong></p>
<br/>
当使用持久性 <span style="color: #800080;">JobStore</span> 时，Quartz 需要一个数据源。数据源扮演着产生数据库连接工厂的角色。在 Java 　中，所有的数据源要实现 <span style="color: #800080;">java.sql.Datasource</span> 接口。Quartz 自身并不提供 <span style="color: #800080;">Datasource</span> 的所有功能；它只代表了那一职责。默认的，Quartz 能使用另一开源的框架，叫做 Commons DBCP，或者可以通过 JNDI 查找应用服务器中定义的 <span style="color: #800080;">DataSource</span>。<br/><br/>
DBCP 是一个 Jakarta Commons 项目，网址是 <a href="http://jakarta.apache.org/commons/dbcp">http://jakarta.apache.org/commons/dbcp</a>。这个框架的二进制版包含在 Quartz 的发行版中，你应该把它加到你的 Quartz  应用中来。你还需要加入 Commons Pool 库，它也包含中 Quartz 发行版中，是 DBCP 要用到的。<br/><br/>
使用 <span style="color: #800080;">JobStoreTX</span> 时，你必须在 <span style="color: #800080;">quartz.properties</span> 文件中指定 Datasource 属性。这允许 Quartz 为你创建并管理 <span style="color: #800080;">Datasource</span>。表 6.4 列示了使用 <span style="color: #800080;">JobStoreTX</span> 时需要的 <span style="color: #800080;">Datasource</span> 配置属性。<!--more--><br/><br/>
<table border="0" width="650" cellpadding="5">
<caption><strong>表 6.4. 配置 Quartz Datasource 的可用属性</strong></caption>
<tbody>
<tr>
<td><strong>属性</strong></td>
<td><strong>必须</strong></td>
</tr>
<tr>
<td><span style="color: #800080;">org.quartz.dataSource.NAME.driver</span></td>
<td>是</td>
</tr>
<tr>
<td colspan="2"><strong>描述：</strong>JDBC 驱动类的全限名</td>
</tr>
<tr>
<td><span style="color: #800080;">org.quartz.dataSource.NAME.URL</span></td>
<td>是</td>
</tr>
<tr>
<td colspan="2"><strong>描述：</strong>连接到你的数据库的 URL(主机，端口等)</td>
</tr>
<tr>
<td><span style="color: #800080;">org.quartz.dataSource.NAME.user</span></td>
<td>否</td>
</tr>
<tr>
<td colspan="2"><strong>描述：</strong>用于连接你的数据库的用户名</td>
</tr>
<tr>
<td><span style="color: #800080;">org.quartz.dataSource.NAME.password</span></td>
<td>否</td>
</tr>
<tr>
<td colspan="2"><strong>描述：</strong>用于连接你的数据库的密码</td>
</tr>
<tr>
<td><span style="color: #800080;">org.quartz.dataSource.NAME.maxConnections</span></td>
<td>否</td>
</tr>
<tr>
<td colspan="2"><strong>描述：</strong>DataSource 在连接接中创建的最大连接数</td>
</tr>
<tr>
<td><span style="color: #800080;">org.quartz.dataSource.NAME.validationQuary</span></td>
<td>否</td>
</tr>
<tr>
<td colspan="2"><strong>描述：</strong>一个可选的 SQL 查询字串，<span style="color: #800080;">DataSource</span> 用它来侦测并替换失败/断开的连接。例如，Oracle 用户可选用 <span style="color: #800080;">select table_name from user_tables</span>，这个查询应当永远不会失败，除非直的就是连接不上了。</td>
</tr>
</tbody>
</table>
<br/>
表 6.4  中列出的每一个属性，你需要用你选择的名字替换掉属性的 <span style="color: #800080;">NAME</span> 部分。只要保证 <span style="color: #800080;">Datasource</span> 的所有属性的 <span style="color: #800080;">NAME</span> 部分相同就行了。这个名字用于唯一的标识 <span style="color: #800080;">Datasource</span>。假如你需要配置多个 <span style="color: #800080;">Datasource</span> (在使用 <span style="color: #800080;">JobStoreCMT</span> 时你将会这么做)，每一个 <span style="color: #800080;">Datasource</span> 应该有一个唯一的 <span style="color: #800080;">NAME</span> 值。<br/><br/>
代码 6.2 展示了一个为 <span style="color: #800080;">JobStoreTX</span> 配置 <span style="color: #800080;">Datasource</span> 的例子，它需要加到 <span style="color: #800080;">quartz.properties</span> 文件中<br/><br/>
<strong>代码 6.2. 一个用于非 CMT 环境的 Quartz <span style="color: #800080;">Datasource</span> 的例子<br />
</strong>
{{< highlight java-properties >}}org.quartz.dataSource.myDS.driver = net.sourceforge.jtds.jdbc.Driver
org.quartz.dataSource.myDS.URL = jdbc:jtds:sqlserver://localhost:1433/quartz
org.quartz.dataSource.myDS.user = admin
org.quartz.dataSource.myDS.password = myPassword
org.quartz.dataSource.myDS.maxConnections = 10
{{</ highlight >}}
<br/>
像上面代码 6.2 那样加入了 <span style="color: #800080;">Datasource</span> 部分到 <span style="color: #800080;">quartz.properties</span> 文件后，你仍然需要使之对于已配置的 Quartz <span style="color: #800080;">JobStoreTX</span> 是可用的。你可以通过把下面的属性加到属性文件中来做到这一点：<br/><br/>
<span style="color: #800080;">org.quartz.jobStore.DataSource = &lt;DS_NAME&gt;</span><br/><br/>
这个 <span style="color: #800080;">&lt;DS_NAME&gt;</span> 应该与指定给个 <span style="color: #800080;">Datasource</span> 配置的名字相匹配。对于代码 6.2 中的例子来使用 <span style="color: #800080;">Datasource</span>，你应当在 <span style="color: #800080;">quartz.properties</span> 文件中加入下面这行：<br/><br/>
<span style="color: #800080;">org.quartz.jobStore.dataSource = myDS</span><br/><br/>
这个值然后会传递给 <span style="color: #800080;">JobStoreSupport</span> 并且对于你的 <span style="color: #800080;">JobStoreTX</span> 就可用了，这样连接就可以被获取并传递到 <span style="color: #800080;">DriverDelegate</span> 实例。<br/><br/>
<strong>九. 应用 <span style="color: #800080;">JobStoreTX</span> 运行 Quartz<br />
</strong><br />
当你已完成前面的配置步骤时，你的程序就可以准备启动了。正如前面所有的例子那样，你仍然需要一个启动类来从工厂创建一个 Scheduler 实例，并调用它的 <span style="color: #800080;">start()</span> 方法。一个如代码 6.3 中的类就足够了。<br/><br/>
<strong>代码 6.3. 简单的启动类，从命令行调用来启动 Scheduler<br />
</strong>
{{< highlight java >}}
public class SchedulerMain {
    static Log logger = LogFactory.getLog(SchedulerMain.class);

   public static void main(String[] args) {
         SchedulerMain app = new SchedulerMain();
         app.startScheduler();
    }
   public void startScheduler() {
         try {
              // Create an instance of the Scheduler
              Scheduler scheduler =
                       StdSchedulerFactory.getDefaultScheduler();

            logger.info("Scheduler starting up...");
             scheduler.start();

       } catch (SchedulerException ex) {
              logger.error(ex);
       }
    }
}
{{</ highlight >}}
<br/>
当你使用代码 6.3 中的 <span style="color: #800080;">SchedulerMain</span> 类来测试 <span style="color: #800080;">JobStoreTX</span> 配置，你将得到类似于如下那样的输出：<br/><br/>
<span style="color: #800080;">INFO [main] - Quartz Scheduler v.1.5.0 created.<br />
INFO [main] - Using thread monitor-based data access locking (synchronization).<br />
INFO [main] - Removed 0 Volatile Trigger(s).<br />
INFO [main] - Removed 0 Volatile Job(s).<br />
INFO [main] - JobStoreTX initialized.<br />
INFO [main] - Quartz scheduler 'QuartzScheduler' initialized from default resource<br />
file in Quartz package: 'quartz.properties'<br />
INFO [main] - Quartz scheduler version: 1.5.0<br />
INFO [main] - Scheduler starting up...<br />
INFO [main] - Freed 0 triggers from 'acquired' / 'blocked' state.<br />
INFO [main] - Recovering 0 jobs that were in-progress at the time of the last<br />
shut-down.</span><br/><br/>
<span style="color: #800080;">INFO [main] - Recovery complete.<br />
INFO [main] - Removed 0 'complete' triggers.<br />
INFO [main] - Removed 0 stale fired job entries.<br />
INFO [main] - Scheduler QuartzScheduler_$_NON_CLUSTERED started.</span><br/><br/>
日志信息是用 Log4J 显示的，因而它们可能和你实际的输出略有差别。一些事情从输出来看是很明显的。首先，在数据库中没有发现 Trigger 或 Job。这是很重要的，有些时候也是使人困惑之处。用了数据库却未给你加载任何的 Job 或 Trigger：是这样的，因为它无法知道谁来为你加载。这是你自己不得不做的事情，你可以几种方式把 Scheduler 信息存入到数据库中。
