---
title: Quartz Job Scheduling Framework［翻译］第十一章. Quartz 集群 (第三部分)
url: /quartz-job-scheduling-framework-11-3/
date: 2008-08-08T03:51:00-05:00
featured: false
draft: false
type: post
toc: false
# menu: main
usePageBundles: true
categories:
  - Quartz
tags: 
  - Quartz
  - 翻译
comment: true
codeMaxLines: 50
# additional
wpPostId: 352 
wpStatus: publish
views: 617
lastmod: 2010-08-20T13:32:52-05:00
---

<strong>三. 配置 Quartz 使用集群</strong><br/>
<br/>
为 Quartz 配置集群环境的步骤比设置类似的 J2EE 集群环境容易的多：<br/>
<br/>
<strong>1.</strong>  配置每个节点的 <span style="color: #800080;">quartz.properties</span> 文件。<br/>
<br/>
<strong>2.</strong>  配置 JDBC <span style="color: #800080;">JobStore</span>。<br/>
<br/>
<strong>3.</strong>  使用 Scheduler 信息(Job 和 Trigger) 装载数据库。<br/>
<br/>
<strong>4.</strong>  启动每个 Quartz 节点。<!--more--><br/>
<br/>
<strong>·配置节点的 <span style="color: #800080;">quartz.properties</span> 文件</strong><br/>
<br/>
就像是运行 Quartz 在非集群环境中那样，每个 Quartz 应用需要一个 <span style="color: #800080;">quartz.properties</span> 文件。在第三章，“Hello, Quartz” 中提到过，假如你不指定它，会使用默认的 <span style="color: #800080;">quartz.properties</span> 文件(存在于 <span style="color: #800080;">quartz.jar</span> 文件中)。最好是指定这个文件，因为你终究是需求修改一个或多个的设置项。<br/>
<br/>
当使用 Quartz 的集群特性，你需要为每个节点修改 <span style="color: #800080;">quartz.properties</span> 文件。代码 11.1 显示了一个用于集群实例的 <span style="color: #800080;">quartz.properties</span> 文件的例子。属性将在之后讨论。<br/>
<br/>
<strong>代码 11.1. 集群实例的 <span style="color: #800080;">quartz.properties</span> 文件示例<br/>
</strong>
{{< highlight java-properties >}}
#==============================================================
#Configure Main Scheduler Properties
#==============================================================
org.quartz.scheduler.instanceName = TestScheduler1
org.quartz.scheduler.instanceId = instance_one
#==============================================================
#Configure ThreadPool
#==============================================================
org.quartz.threadPool.class = org.quartz.simpl.Simple ThreadPool
org.quartz.threadPool.threadCount = 5
org.quartz.threadPool.threadPriority = 5
#==============================================================
#Configure JobStore
#==============================================================
org.quartz.jobStore.misfireThreshold = 60000
org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX
org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.MSSQLDelegate
org.quartz.jobStore.tablePrefix = QRTZ_
org.quartz.jobStore.dataSource = myDS

org.quartz.jobStore.isClustered = true
org.quartz.jobStore.clusterCheckinInterval = 20000
#==============================================================
#Non-Managed Configure Datasource
#==============================================================
org.quartz.dataSource.myDS.driver = net.sourceforge.jtds.jdbc.Driver
org.quartz.dataSource.myDS.URL = jdbc:jtds:sqlserver://localhost:1433/quartz
org.quartz.dataSource.myDS.user = admin
org.quartz.dataSource.myDS.password = admin
org.quartz.dataSource.myDS.maxConnections = 10
{{</ highlight >}}

<strong>·配置主要的 Scheduler 属性</strong><br/>
<br/>
在这一节中有两个属性应该配置<br/>
<br/>
    ·<span style="color: #800080;">org.quartz.scheduler.instanceName<br/>
</span><br/>
    ·<span style="color: #800080;">org.quartz.scheduler.instanceId<br/>
</span><br/>
这两属性用于多处，用在 JDBC <span style="color: #800080;">JobStore</span> 中和数据库来唯一标识实例。<br/>
<table style="border: 1px;" border="1" width="70%" align="center">

<tbody>

<tr>

<td><strong>集群时为实例 ID 使用 <span style="color: #800080;">AUTO</span></strong><span style="color: #800080;">AUTO</span> 为专门为集群准备的。不幸的是，在某些早期的版本，1.4.5 版所用的机制任何情况下都不会清理旧的实例 ID。1.5.1 版中有一些插入式的实例 ID 生成器，其中一个是基于节点的 IP 地址来生成 ID；只要你在一台给定的机器上仅有一个 Quartz 集群节点时这个生成器工作的很好。集群时应当使用 <span style="color: #800080;">AUTO</span>，因为很多人把 Quartz 放在 EAR 中，分布部署在集群的应用服务器上。这时候，EAR 中必然只有一个 <span style="color: #800080;">quartz.properties</span> 文件，因此它在所有的节点上是相同的。假如实例 ID 是硬编码的，Quartz 集群将不能正常工作，因为所有的节点有着一样的 ID。<span style="color: #800080;">AUTO</span> 就是为解决这个问题的。<br/>
<br/>
一些其他严重的集群问题在 Quartz 1.5.1 被引入。如果你需要对 Quartz 集群，你或许该避免这个版本。</td>

</tr>

</tbody>

</table>

<strong>·配置 <span style="color: #800080;">JobStore</span> 块</strong><br/>
<br/>
为使用 Quartz 的集群，你需要用到 <span style="color: #800080;">JobStoreTX</span> 或者 <span style="color: #800080;">JobStoreCMT</span> 作为 Scheduler 的 <span style="color: #800080;">JobStore</span>。第六章，“Job 存储和持久化” 详细说明了如何设置和使用所提供的这两个 JDBC <span style="color: #800080;">JobStore</span>。从代码 11.1 中，你能发现和第六章所显示的设置是一样的，还有两个附加的属性：<br/>
<br/>
    ·<span style="color: #800080;">org.quartz.jobStore.isClustered<br/>
</span><br/>
    ·<span style="color: #800080;">org.quartz.jobStore.clusterChedkinInterval</span><br/>
<br/>
通过设置 <span style="color: #800080;">org.quartz.jobStore.isClustered</span> 属性为 true，你就告诉了 Scheduler 实例要它参与到一个集群当中。这一属性会贯穿于调度框架的始终，用于修改集群环境中操作的默认行为。<br/>
<br/>
<span style="color: #800080;">org.quartz.jobStore.clusterCheckinInterval</span> 属性定义了Scheduler 实例检入到数据库中的频率(毫秒为单位)。Scheduler 检查是否其他的实例到了它们应当检入的时候未检入；这能指出一个失败的 Scheduler 实例，且当前 Scheduler 会以此来接管任何执行失败并可恢复的 Job。通过检入操作，Scheduler 也会更新自身的状态记录。<br/>
<br/>
<span style="color: #800080;">clusterChedkinInterval</span> 越小，Scheduler 节点检查失败的 Scheduler 实例就越频繁。默认值是 <span style="color: #800080;">15000</span> (即<span style="color: #800080;">15</span> 秒)。<br/>
<br/>
<strong>·配置 JobStore 的 数据源</strong><br/>
<br/>
因为你必须用 JDBC <span style="color: #800080;">JobStore</span> (<span style="color: #800080;">JobStoreTX</span> 或 <span style="color: #800080;">JobStoreCMT</span>) 于集群中，你也需要配置一个不受管理的数据源(所谓 "不受管理的"，我们意思是说数据源不受应用服务器管理)。看代码 11.1 中给 <span style="color: #800080;">JobStoreTX</span> 设置不受管理的数据源的例子。参考第六章中列出的可用属性和它们的允许值。<br/>
<br/>
<strong>·使用 Scheduler 信息装载数据库</strong><br/>
<br/>
就如所有的使用数据库作为 Job 存储的 Quartz 应用一样，你必须加载 Job 信息到数据库中。我们在第六章已谈论过数种完成这个的方法。<br/>
<br/>
其中一种方式是写一个配置经由 JDBC <span style="color: #800080;">JobStore</span> 使用数据库的独立的 Quartz 应用，创建一个 Scheduler 实例，部署所有的 Job 和 Trigger 信息。你可以让应用能通过传递一个参数给命令行来从数据库清除 Job 信息。这种用法的问题在于维护数据库变得非常笨拙的。<br/>
<br/>
另一方式是使用你指定的 RDBMS 所带的查询工具来手工加载信息。这使得更新和删除相当容易，但是这在首次加载数据时可能有问题，除非你明确你正在做什么；我们强烈不建议这么做。<br/>
<br/>
有人发现了使用在第十三章，“Quartz 和 Web 应用” 讨论的 Quartz Web 应用是一种很方便的做法。管理 Job 信息简单，甚至能由非技术性的资源来完成。看第十三章中关于 Quartz Wet 应用的内容，假如你选择这么做，也能够以类似的方式集成 Quartz 到你自己的 GUI 程序中来。<br/>
<br/>
［译者 Unmi 注：对于最后一节的原文，感觉到一阵雾水洒过，仿佛说了个东西含含糊糊，不够明确，不具体。］
