---
title: Quartz Job Scheduling Framework［翻译］第四章. 部署 Job (第一部分)
url: /quartz-job-scheduling-framework-4-1/
date: 2007-12-25T09:24:00-06:00
featured: false
draft: false
type: post
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/https://yanbin.blog/wp-content/uploads/2007/10/quartz-logo.jpeg"
categories:
  - Quartz
tags: 
  - Quartz
  - 翻译
comment: true
codeMaxLines: 50
# additional
wpPostId: 456 
wpStatus: publish
views: 1026
lastmod: 2019-12-11T19:09:23-06:00
---

<strong>第四章. 部署 Job</strong></p>
<br/>
在上一章中，你首次尝试使用了 Quartz 来部署 Job。无可否认地，那些 Job 都不是很复杂，但这个不是重点。你应该轻松的对如何构造并部署 Job 有了相当的了解，更重要的是，由此热情的希望学得更多的东西。在本章中将会继续给你讲述。<br/><br/>
第四章将带领你深入到 Quart 框架的核心部分。可证明的是，这一章对于阅读和理解本书是非常之重要的。调度器(Scheduler) 是此框架的心脏。本章关注于如何使用 Scheduler 来管理你的 Job；如何创建并关联触发器以使 Job 能被触发执行；以及如可选择 calendar 为给定的时程安排提供更多的灵活性。<br/><br/>
<!--more--><br/>
<table border="0" width="70%" align="center">
<tbody>
<tr>
<td>
<em>此刻，什么也没发生，下一刻，仍旧什么也没发生。</em>
<em>道格拉斯.亚当斯，《银河系漫游指南》</em>
</td>
</tr>
</tbody>
</table>
<br/>
<strong>1. Quartz 调度器</strong><br/><br/>
Quartz 框架包含许多的类和接口，它们分布在大概 11 个包中。多数你所要使用到的类或接口放置在 <span style="color: #800080;">org.quartz</span> 包中。这个包含盖了 Quartz 框架的公有 API.<br/><br/>
我们不打算对这个框架的所有类和接口都面面俱到。而所要介绍的是那些有助于你理解 Quartz 如何做它该做事情的组件的子集。图 4.1 展示了一个只留下必要的调度器的精简类图。<br/><br/>
<div align="center">
<strong>图 4.1. Quartz 类图(仅显示主要组件)</strong>
{{< bundle-image src="QuartzFigure4.1.JPG" width="586px">}}
</div>
<br/>
Scheduler 是 Quartz 的主要 API。对于 Quartz 用户来说，多数时候与框架的交互是发生于 Scheduler  之上的。客服端与 Scheduler 交互是通过 <span style="color: #800080;">org.quartz.Scheduler</span> 接口的。这个 Scheduler 的实现，在这种情况下，是一个代理，对其中方法调用会传递到 <span style="color: #800080;">QuartzScheduler</span> 实例上。<span style="color: #800080;">QuartzScheduler</span> 对于客户端是不可见的，并且也不存在与此实例的直接交互。<br/><br/>
<span style="color: #800080;">QuartzScheduler</span> 处在框架根的位置，它是一个引擎驱动着整个框架。并非所有的功能都直接内建到 <span style="color: #800080;">QuartzScheduler</span>，然而，框架为灵活性和可配置性考虑而设计，所以许多重要的功能由分离的组件和子框架实现。这就意味着 Quartz 用户可以用自己某个关键特征实现来替换原有默认实现。即使 <span style="color: #800080;">QuartzScheduler</span> 代理了它的一些职责，但它仍然掌控着整个作业调度流程。<br/><br/>
<strong>·Quartz Scheduler 类层次</strong><br/><br/>
客户端会同两种类型的 Scheduler 交互，如图 4.2. 它们都实现了 <span style="color: #800080;">org.quartz.Scheduler</span> 接口。<br/><br/>
<div align="center">
<strong>图 4.2. <span style="color: #800080;">org.quartz.Scheduler</span> 类层次</strong>
{{< bundle-image src="QuartzFigure4.2.JPG" width="402px" >}}
</div>
<br/>
作为一个 Quartz 用户，你要与实现了 <span style="color: #800080;">org.quartz.Scheduler</span> 接口的类交互。在你调用它的任何 API 之前，你需要知道如何创建一个 Scheduler 的实例。<br/><br/>
<strong>2. Quartz <span style="color: #800080;">SchedulerFactory</span></strong><br/><br/>
尽管你已使用到了 Scheduler 类型了，但你未曾显式的去创建 Scheduler 的实例。取而代之的是用了某个工厂方法来确保了构造出 Sheduler 实例并正确的得到初始化。(工厂设计模式之所以谓之工厂模式是因为它承担了生产对象的职责。在这里是生产了一个 Scheduler 实例)　Quartz 框架为这一目的提供了 <span style="color: #800080;">org.quartz.SchedulerFactory</span> 接口。角色 <span style="color: #800080;">SchedulerFactory</span> 就是用来产生 Scheduler 实例的。当 Scheduler 实例被创建之后，就会存到一个仓库中(<span style="color: #800080;">org.quartz.impl.SchedulerRepository</span>)，这个仓库还提供了通过一个 class loader 查询实例的机制。要使用 Scheduler 实例，客户端必须从工厂（和随同的仓库中）使用不同方法调用来获取到它们。换句话说，要通过工厂创建一个 Scheduler 实例并获取到它需要经由两次方法调用。有一些方便的方法封装了那两个方法，你将很快能看到。<br/><br/>
你可使用两种不同类型的 SchedulerFactory 来创建 Scheduler 实例 (看图 4.3)<br/><br/>
<div align="center">
<strong>图 4.3. 所有的 Scheduler 实例应该由 SchedulerFactory 来创建</strong>
{{< bundle-image src="QuartzFigure4.3.JPG" width="391px" >}}
</div>
<br/>
这两个 Scheduler 工厂分别是 <span style="color: #800080;">org.quartz.impl.DirectoSchedulerFactory</span> 和 <span style="color: #800080;">org.quartz.impl.StdSchedulerFactory</span>. 让我们来逐个检视它们。<br/><br/>
<strong>·使用 <span style="color: #800080;">DirectSchedulerFactory</span></strong><br/><br/>
<span style="color: #800080;">DirectSchedulerFactory</span> 是为那些想绝对控制 Scheduler 实例是如何生产出的人所设计的。代码 4.1 显示了最简单的方式去使用 <span style="color: #800080;">DirectSchedulerFactory</span> 来创建一个 Scheduler 实例。<br/><br/>
<strong>代码 4.1. 使用 </strong><br/><br/>
<strong>DirectSchedulerFactory</strong><br/>
{{< highlight java >}}
public class Listing_4_1 {
     static Log logger = LogFactory.getLog(Listing_4_1.class);

     public static void main(String[] args) {
          Listing_4_1 example = new Listing_4_1();
          example.startScheduler();
     }

     public void startScheduler() {
          DirectSchedulerFactory factory=DirectSchedulerFactory.getInstance();

          try {
              // Initialize the Scheduler Factory with 10 threads
              factory.createVolatileScheduler(10);

              // Get a scheduler from the factory
              Scheduler scheduler = factory.getScheduler();

              // Start the scheduler running
              logger.info("Scheduler starting up...");
              scheduler.start();

          } catch (SchedulerException ex) {
               logger.error(ex);
          }
     }
}
{{</ highlight >}}
<br/>
当使用 <span style="color: #800080;">DirectSchedulerFactory</span> 时，有三个基本的步骤。首先，你必须用静态方法 <span style="color: #800080;">getInstance()</span> 获取到工厂的实例。当你持有了工厂的实例之后，你必须调用其中的一个 <span style="color: #800080;">createXXX</span> 方法去初始化它。如代码 4.1 所示例子中是调用 <span style="color: #800080;">createVolatileScheduler()</span> 方法告诉工厂以十个工作者线程初始化它自己（至于工作者线程的更多内容将在本章的后部分讨论到）。第三步也就是最后一步是通过工厂的 <span style="color: #800080;">getScheduler()</span> 方法拿到 Scheduler 的实例。<br/><br/>
<table style="border: 1px;" border="1" width="70%" align="center">
<tbody>
<tr>
<td><strong>在调用 <span style="color: #800080;">getScheduler()</span> 方法之后调用其中的一个 <span style="color: #800080;">createXXX</span> 方法</strong>
方法 <span style="color: #800080;">createVolatileScheduler()</span> 方法不会返回 scheduler 的实例。<span style="color: #800080;">createXXX()</span> 方法是告诉工厂如何配置要创建的 Scheduler 实例。你必须调用方法 <span style="color: #800080;">getScheduler()</span> 获取到在工厂上执行方法 <span style="color: #800080;">createXXX()</span> 产生的实例。实际上，在调用 <span style="color: #800080;">getScheduler()</span> 方法之前，你必须调用其中一个 <span style="color: #800080;">createXXX()</span> 方法；否则，你将有收到一个 <span style="color: #800080;">SchedulerException</span> 错误，因为根本没有 Scheduler 实例存在。
</td>
</tr>
</tbody>
</table>
<br/>
你可从数个不同的 <span style="color: #800080;">createXXX()</span> 方法中选择，依赖于你想要的 Scheduler 类型和你需要怎样的配置。代码 4.1 中用的是 <span style="color: #800080;">createVolatileScheduler()</span> 方法创建 Scheduler 实例的。方法 <span style="color: #800080;">createVolatileScheduler()</span> 带有单个参数：要创建的线程数量。在图 4.2 中，你已看到还有一个 <span style="color: #800080;">RemoteScheduler</span> 类。你必须要用一个不同的 <span style="color: #800080;">createXXX()</span> 方法去创建 <span style="color: #800080;">RemoteScheduler</span> 实例。有两个版本的方法可用：<br/>
{{< highlight java >}}
public void createRemoteScheduler(String rmiHost, int rmiPort)
  throws SchedulerException;

protected void createRemoteScheduler(String schedulerName,
  String schedulerInstanceId, String rmiHost, int rmiPort)
  throws SchedulerException;
{{</ highlight >}}
<br/>
<span style="color: #800080;">RemoteScheduler</span> 会在第十章，“J2EE 中使用 Quartz”讨论。假如你就是想要一个标准的 Scheduler, 可以调用以下三个版本的方法中的一个：<br/>
{{< highlight java >}}
public void createScheduler(ThreadPool threadPool, JobStore jobStore)
  throws SchedulerException;

public void createScheduler(String schedulerName,
  String schedulerInstanceId, ThreadPool threadPool, JobStore jobStore)
  throws SchedulerException;

public void createScheduler(String schedulerName,
  String schedulerInstanceId, ThreadPool threadPool,
  JobStore jobStore, String rmiRegistryHost, int rmiRegistryPort,
  long idleWaitTime, long dbFailureRetryInterval)
  throws SchedulerException;
{{</ highlight >}}
<br/>
在上一章上，我们用了一个属性文件来初始化 Scheduler。要通过 <span style="color: #800080;">DirectSchedulerFactory</span> 创建一个 Scheduler 实例，你必须传递配置参数给其中的一个 <span style="color: #800080;">createXXX()</span> 方法。在下一节中，我们讨论 <span style="color: #800080;">StdSchedulerFactory</span>，一个 <span style="color: #800080;">SchedulerFactory</span> 版本，它依赖于一系列的属性来配置 Scheduler，而不是通过 <span style="color: #800080;">createXXX()</span> 方法参数来传递配置参数。这样也避免了在代码中对 Scheduler 的配置选项的硬编码。<br/><br/>
<strong>·使用 StdSchedulerFactory</strong><br/><br/>
与 <span style="color: #800080;">DirectSchedulerFactory</span> 形成鲜明对比的是，<span style="color: #800080;">org.quartz.impl.StdSchedulerFactory</span> 依赖于一系列的属性来决定如何生产出 Scheduler 实例。你可以通过以下三种途径向工厂提供那些属性：<br/><br/>
    ·通过 <span style="color: #800080;">java.util.Properties</span> 实例提供<br/><br/>
    ·通过外部属性文件提供<br/><br/>
    ·通过含用属性文件内容的 <span style="color: #800080;">java.io.InputStream</span> 实例提供<br/><br/>
<table style="border: 1px;" border="1" width="70%" align="center">
<tbody>
<tr>
<td><strong>Java 属性文件</strong>
我们这里使用述语“属性文件”，对于 Java 传统来说就是：在一个外部文件中指定一系列的 <span style="color: #800080;">key=value</span>  对，并且每个 <span style="color: #800080;">key=value</span> 对独占一行。
</td>
</tr>
</tbody>
</table>
<br/>
代码 4.2 演示了第一种途径，通过一个 <span style="color: #800080;">java.util.Properties</span> 实例来提供属性。<br/><br/>
<strong>代码 4.2. 使用 <span style="color: #800080;">java.util.Properties</span> 实例创建 <span style="color: #800080;">StdSchedulerFactory</span></strong><br/>
{{< highlight java >}}
public class Listing_4_2 {
     static Log logger = LogFactory.getLog(Listing_4_2.class);

     public static void main(String[] args) {
          Listing_4_2 example = new Listing_4_2();
          example.startScheduler();
     }

     public void startScheduler() {

          // Create an instance of the factory
          StdSchedulerFactory factory = new StdSchedulerFactory();

          // Create the properties to configure the factory
          Properties props = new Properties();

          // required to supply threadpool class and num of threads

          props.put(StdSchedulerFactory.PROP_THREAD_POOL_CLASS,
                    "org.quartz.simpl.SimpleThreadPool");

          props.put("org.quartz.threadPool.threadCount", "10");

          try {

              // Initialize the factory with properties
              factory.initialize(props);

              Scheduler scheduler = factory.getScheduler();

              logger.info("Scheduler starting up...");
              scheduler.start();

         } catch (SchedulerException ex) {
              logger.error(ex);
         }
    }
}

{{</ highlight >}}
<br/>
代码 4.2 提供了一个使用 <span style="color: #800080;">StdSchedulerFactory</span> 创建 Scheduler 实例的很简单的例子。在这个例子中向工厂传递了两个属性，它们分别是实现了 <span style="color: #800080;">org.quartz.spi.ThreadPool</span> 接口的类名和 Scheduler 用来处理 Job 的线程的数量。这两个属性是必须的，因为它们并没有被指定默认值（我们很快在后面讨论它们）<br/><br/>
在代码 4.1 中的 <span style="color: #800080;">DirectSchedulerFactory</span>，我们调用它其中一个 <span style="color: #800080;">createXXX()</span> 方法来初始化工厂。而对于 <span style="color: #800080;">StdSchedulerFactory</span>, 你使用的是一个有效的 <span style="color: #800080;">initialize()</span> 方法。在工厂初始化之后，你就可以调用它的 <span style="color: #800080;">getScheduler()</span> 方法获取到 Scheduler 的实例。使用 <span style="color: #800080;">java.util.Properties</span> 对象传递属性给工厂是一种配置 SchedulerFactory 的方式之一。硬编码配置属性的做法基本不推荐，也是可能的时候应尽力避免的做法。假如你需要修改上一例子中的线程数量，你将不得不修改代码然后重新编译。<br/><br/>
幸运的是，<span style="color: #800080;">StdSchedulerFactory</span> 还有其他的方式来提供必须的属性。工厂也能通过传入一个外部文件名而被初始化，在这个外部文件中包含了这些配置项。应使用 <span style="color: #800080;">initialize()</span> 的替代方法形式如下：<br/>
{{< highlight java >}}
public void initialize(String filename) throws SchedulerException;
{{</ highlight >}}
<br/>
要使文件和属性能被成功加载的话，这个文件必须对于 classloader 是可见的。也就是说它必须在你的应用程序的 classpath 中。假如你用的是 <span style="color: #800080;">java.io.InputStream</span> 去加载文件，你可以使用另一个 <span style="color: #800080;">initialize()</span> 的替代方法如下：<br/>
{{< highlight java >}}
public void initialize(InputStream propertiesStream) throws SchedulerException;
{{</ highlight >}}
<br/>
在第三章，“Hello, Quartz” 你已看到为 <span style="color: #800080;">SchedulerFactory</span> 从一个叫做 <span style="color: #800080;">quartz.properties</span> 的外部文件中加载设置的例子。这个外部属性文件就是要用前面的方法来加载。假如你没有为 <span style="color: #800080;">initialize()</span> 方法指定从哪儿读取属性，那么 <span style="color: #800080;">StdSchedulerFactory</span> 会试图从名为 <span style="color: #800080;">quartz.properties</span> 的文件中加载它们。这就是你在第三章看到的行为。<br/><br/>
<strong>·使用默认的 <span style="color: #800080;">quartz.properties</span> 文件创建 Scheduler</strong><br/><br/>
假如你使用无参的 <span style="color: #800080;">initialize()</span> 方法，<span style="color: #800080;">StdSchedulerFactory</span> 会执行以下几个步骤去尝试为工厂加载属性：<br/><br/>
<strong>1.</strong>  检查 <span style="color: #800080;">System.getProperty("org.quartz.properties")</span> 中是否设置了别的文件名<br/><br/>
<strong>2.</strong>  否则，使用 <span style="color: #800080;">quartz.properties</span> 作为要加载的文件名<br/><br/>
<strong>3.</strong>  试图从当前工作目录中加载这个文件<br/><br/>
<strong>4.</strong>  试图从系统 classpath 下加载这个文件<br/><br/>
<table style="border: 1px;" border="1" width="70%" align="center">
<tbody>
<tr>
<td><strong>在 Quartz Jar 包中的默认 <span style="color: #800080;">quartz.properties</span> 文件</strong></td>
</tr>
</tbody>
</table>
<br/>
上面第4步总是能成功的，因为在 Quartz Jar 包中有一个默认的 <span style="color: #800080;">quartz.properties</span> 文件。假如你想使用另一个替代文件，你必须自己创建一个并确保它在 classpath 上。<br/><br/>
使用 <span style="color: #800080;">StdSchedulerFactory</span> 来创建 Scheduler 实例的方式很普遍，因此在 <span style="color: #800080;">StdSchedulerFactory</span> 直接提供了一个方便的静态方法 <span style="color: #800080;">getDefaultScheduler()</span>，它就是使用前面列出的几个步骤来初始化工厂的。这如代码 4.3 所示。<br/><br/>
<strong>代码 4.3. 使用静态的 <span style="color: #800080;">getDefaultScheduler()</span> 方法创建 Scheduler</strong><br/>
{{< highlight java >}}
    public class Listing_4_3 {
         static Log logger = LogFactory.getLog(Listing_4_3.class);

         public static void main(String[] args) {
              Listing_4_3 example = new Listing_4_3();
              example.startScheduler();
         }

         public void startScheduler() {

              try {
                  // Create a default instance of the Scheduler
                  Scheduler scheduler =
                             StdSchedulerFactory.getDefaultScheduler();
                  logger.info("Scheduler starting up...");
                  scheduler.start();

              } catch (SchedulerException ex) {
                   logger.error(ex);
              }
         }}
{{</ highlight >}}
<br/>
在静态方法 <span style="color: #800080;">getDefaultScheduler()</span> 方法中调用了空的构造方法。假如之前未调用过任何一个 <span style="color: #800080;">initialize()</span> 方法，那么无参的 <span style="color: #800080;">initialize()</span> 方法会被调用。这会开始去按照前面说的顺序加载文件。默认情况下，<span style="color: #800080;">quartz.properties</span> 会被定位到，并从中加载属性。<br/><br/>
<strong>·Scheduler 的功能</strong><br/><br/>
本章到此为止大部分笔墨都在着重论述如何获得一个 Scheduler 的实例。那么一旦你拿到 Scheduler 的实例之后，你能能此做些什么呢？好，现在开始，上面的例子中告诉了你可以调用它的 <span style="color: #800080;">start()</span> 方法。Scheduler 的 API 大概包括了 65 个不同的方法。我们不在此全部枚举出来，但是你需要理解其中的一小部分 API。<br/><br/>
Scheduler 的 API 可以分组成以下三个类别：<br/><br/>
    ·管理 Scheduler<br/><br/>
    ·管理 Job<br/><br/>
    ·管理 Trigger 和 Calendar
