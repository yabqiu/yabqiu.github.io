---
title: Spring 学习点滴，《Spring in Action》笔记（一）
url: /spring-in-action-notes-1/
date: 2007-06-03T00:47:00-05:00
featured: false
draft: true
type: post
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/http://unmi.cc/wp-content/uploads/2016/10/spring-framework-project-logo-200x200.png"
categories:
  - Spring
tags: 
  - Spring
comment: true
codeMaxLines: 50
# additional
wpPostId: 520 
wpStatus: publish
views: 614
lastmod: 2021-05-02T22:33:14-05:00
---

<strong>第二章：装配 Bean</strong></p>
<br/>
<hr /><br/><br/>
&nbsp;<br/><br/>
1. &lt;ref&gt;标签中的 bean, local, parent 三个属性的区别(P53)<br/><br/>
2. &lt;list&gt;&lt;value...&lt;/list&gt;和&lt;set&gt;&lt;value...&lt;/set&gt;可以换着用都可以为 List, Set 以及数组属性赋值(P55)<br/><br/>
3. &lt;map&gt;属性用 spring  进行装匹时 key 值只能是字符串类型，不过一般能满足要求(P55)<br/><br/>
4. 装配 map 属性要用 &lt;entry key="key1"&gt;&lt;value&gt;foo&lt;/value&gt;&lt;/entry&gt;, 而装匹 properties 属性可以写成 &lt;prop key="key1"&gt;foo&lt;/prop&gt;, 这是因为 properties 的值总是字符串，而 map 中很随意(P55)<!--more--><br/><br/>
5. 用 &lt;property name="foo"&gt;&lt;null/&gt;&lt;/property&gt; 形式设置属性为 null, 区别为字符串 "null"(P56)<br/><br/>
6. 通过构造函数注入依赖时，对多参数需要借助于 index 或 type 属性来指定对应哪个参数，index 属性能应付所有情况(P58)<br/><br/>
7. 可为 bean 设置 autowire为四个值， byName, byType, constructor, autodetect， 四种方式自动装匹；也可以在 &lt;beans&gt; 中设置 default-autowire 属性。手动和自动可以混合使用，手动优先。你应该清楚自己在做什么，所以不建议用自动装配(P61)<br/><br/>
8. BeanPostProcessor的方法 postProcessBeforeInitialization 在 bean 初始化之前调用，postProcessAfterInitialization 是在 bean 初始化之后调用，需要注册到 BeanFactory 上，如 factory.addBeanPostProcessor(new BeanPostProcessor(){...})。内置的 ApplicationContextAwareProcessor 注册在了 AbstractApplicationContext 上了(P64)<br/><br/>
9. BeanFactoryPostProcessor 是在 Bean 工厂载入所有 Bean 定义后，实例化 Bean 之前作处理。如果是 AbstractApplicationContext ,那么只需要配置 &lt;bean id="myBeanFactoryPostProcessor" class="com.unmi.MyBeanFactoryPostProcessor"/&gt;, 则会自动注册这个，原有的 BeanFactoryPostProcessor 不可用了，不需要显示式的调用 addBeanFactoryPostProcessor 方法(P67)<br/><br/>
10. 可用 PropertyPlaceholderConfigurer 载入属性文件，然后在其他引用 value 的地方用 ${database.url} 的方式引用(P70)<br/><br/>
11. 用 CustomEditorConfigurer 注册自己的 PropertyEditorSupport 关联特定的 bean 属性的处理，可了解 Spring 有哪些内置的 PropertyEditorSupport(P72)<br/><br/>
12. Spring 用 ResourceBundleMessageSource 处理国际化，配置成<br/><br/>
<pre class="lang:default decode:true ">&lt;bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
    &lt;property name="basename"&gt;
       &lt;value&gt;trainingtext&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre>
<br/>
  会读取 trainingtext.prperties, trainingtext_en_US.properties 等。<br />
  用 Sring text = context.getMessage("button.submit", new Object[0],locale); 或 &lt;sping:message code="button.submit"/&gt; 读取(P73)<br/><br/>
13. 监听事件，配置实现了ApplicationListener的Bean,容器会自动注册它，发布ApplicationEvent时由它处理，事件的处理是同步的(P74)<br/><br/>
14. Bean 实现了 BeanNameAware, BeanFactoryAware 或 ApplicationContextAware 可以感知它自己或所处环境的信息，但这样做却让 Bean 与 Spring 框架耦合起来了(P76)<br/><br/>
<strong>第三章：创建切面<br />
</strong><br/><br/>
<hr /><br/><br/>
15. AOP: spring 有两种代理创建方式，对接口方法用JDK的java.lang.reflect.Proxy类创建代理，对于未实现接口的借助于 CGLIB 库生成目标对象的子类，标记为 final 的方法不能被通知，因为子类中不能覆写该方法(P83)<br/><br/>
16. Spring 只支持方法连接点，应该也是秉着够用就行的道理，直接用 AspectJ 将能做十分细致的活，Spring 2.x 用上了 AspectJ。(P84)<br/><br/>
17. MyEclipse 提供了一种快捷方式来写Bean的配置，从左树上把类拖到打开的 Spring 的配置文件中依提示行事即可，实际使用中看是否真正实用<br/><br/>
18. 在 MethodBeforeAdvice中可以抛异常(或System.exit()，这有点过份了)　阻止目标方法的执行，如果此时抛出的异常是 RuntimeException 或者目标方法申明的异常，将会被 Spring 框架捕获(P86)<br/><br/>
19. MethodInterceptor 能控制目标方法是否真的被调用，用 methodInvocation.proceed() 调用目标方法(P89)<br/><br/>
20. MethodInterceptor 可以返回一个与目标方法不同的对象，但也必须是兼容的，否则出现 ClassCastException 异常(P89)<br/><br/>
21. 实现接口 ThrowsAdvice 的类，必须至少有一个如下形式方法：<br />
    1）void afterThrowing(Throwable throwable)<br />
    2）void afterThrowing(Method method, Object[] args, Object target, Throwable throwable)<br />
    在 ThrowsAdvice 并没有象 MethodBeforeAdvice, MethodAfterAdvice 和 MethodInterceptor 定义了要实现的方法，只是一个不成文的约定，不知作者是如何考虑的，怕定义了两个方法后实现类要实现两个方法（可能只需用到一个方法）而麻烦吗？那至少可以弄一个 ThrowsAdviceAdapter 的东西，Spring 中还确实有这玩艺，但不是那么回事。<br />
    这种 ThrowsAdvice 对实现类不成文的规定，让在 IDE 中写代码不方便，也容易产生错误(P90)<br/><br/>
22. 当你的 ThrowsAdvice 同时实现了上面两个方法时，只有参数多的那个方法有效，只实现第一个方法也是可以的，所以在 ThrowsAdvice 的源代码中只提到要实现第二个方法，所以我就更想不能了，为什么在接口 ThrowsAdvice 中不定义这个方法呢？(P90)<br/><br/>
23. 记录几个书中错误：54页的java.awt应该是java.util。94页的maidService配置中的frequentCustomerAdvisor应该是  frequentCustomerPointcutAdvisor。108页,后面两个 proxyInterfaces 应该是 interceptorNames<br/><br/>
24. 用 NameMatchMethodPointAdvisor 能简单的用通配符控制切入点，但要细致的控制切入点就要用 RegexpMethodPointcutAdvisor 结合正则表达式了, 它可含有类名信息，而 NameMatchMethodPointAdvisor只需考虑方法名的匹配(P90)<br/><br/>
25. 动态切入点的配置方法与静态切入点略有不同，需要申明一个ControlFlowPointcut的Bean(Pointcut)作为DefaultPointcutAdvisor的pointcut属性，然后这个advisor配置到ProxyFactoryBean的interceptorNames，所以想，既然是叫做DefaultPointcutAdvisor,那么是不是别的Pointcut也可以通过这种方式来配置呢？动态切入点很损耗性能，非必要是不用，对JDK1.4会慢5位，对JDK1.3会慢10,对于JDK1.5恐怕也好不到哪儿去(P96)<br/><br/>
26. 觉得 Spring 的引用 IntroductionInterceptor 用起来特麻烦，远没有直接用 AspectJ 来的方便与简练(P100)<br/><br/>
27. 配置 ProxyFactoryBean 时不指定 proxyInterfaces 属性，直接指定 target 为Class，则会用CGLIB生成目标类的子类。即使指定的 proxyInterfaces 属性，设置 ProxyTargetClass 属性为 true，也会用 CGLIB 生成目标类的子类，而不是用JDK的动态代理(P106)<br/><br/>
28. 配置 ProxyFactoryBean 时可以把 target 目标对象配置为interceptorNames的最后一个属性(P108)<br/><br/>
29. 强大的自动代理：BeanNameAutoProxyCreator 和 DefaultAdvisorAutoProxyCreator。DefaultAdvisorAutoProxyCreator实现了 BeanPostProcessor 接口，它只能与 Advisor 配合使用，自动的处理所有的 Advisor (P109)<br/><br/>
30. 看到29条中的自动代理，让我回想起可以为一批 Bean 批量的增加 toString() 方法，只是那些 bean 必须通过 getBean()得来才能看到效果
