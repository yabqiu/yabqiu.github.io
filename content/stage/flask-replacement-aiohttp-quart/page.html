---
title: Flask 的替代品 aiohttp 和 Quart
url: /flask-replacement-aiohttp-quart/
date: 2020-07-12T02:27:22-05:00
featured: false
draft: true
type: post
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/http://unmi.cc/wp-content/uploads/2016/06/python-icon-200x200.png"
categories:
  - Flask
tags: 
  - aiohttp
  - quart
comment: true
codeMaxLines: 50
# additional
wpPostId: 10377 
wpStatus: publish
views: 3407
lastmod: 2021-12-07T22:32:21-06:00
---

本来只是为了研究一下 Flask  怎么去支持早已在 Python 的支持的 coroutine 功能，没想步子越迈越大，直顶到 aiohttp Web 服务器和 Flask  的异步实现版本 Quart。Flask 得费了好一番功夫去获得 <code>EventLoop</code>，可知 aiohttp 和 Quart 的路由方法直接就允许 <code>async</code> 的，那个 <code>EventLoop</code> 自然就在其中。从 <code>async</code> 的路由方法出发去调用别的异步方法就是一件十分轻松的事情。<br/><br/>
下面来稍稍体验一下用分别用  aiohttp 和 Quart 实现简单的异步服务器，我们的关注点在它的异步路由。<br/><br/>
<!--more--><br/><br/>
<h3>异步的  aiohttp Web 服务器</h3><br/><br/>
aiohttp 除了 HTTP 客户端功能，还有服务端端，因它的异步特性，可以用它建立一个异步的 Web 服务器，也就是它的路由方法也是异步的，完全可用它来替代 Flask 本身。<br/><br/>
用 <code>pip install aiohttp</code> 安装<br/><br/>
下面是一个简单的例子<br/><br/>
<pre class="lang:default decode:true">from aiohttp import web
import asyncio
import threading<br/><br/>
async def hello(request):
    loop = asyncio.get_event_loop()
    thread_name = threading.current_thread().name
    return web.json_response({'event_loop': str(loop), 'thread': thread_name})<br/><br/>
app = web.Application()
app.add_routes([web.get('/', hello)])   # 只能注册 async 修饰的方法
web.run_app(app)</pre>
<br/>
由于 hello() 方法加了 <code>async</code> 关键字，可直接由路由 <code>/</code> 关联来执行，所以它是有一个 <code>EventLoop</code> 在里头的，加了一行代码在控制台打印出该 <code>EventLoop</code>。同是我们也来观察一下它用什么线程来处理客户端请求。aiohttp 服务启动的默认端口号是 8080<br/><br/>
<blockquote>
======== Running on http://0.0.0.0:8080 ========<br />
(Press CTRL+C to quit)
</blockquote>
<br/>
发出请求<br/><br/>
<blockquote>
$ curl http://localhost:8080/<br />
{"event_loop": "&lt;_UnixSelectorEventLoop running=True closed=False debug=False&gt;", "thread": "MainThread"}
</blockquote>
<br/>
比起 Flask 应用 coroutine 时不需要显式的用  <code>asyncio.run()</code> 或用下面几行代码<br/><br/>
<pre class="lang:default decode:true">loop = asyncio.new_event_loop()
asyncio.set_event_loop(loop)<br/><br/>
loop.run_until_complete(asyncio.gather(tasks))</pre>
<br/>
不过 <code>aiohttp</code> 的服务总是用主线程去处理客户端请求，那就是说使用 <code>aiohttp</code> 做服务器的话，需要各个层所有的方法都是 <code>async</code> 的，这样多个请求之前才不至于互相阻塞。同时 <code>aiohttp</code> 用 <code>app.add_routes()</code> 注册路由时，只能支持 <code>async</code> 修饰的方法，也就是说 <code>asiohttp</code> 不支持非异步的方法。这要求后端的所有实现方法必须小心，一旦调用了非异步方法将阻塞其他的请求。<br/><br/>
<h3>Flask 的超集版本 Quart</h3><br/><br/>
Quart 直接被定义为 Flask 的超集，支持异步路由，使用了 Flask 的 API，支持 Flask 的扩展，还添加了一些 Flask 不具备的功能。Quart 当前版本 0.13.0，它从 0.7.0 开始需要 Python 3.7.0 或更高版本的。<br/><br/>
用 <code>pip install quart</code> 安装<br/><br/>
下面来看熟悉的味道，同样测试 <code>async</code> 和 非 <code>async</code> 两个路由方法<br/><br/>
<pre class="lang:default decode:true ">from quart import Quart, jsonify
import asyncio
import threading<br/><br/>
app = Quart(__name__)<br/><br/>
@app.route('/async')
async def hello_async():
    loop = asyncio.get_event_loop()
    thread_name = threading.current_thread().name
    return jsonify({'event_loop': str(loop), 'thread': thread_name})<br/><br/>
@app.route('/sync')
def hello_sync():
    loop = None
    try:
        loop = asyncio.get_event_loop()
    except RuntimeError:
        pass
    thread_name = threading.current_thread().name
    return jsonify({'event_loop': str(loop), 'thread': thread_name})<br/><br/>

app.run(debug=True)</pre>
<br/>
<code>python app.py</code> 启动它，同样是监听在 <code>5000</code> 号端口<br/><br/>
<blockquote>
Running on http://127.0.0.1:5000 (CTRL + C to quit)<br />
[2020-07-13 11:26:01,137] Running on 127.0.0.1:5000 over http (CTRL + C to quit)
</blockquote>
<br/>
访问及结果<br/><br/>
<blockquote>
$ curl http://localhost:5000/async<br />
{<br />
  "event_loop": "&lt;_UnixSelectorEventLoop running=True closed=False debug=True&gt;",<br />
  "thread": "MainThread"<br />
}
$ curl http://localhost:5000/sync<br />
{<br />
  "event_loop": "None",<br />
  "thread": "ThreadPoolExecutor-0_0"<br />
}
</blockquote>
<br/>
同样，既然是路由方法上可用 <code>async</code> 关键字，自然它在执行时能拿到当前的  <code>EventLoop</code>，调用其他的 <code>async</code> 方法不在话下。与 <code>aiohttp</code> 一样，<code>async</code> 的路由方法总是由主线程来处理请求。非 <code>async</code>  的路由方法由线程池来处理，这比 Flask 每请求创建一个新的线程要先进一些。<br/><br/>
Quart 同时支持异步和非异步的方法，这给了我们更多的灵活性，比如使用非 <code>async</code> 路由方法时，某些地方我们可以手动的用 <code>EventLoop</code> 来调度，而不一定要求一切 async。<br/><br/>
<h3>轻松搞上 websocket</h3><br/><br/>
Flask 支持 websocket 需要安装一个 flask-socketio 扩展，而 Quart 更简单，有装饰器支持<br/><br/>
<pre class="lang:default decode:true ">from quart import websocket<br/><br/>
@app.websocket('/ws')
async def ws():
    while True:
        await websocket.sned('hello')</pre>
<br/>
值得一试<br/><br/>
<h3>一个获得 <code>EventLoop</code> 的工具方法</h3><br/><br/>
对于 Quart 中异步或同步路由中都想获得 <code>EventLoop</code> 进行更精细的方法调度，可以用下面的工具方法来获得或创建一个新的 <code>EventLoop</code><br/><br/>
<pre class="lang:default decode:true ">def get_event_loop():
    try:
        event_loop = get_event_loop()
    except RuntimeError:
        event_loop = asyncio.new_event_loop()
        asyncio.set_event_loop(event_loop)<br/><br/>
    if event_loop.is_running():
        raise RuntimeError("called from a running event loop")
    return event_loop
</pre>
<br/>
线程上存在直接返回，否则创建一个 <code>EventLoop</code>, 如果是同步路由方法，必须自己用 <code>event_loop.run_until_complete(...)</code> 发起协程的执行，相当于进行 Promise 的最终兑现。<br/><br/>
<h3>总结一下：</h3><br/><br/>
<ol>
    <li>aiohttp 只支持 <code>async</code> 路由方法，所有请求都在主线程中处理，任何非异步方法的调用都将阻塞其他的请求</li>
    <li>Quart 同时支持 <code>async</code> 和非 <code>async</code> 路由方法，<code>async</code> 路由由主线程处理，这一点与 <code>aiohttp</code> 的路由是一样的。</li>
    <li>Quart 的非 <code>async</code> 路由方法由线程池处理，比 Flask 每次请求新建线程要好</li>
    <li>Quart 允许我们同时用非 <code>async</code> 路由与 <code>EventLoop</code> 来控制</li>
    <li>在 aiohttp 或 Quart 中使用 <code>async</code> 路由时反而要倍加小心，最好是所有方法都是 <code>async</code> 的</li>
</ol>
