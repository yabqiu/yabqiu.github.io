---
title: "两种最基本的排序算法: 冒泡和选择"
url: /two-basic-sorting-algorithms/
date: 2020-04-14T17:36:28-05:00
featured: false
draft: true
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/https://yanbin.blog/wp-content/uploads/2020/04/algorithm-icon.png"
categories:
  - Algorithm
tags: 
  - 算法
comment: true
codeMaxLines: 50
# additional
wpPostId: 10139 
wpStatus: publish
views: 477
lastmod: 2020-04-26T17:06:35-05:00
---

因 COVID-19 漫延各自居家，也更有闲时，便拣起一本关于算法的书籍来研究。本不是科班出身，算法方面自然是自己的薄弱环节。平时用各种 SDK，只大概听说了些算法，仅能就自己如何选择哪种实现而作为参考。<br/><br/>
如今阅读的是一本入门的书籍，名为 《算法图解》，英文版书名是 《Grokking Algorithms》。 该书图文并茂，十分适合初学者，关于排序最基本莫过于冒泡与选择排序。该书并未提及冒泡，而是直接从选择排序切入，在阅读本书之前我就一直对这两咱排序方式傻傻不分。一直以为头脑中的选择排序就是冒泡排序，那就来看下什么是真正的冒泡排序。<!--more--><br/><br/>
<h3>冒泡排序</h3><br/><br/>
以 Python 代码为例：<br/><br/>
<pre class="lang:python decode:true">items = [6, 5, 3, 1, 8, 7, 2, 4]
length = len(items)<br/><br/>
for i in range(length):    #1
    for j in range(length - i - 1):
        if items[j] &gt; items[j + 1]:
            items[j], items[j + 1] = items[j + 1], items[j]  #2<br/><br/>
print(items)</pre>
<br/>
#1: range(length) 和 range(0, length) 是一样的<br />
#2: 这是 Python 交换两个值的写法，相当于用临时变量的方式 tmp = items[j]; items[j] = items[j + 1]; items[j + 1] = tmp<br/><br/>
 网上找了一张非常直观的动态演示了整冒泡排序的过程<a href="https://yanbin.blog/wp-content/uploads/2020/04/bubble_sorting.gif"><img class="aligncenter wp-image-10143 size-full" src="https://yanbin.blog/wp-content/uploads/2020/04/bubble_sorting.gif" alt="" width="500" height="151" /></a>该图来自于 <a href="http://syllabus.cs.manchester.ac.uk/ugt/2018/COMP26120/SortingTool/bubble_sort_info.html">Sorting Algorithms - Bubble Sort</a><br/><br/>
下面可以看到的更生动现实的排序执行过程<br/><br/>
<iframe width="820" height="420" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=items%20%3D%20%5B6,%205,%203,%201,%208,%207,%202,%204%5D%0Alength%20%3D%20len%28items%29%0A%20%0Afor%20i%20in%20range%28length%29%3A%0A%20%20for%20j%20in%20range%28length%20-%20i%20-%201%29%3A%0A%20%20%20%20if%20items%5Bj%5D%20%3E%20items%5Bj%20%2B%201%5D%3A%0A%20%20%20%20%20%20items%5Bj%5D,%20items%5Bj%20%2B%201%5D%20%5C%0A%20%20%20%20%20%20%20%20%3D%20items%5Bj%20%2B%201%5D,%20items%5Bj%5D%0A%20%0Aprint%28items%29&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=1&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false"><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span> </iframe><br/><br/>
前面代码中的数字列表也是基于这个图来选择的。对冒泡排序大意的理解可以这样的<br/><br/>
<ol>
    <li>冒泡排序的每一步只作相邻两元素的交换</li>
    <li>交换后的右端元素继续与下一个元素比较</li>
    <li>大循环每次向左收缩一个元素</li>
    <li>每次大循环都能把当前子列表中最大的元素冒泡到最右端</li>
</ol>
<br/>
冒泡排序的时间复杂度是 O(n<sup>2</sup>)<br/><br/>
冒泡排序效率最低效，存在过多的比较与交换，但它却有一个其他排序算法没有的好处，当某轮大循环(比如第一轮大循环) 中没有发生一次交换，那么说明排序已完成，可以立即返回。比如说对于有序集合，扫一遍就能完成 "排序"，效率就是 O(n)。看下面冒泡排序也能处理 100 百有序集合的 "排序"<br/><br/>
<pre class="lang:default decode:true ">def bubble_sort(items):
    exchanges = True
    for i in range(len(items)):
        if not exchanges:
            return
        exchanges = False
        for j in range(len(items) - i - 1):
            if items[j] &gt; items[j + 1]:
                exchanges = True
                items[j], items[j + 1] = items[j + 1], items[j]<br/><br/>

bubble_sort(list(range(1000000)))</pre>
<br/>
&nbsp;<br/><br/>
<h3>选择排序</h3><br/><br/>
相对于冒泡排序，选择排序我认为是一种更好理解最直截了当的排序方式，下面用 Python 代码演示<br/><br/>
<pre class="lang:python decode:true">items = [6, 8, 3, 5, 9, 10, 7, 2, 4, 1]<br/><br/>
length = len(items)
for i in range(length):
    for j in range(i+1, length):
        if items[i] &gt; items[j]:
            items[i], items[j] = items[j], items[i]<br/><br/>
print(items)</pre>
<br/>
看实际执行过程：<br/><br/>
<iframe width="890" height="440" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=items%20%3D%20%5B6,%208,%203,%205,%209,%0A%20%20%20%20%20%20%20%20%20%2010,%207,%202,%204,%201%5D%0A%0Alength%20%3D%20len%28items%29%0Afor%20i%20in%20range%28length%29%3A%0A%20%20for%20j%20in%20range%28i%2B1,%20length%29%3A%0A%20%20%20%20if%20items%5Bi%5D%20%3E%20items%5Bj%5D%3A%0A%20%20%20%20%20%20items%5Bi%5D,%20items%5Bj%5D%20%5C%0A%20%20%20%20%20%20%3D%20items%5Bj%5D,%20items%5Bi%5D%0A%0Aprint%28items%29&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=2&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false"><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span> </iframe><br/><br/>
同样找来了一张图<a href="https://yanbin.blog/wp-content/uploads/2020/04/selection-sort.gif"><img class="aligncenter wp-image-10146" src="https://yanbin.blog/wp-content/uploads/2020/04/selection-sort.gif" alt="" width="650" height="371" /></a>选择排序的意图非常明确，假如是从小到大的顺序排序，从左至右一个个位置上选择出剩余列表中最小的值<br/><br/>
<ol>
    <li>位置 1 处要放最小值，循环从右端子列表中选择谁比它还小，是的话交换值</li>
    <li>然后同样的办法确定位置 2 处的值，子列表向右边收缩</li>
    <li>每次大循环确定左边一个位置上的值</li>
</ol>
<br/>
选择排序的时间复杂度也是是 O(n<sup>2</sup>)，但操作上比冒泡排序少一些，因为冒泡排序邻近元素相比较，交换次数要多，效率上选择排序比冒泡排序高那么一点点。<br/><br/>
具体比较 10 万次对列表 [6, 8, 3, 6, 9, 10, 7, 2, 4, 1] 的排序，我测试选择和冒泡排序的平均时间分别为 1.58608 和 1.87929 秒，选择排序比冒泡快 15.6%。<br/><br/>
链接：<br/><br/>
<ol>
    <li><a href="https://algorithm-visualizer.org/">Algorithm Visualizer</a></li>
    <li><a href="http://syllabus.cs.manchester.ac.uk/ugt/2018/COMP26120/SortingTool/index.html">Sorting Algorithms</a></li>
    <li><a href="https://visualgo.net/en">VisuAlgo</a></li>
</ol>
