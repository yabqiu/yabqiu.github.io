---
title: 巩固 Java Future 的使用
url: /consolidate-use-of-java-future/
date: 2016-12-22T00:13:11-06:00
featured: false
draft: true
toc: false
# menu: main
usePageBundles: true
categories:
  - Java/JEE
tags: 
  - Future
  - CompletableFuture
comment: true
codeMaxLines: 50
# additional
wpPostId: 7645 
wpStatus: publish
views: 989
lastmod: 2021-05-11T11:32:55-05:00
---

<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html">Future</a> 还是一 Java 1.5 带进来的产物，但过去那么多年实际代码中却很少有直接接触, 大约它多是隐匿在各种现成框架中默默的为我们服务。Future 本身不代表着多线程，而是代表着需异步计算的结果, 将来的一个期待，至于后来真正的结果不可知。在此之前想要获得一个 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html">Runnable</a> 在其他线程中的计算结果颇费波折，有了 Future 加之它身后的 <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Callable.html">Callable</a> 一切就变得简单了。</p>
<br/>
对比一下 Java 1.5 前后的下面几个概念<br/><br/>
<ol>
    <li>Callable 相当于之前的 Runnable, 只是 Callable 是有返回值的</li>
    <li>ExecuteService.submit(callable): Future 就类似于之前的 Thread(runnable)<br />
只是前者 submit 后立即执行，通过 get() 获得结果，后者用 start() 方法启动，runnable 是没有结果的。如果你也不想关心 Future 的结果也能 ExecuteService.submit(runnable)</li>
</ol>
<br/>
只有 callable 被提交(到线程池) 后返回的 Future 才可能会有结果, 所以下面的代码永远等不到结果<br/><br/>
<blockquote>
Future&lt;String&gt; future = new FutureTask&lt;&gt;(() -&gt; "Never");<br />
String result = future.get();
</blockquote>
<br/>
最容易理解的 Future 基本使用代码如下：<!--more--><br/><br/>
<pre class="lang:default decode:true"> ExecutorService executor = Executors.newCachedThreadPool(); //这是众多线程池类型的一种
 Future&lt;String&gt; future = executor.submit(() -&gt; { //Lambda 是一个 callable， 提交后便立即执行，这里返回的是 FutureTask 实例
   System.out.println("Running task...");
   Thread.sleep(5000);
   return "Task return";
 });<br/><br/>
 try {
   Thread.sleep(1000);
 } catch (InterruptedException e) {
 }<br/><br/>
 System.out.println("Do something else");  //前面的的 Callable 在其他线程中运行着，现在想做别的事情都不影响<br/><br/>
 try {
   System.out.println(future.get());  //等待 future 的执行结果
 } catch (InterruptedException | ExecutionException e) {
 }<br/><br/>
 executor.shutdown();  //不关闭的话程序都不会退出</pre>
<br/>
上面代码的执行结果如下<br/><br/>
<blockquote>
Running task...<br />
Do something else<br />
Task return
</blockquote>
<br/>
可以看出任务 submit() 之后立即执行，相当于 <code>new Thread(...).start()</code>. 注意 future.get() 需强制捕获的异常，它还有一个重载方法 <code>future.get(long timeout, TimeUnit unit)</code>, 指定等待多长时间，超时报 TimeoutException. 无参的 <code>get()</code> 永远的等待。<br/><br/>
Future 的其他几个方法如下：<br/><br/>
boolean cancel(boolean mayInterruptIfRunning): 可以取消一个任务，调用能否成功因情况而定<br />
boolean isCancelled()<br />
boolean isDone()<br/><br/>
我们也可以通过查询 <code>isDone()</code> 看任务是否执行完成，比如<br/><br/>
<pre class="lang:default decode:true">while(!future.isDone()) {
  Thread.sleep(1000);
  System.out.println("Waiting....")
}
future.get();    //到这时 future 已经执行完</pre>
<br/>
Future 解决了线程返回值的问题，但到了 Java 8 还不够，我们还需要处理多个 Future 之间的依赖，竞争关系，因此又带来了更强悍的 Future 的新实现 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture</a>。<br/><br/>
进一步学习当中......<br/><br/>
<hr /><br/><br/>
补充一下，在 Java 1.5 之前想要获得线程的执行结果可以参考如下代码<br/><br/>
<pre class="lang:default decode:true ">// AtomicReference&lt;String&gt; reference = new AtomicReference&lt;&gt;();<br/><br/>
 StringBuffer sb = new StringBuffer();<br/><br/>
 new Thread(() -&gt; {
   try {
     Thread.sleep(5000);
   } catch (InterruptedException e) {
     e.printStackTrace();
   }
    // reference.set("I'm done");
     sb.append("I'm done");
 }).start();<br/><br/>
// while(reference.get() == null) {
// }<br/><br/>
// System.out.println(reference.get());<br/><br/>
 while(sb.length() == 0) {
 }<br/><br/>
 System.out.println(sb.toString());</pre>
<br/>
因为 <code>AtomicReference</code> 也是来自于 JDK 1.5 的 concurrent 的 API，所以用了早先线程安全的 <code>StringBuffer</code> 类。
