---
title: 读《Objective-C培训资料》的摘要
url: /objective-c-training-notes/
date: 2011-05-25T18:16:17-05:00
featured: false
draft: false
type: post
toc: false
# menu: main
usePageBundles: true
categories:
  - iOS
tags: 
  - ios
  - objective-c
  - apple
comment: true
codeMaxLines: 50
# additional
wpPostId: 3606 
wpStatus: publish
views: 972
lastmod: 2011-07-01T09:20:09-05:00
---

本文为阅读文档：<a href="http://unmi.cc/wp-content/uploads/2011/05/Objective-C培训资料.pdf" target="_blank">Objective-C 培训资料</a> 的一些摘要，在此记录，以备回顾。<br/>
<br/>
#define nil NULL<br/>
bool型与c/c++是一样的，非0为 TRUE/YES, 0 为 FALSE/NO, 用 if(flag==YES) 就要注意了，此时 YES 就是 1，不过你直接用 if(flag) ..... 来判断就只要不是 0 就成立。<br/>
<br/>
#import 和 c/C++ 的 include 一样也有 &lt;&gt; 和 "" 两种查找方式。但是它不怕重复引入。<br/>
<br/>
NSLog() 会自动在输出后加 \n，相当于 System.out.println().<br/>
<br/>
Objective-C 的对象需要直接或间接的继承自 NSObject。Objective-C 的 @interface 相当 java 的 class，而 @protocol 才是 Java 的 interface。类声明的基本方式如下:<br/>
<br/>
@interface &lt;#class#&gt; : &lt;#superclass#&gt;<br/>
{<br/>
&nbsp; &nbsp;&lt;#ivars#&gt;<br/>
}<br/>
<br/>
&lt;#methods#&gt;<br/>
<br/>
@end<!--more--><br/>
<br/>
@implementation &lt;#class#&gt;<br/>
<br/>
&lt;#methods#&gt;<br/>
<br/>
@end<br/>
<br/>
(-) 表示实例方法<br/>
(+) 是类方法，即静态方法<br/>
<br/>
函数的形式是：- (void) setNum: (int) n;<br/>
多个参数用 - (void) setNum: (int) n: (int)m;&nbsp; 用 [car setNum(1:3)]; 调用<br/>
或者给第一个之后的参数指定参数名，如<br/>
- (void) setNum: (int)n andHeight: (int)h andWidth: (int)w;&nbsp; 用 [car setNum: 1 andHeight: 5 andWidth: 10];<br/>
Objective-C 的方法参数有点怪异，第一个参数是没有参数名的，如果硬要说有，那就是方法名，统一说来，见到冒号，冒号前面那个就是参数名<br/>
<br/>
没有指定返回类型就是 id 类型，输入参数默认也是 id 类型。<br/>
<br/>
实例化：<br/>
<br/>
Car* car = [[Car alloc] init]; 或 Car* car = [Car new]; 通常用前一种。<br/>
<br/>
释放对象 [car release]; iPhone 平台不支持垃圾回收机制。<br/>
<br/>
#define 和 C 的一样<br/>
<br/>
数据声明及初始化 intPtr = (int[100){[0]=1, [50]=50, [51]=200};<br/>
<br/>
int number;<br/>
scanf("%i", &amp;number);<br/>
NSLog(@"Number is: %i", number);<br/>
<br/>
输入<br/>
<br/>
@protected @private $public @package 修饰变量，voaltile 和&nbsp; const<br/>
<br/>
所有方法都是 public 的，私有方法该如何声明呢？<br/>
<br/>
NSString 和 NSMutableString 一个是不可变，一个是可变的, 相应的有 NSArray 和 NSMutableArray.<br/>
<br/>
NSLog(@"String HERE %@", @"Hello world.");<br/>
<br/>
[object retain] [object release]&nbsp; 分别使引用计数加 1 和减 1。<br/>
<br/>
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];<br/>
RetainTracker *tracker;<br/>
tracker = [RetainTracker new]; // count: 1<br/>
[tracker retain]; // count: 2<br/>
[tracker autorelease]; // count: still 2<br/>
[tracker release]; // count: 1<br/>
NSLog (@"releasing pool");<br/>
[pool release];<br/>
// gets nuked, sends release to tracker<br/>
<br/>
当使用alloc、new 或者通过copy 消息（生成接受对象的一个副本）创建一个对象，对象的引用计数器被设置成1。发送retain 消息将增加引用计数器，release 消息减1。<br/>
<br/>
不必费心地释放其他方法返回的对象，这不是你的责任<br/>
<br/>
通常的写法：<br/>
- （id）init<br/>
{<br/>
&nbsp; &nbsp; if （self = [super init]）{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; . . .<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; return (self) ;<br/>
}<br/>
注：在自己的初始化方法中，需要调用自己的指定的初始化函数或者超类的指定的初始化函数。一定要将超类的初始化函数的值赋给self 对象，并返回你自己的初始化方法的值。超类可能决定返回一个完全不同的对象。<br/>
<br/>
存取器(属性)的例子：<br/>
<br/>
//Car.h 文件<br/>
#import &lt;Cocoa/Cocoa.h&gt;<br/>
<br/>
@interface Car ： NSObject {<br/>
&nbsp; &nbsp; NSString *name ;<br/>
}<br/>
@property （copy）NSString *name ；//表明类的对象具有 NSString* 类型的 name 属性，表明可以调用 - setName 和 - name 方法，即相应的 setter/getter 方法<br/>
<br/>
@end //Car<br/>
<br/>
//Car.m 文件<br/>
#import "Car.h"<br/>
@implementation Car<br/>
@synthesize name ; //表示实际创建该属性的访问器，即 - setName 和 -name 方法<br/>
<br/>
@end //Car<br/>
<br/>
//*********************************************************************************<br/>
最后就可以在main（）函数中使用点表示法给对象赋值<br/>
Car *car = [[Car alloc] init] ;<br/>
car.name = @"Herbie" ;&nbsp; //调用了 setName 方法<br/>
NSLog("%@", car.name);&nbsp; //调用了 name 方法<br/>
<br/>
@property 和 @synthesize 可同时指定多个。<br/>
@property (copy) int width, height;<br/>
@synthesize width, heigth;<br/>
<br/>
该技术同样适用于int、char、BOOL、struct 甚至可以定义一个NSRect 类的对象的特性<br/>
<br/>
@property （readwrite，copy）NSString *name；//对象可读写，对象将被复制<br/>
@property （readwrite，retain）NSString *name；//对象可读写，对象将被保持<br/>
@property （readonly）NSString *name；////对象只读<br/>
<br/>
C/C++中支持的内存方式Objective-C 都支持（例如new,delete 或malloc,free）， Objective-C 也有自己对象分配内存的方法：alloc,allocWithZone。<br/>
<br/>
Objective-C 不支持多继承, 可以通过Objective-C 的分类和协议特性获取多继承的优点<br/>
<br/>
@class XYPoint; //代替#import "XYPoint.h"<br/>
//使用@class 指令提高效率，编译器不需要处理整个XYPoint.h 文件，只需要知道XYPoint 是一个类名， 但是如果需要引用XYPoint 类中方//法， @class 指令是不够的，必须用#import "XYPoint.h"。<br/>
<br/>
分类的应用：<br/>
<br/>
#import &lt;Foundation/Foundation.h&gt;<br/>
<br/>
@interface Car : NSObject<br/>
{<br/>
&nbsp; &nbsp; int c;<br/>
}<br/>
<br/>
-(id) init;<br/>
-(void) toString;<br/>
@end<br/>
@implementation Car<br/>
<br/>
-(id) init<br/>
{<br/>
&nbsp; &nbsp; if(self=[super init])<br/>
&nbsp; &nbsp; {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; c = 100;<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; return self;<br/>
}<br/>
-(void) toString<br/>
{<br/>
&nbsp; &nbsp; NSLog(@"YES id: %i", c); //分类后最原始的方法访问不到了<br/>
}<br/>
<br/>
@end<br/>
<br/>
//进行分类，类名与已有类名相同<br/>
@interface Car(Unmi) //括号中任意指定一个 Category 名<br/>
<br/>
-(void) toString;<br/>
<br/>
@end<br/>
<br/>
@implementation Car(Unmi)<br/>
<br/>
-(void) toString //分类方法的实现<br/>
{<br/>
&nbsp; &nbsp; NSLog(@"Category id: %i", c); //分类中的方法可以引用变量<br/>
}<br/>
<br/>
@end<br/>
<br/>
int main (int argc, const char * argv[]) {<br/>
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];<br/>
<br/>
Car* car = [[Car alloc] init];<br/>
[car toString]; //这行的输出是 Category id: 100<br/>
<br/>
[pool drain];<br/>
<br/>
return 0;<br/>
}<br/>
<br/>
关于分类的一些注意事项<br/>
A、尽管分类可以访问原始类的实例变量，但是它不能添加自身的任何变量。如果需要添加变量，可以考虑创建子类。<br/>
B、分类可以重载该类中的另一个方法，但是通常认为这种做法不可取。因为，重载之后，再不能访问原来的方法。<br/>
C、可以拥有很多分类。<br/>
D、和一般接口部分不同的是，不必实现分类中的所有方法。这对于程序扩展很有用，可以在该分类中声明所有方法，然后在一段时间之后才实现它。<br/>
E、通过使用分类添加新方法来扩展类不仅会影响这个类，同时也会影响它的所有子类。<br/>
<br/>
@synthesize name=_name; 的用法：<br/>
<br/>
@interface Car : NSObject<br/>
@property (copy) NSString* name;<br/>
@end<br/>
@implementation Car<br/>
@synthesize name=_name; //这个的效果会同时声明一个 _name 实例变量，方便于内部操作<br/>
@end<br/>
<br/>
上面相当于，声明了一个实例变量<br/>
<br/>
@interface Car : NSObject<br/>
{<br/>
&nbsp; &nbsp; NSString* _name;<br/>
}<br/>
@property (copy) NSString* name;<br/>
@end<br/>
@implementation Car<br/>
@synthesize name;<br/>
@end<br/>
<br/>
这样在实例方法中就可以直接引用 _name, 如<br/>
-(void) foo<br/>
{<br/>
&nbsp; &nbsp; _name = @"abc";<br/>
}<br/>
<br/>
协议间也是可以相互继承的，并且不能定义成员变量，只能定义方法。protocol 的声明方式：<br/>
<br/>
@protocol MyProtocol<br/>
- (void)myProtocolMethod;<br/>
@end<br/>
<br/>
应用协议的代码：<br/>
@interface Cat : NSObject &lt;myProtocol&gt;;<br/>
可以应用多个协议<br/>
@interface Cat : NSObject &lt;myProtocol, myProtocol2&gt;<br/>
<br/>
应用了协议必须实现协议中定义的方法，虽然未实现协议中的方法编译能通过，但运行时会报错的：<br/>
<br/>
2011-05-24 15:05:35.065 test[5781:a0f] -[Cat myProtocolMethod]: unrecognized selector sent to instance 0x10010c6b0<br/>
2011-05-24 15:05:35.083 test[5781:a0f] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[Cat myProtocolMethod]: unrecognized selector sent to instance 0x10010c6b0'<br/>
<br/>
有关协议的注意事项：<br/>
A、如果一个类遵守某项协议，那么它的子类也遵守该协议。<br/>
B、通过在类型名称之后的尖括号中添加协议名称，可以借助编译器的帮助来检查变量的一致性，如下：<br/>
id &lt;Drawing&gt; currentObject; //协议是不有点像泛型那么回事啊<br/>
这告知编译器currentObject 将包含遵守Drawing 协议的对象。如果向currentObject 指派静态类型的对象，这个对象不遵守Drawing 协议，编译器将给出warning。<br/>
再次提到id 类型，如果向currentObject 指派一个id 变量，不会产生这条消息，因为编译器不知道存储在id 变量中的对象是否遵守Drawing 协议。<br/>
C、如果这个变量保存的对象遵守多项协议，则可以列出多项协议，如下：<br/>
id &lt;Drawing, Drawing 1&gt; currentObject;<br/>
D、定义一项协议时，可以扩展现有协议的定义。以下协议<br/>
@protocol Drawing3D &lt;Drawing&gt;<br/>
说明 Drawing3D 协议也采用了Drawing 协议。因此采用Drawing3D 协议的类都必须实现此协议列出的方法，以及Drawing 协议的方法。<br/>
E、分类也可以采用一项协议，如：<br/>
@interface Fraction (stuff) &lt;NSCopying, NSCoding&gt;<br/>
此处，Fraction 拥有一个分类stuff，这个分类采用了NSCopying 和NSCoding 协议。<br/>
<br/>
在构建数组 NSArray，用 arrayWithObjects 时最后一个元素需要是 nil，即：<br/>
NSArray* array = [NSArray arrayWithObjects: @"ab", @"cd", nil];<br/>
<br/>
用对象的 copy、mutableCopy 可复制出对象。<br/>
<br/>
Archive(归档)，序列化与反序列化：对象是NSString、NSDictionary、NSArray、NSData、NSNumber 对象时，可以使用writeToFile：atomically：方法将数据写到文件中，是以属性列表的形式写到文件中的。参数atomically 为YES，表示先将数据写到临时备份文件中，一旦成功，再转移到文件中。<br/>
<br/>
相应的，像 dictionaryWithContentOfFile 函当我可以从文件中读取序列化出对象来，<br/>
<br/>
写出的文件内容格式， NSArray 的样子是：<br/>
<br/>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"<br/>
"http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;<br/>
&nbsp; &nbsp; &lt;plist version=”1.0”&gt;<br/>
&nbsp; &nbsp; &lt;array&gt;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &lt;string&gt;I&lt;string&gt;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &lt;string&gt;seem&lt;string&gt;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &lt;string&gt;to&lt;string&gt;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &lt;string&gt;be&lt;string&gt;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &lt;string&gt;a&lt;string&gt;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &lt;string&gt;verb&lt;string&gt;<br/>
&nbsp; &nbsp; &lt;/array&gt;<br/>
&lt;/plist&gt;<br/>
<br/>
NSDictionary&nbsp; writeToFile 的文件是：<br/>
<br/>
&lt;key&gt;...&lt;/key&gt;<br/>
&lt;string&gt;...&lt;/string&gt;<br/>
<br/>
读回数据还可以用的方法dataWithContentOfFile/stringWithContentOfFile/dictionaryWithContentOfFile/arrayWithContentOfFile<br/>
<br/>
还有 NSKeyedArchivers 的 archiveRootObject：toFile 和 unArchiveObjectWithFile
