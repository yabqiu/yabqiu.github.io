---
title: CountDownLatch 协调线程
url: /countdownlatch-threads/
date: 2013-10-19T08:41:37-05:00
featured: false
draft: true
toc: false
# menu: main
usePageBundles: true
categories:
  - Java/JEE
tags: 
  - Jdk
  - concurrent
comment: true
codeMaxLines: 50
# additional
wpPostId: 5782 
wpStatus: publish
views: 701
lastmod: 2014-01-02T01:42:34-06:00
---

JDK8 都快要出来了，在 JDK 5 中仍有许多好宝贝值得去挖掘。提到 JDK5 我们或许只知道它给了我们泛型，其实还有那个并发包 java.util.concurrent 却不那么引人注目，其实就是 NIO。<br/>
<br/>
若是并发包是在某个 JDK 版本中单独奉上，反响就不同了，想想 JDK 6 似乎未带来多少改变--至少对于编程者来说没有明显感受。java.util.concurrent 包中的东西对于我们处理线程带来了很大的便利，例如线程池，线程同步，Future, Callable 等。<br/>
<br/>
这里我记录一下 CountDownLatch 的使用，在此之前在处理<br/>
<br/>
线程 A 等待线程 B，C，D 全部执行完后才继续执行 （比如要每个线程都访问一个 Web 服务，等所有的请求响应成功后进行结果处理）<br/>
<br/>
这样场景的时候，我一般能想到的办法是，初始一个计数器，线程 B，C，D 各自初始化的时候，计数器加一，然后 A 线程等待，每个线程执行完后计数器减一，当计数器为 0 时表明所有任务执行完毕，就通知 A 可以开始运作起来。但这样的方案还是得小心的处理好同步的问题。<!--more--><br/>
<br/>
这可以用 JDK 5&nbsp; java.util.concurrent.CountDownLatch，它的实现原理基本与上一致。也是需要任务在执行完毕后执行一下 countDown() 方式使得计数减一，当为 0 时，A 被唤醒。CountDown 就是倒计数，Latch 是门拴的意思，可以理解为某一线程等待所有它关注的线程全部出去(或进来)后把门拴上。<br/>
<br/>
看个示例：<br/>
<pre class="brush:java">package cc.unmi.test.concurrent;<br/>
<br/>
import java.util.concurrent.CountDownLatch;<br/>
import java.util.concurrent.TimeUnit;<br/>
import java.util.logging.Level;<br/>
import java.util.logging.Logger;<br/>
<br/>
public class TestCountDownLatch {<br/>
<br/>
    public static void main(String args[]) {<br/>
       final CountDownLatch latch = new CountDownLatch(1);<br/>
       Thread cacheService = new Thread(new Service("CacheService", 1000, latch));<br/>
       Thread alertService = new Thread(new Service("AlertService", 1000, latch));<br/>
<br/>
       cacheService.start(); //separate thread will initialize CacheService<br/>
       alertService.start(); //another thread for AlertService initialization<br/>
<br/>
       try{<br/>
            latch.await(1000, TimeUnit.SECONDS);  //main thread is waiting on CountDownLatch to finish<br/>
            System.out.println("All services are up, Application is starting now");<br/>
       }catch(InterruptedException ie){<br/>
<br/>
       }<br/>
    }<br/>
<br/>
}<br/>
<br/>
class Service implements Runnable{<br/>
    private final String name;<br/>
    private final int timeToStart;<br/>
    private final CountDownLatch latch;<br/>
<br/>
    public Service(String name, int timeToStart, CountDownLatch latch){<br/>
        this.name = name;<br/>
        this.timeToStart = timeToStart;<br/>
        this.latch = latch;<br/>
    }<br/>
<br/>
    @Override<br/>
    public void run() {<br/>
        try {<br/>
            Thread.sleep(timeToStart);<br/>
        } catch (InterruptedException ex) {<br/>
            Logger.getLogger(Service.class.getName()).log(Level.SEVERE, null, ex);<br/>
        }<br/>
        System.out.println( name + " is Up");<br/>
        latch.countDown(); //reduce count of CountDownLatch by 1<br/>
    }<br/>
<br/>
}</pre>

输出是：<br/>
<br/>
AlertService is Up<br/>
CacheService is Up<br/>
All services are up, Application is starting now<br/>
<br/>
PlayFramework 的 controller 中的 await 和这很相拟，它较喜欢用 Promise 这个词。<br/>
<br/>
CountDownLatch 变成 0 后就不能重用了，如果想要能重用的就使用 java.util.concurrent.CyclicBarrier 吧，它用到了 ReentrantLock 的概念。<br/>
<br/>
参考：1. <a href="http://javarevisited.blogspot.sg/2012/07/countdownlatch-example-in-java.html" target="_blank">What is CountDownLatch in Java - Concurrency Example Tutorial</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. <a href="http://javarevisited.blogspot.sg/2012/07/cyclicbarrier-example-java-5-concurrency-tutorial.html" target="_blank">What is CyclicBarrier Example in Java 5 – Concurrency Tutorial</a>
