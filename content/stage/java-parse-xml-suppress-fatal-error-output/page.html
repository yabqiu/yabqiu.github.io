---
title: "Java 解析 XML 时如何屏蔽掉 “[Fatal Error]” 的输出"
url: /java-parse-xml-suppress-fatal-error-output/
date: 2014-09-26T01:05:29-05:00
featured: false
draft: false
type: post
toc: false
# menu: main
usePageBundles: true
categories:
  - Java/JEE
  - Scala
tags: 
  - xml
  - SAX
comment: true
codeMaxLines: 50
# additional
wpPostId: 6667 
wpStatus: publish
views: 2026
lastmod: 2014-10-14T11:42:35-05:00
---

我们在用 Java 解析 XML，当文档不是一个合法的 XML 时，可能会收到 <code>[Fatal Error]</code> 的控制台输出，即使把整个代码都 catch 住，仍然不能抑制住 [Fatal Error] 的信息输出。比如常见到这样的输出：<br/>
<blockquote>[Fatal Error] :1:1: Content is not allowed in prolog.</blockquote>

为什么不能禁掉它呢，本来 catch 了异常对程序已经有了很好的保护，想眼不见心不烦，但还是避之不及。<br/>
<br/>
因为，因为这个 XML 解析器用 <code>System.error.print()</code> 输出来了，当然你可以用 System.setErr(PrintStream) 重定向掉错误输出，但不现实，波及面太大。我们需要找到源头，首先交代解决方案就是覆盖掉默认的 ErrorHandler。<br/>
<br/>
看下这段 XML 解析代码：<!--more--><br/>
<pre class="brush:scala">import java.io.*;<br/>
import org.xml.sax.*;<br/>
import org.w3c.dom.Document;<br/>
import javax.xml.parsers.DocumentBuilderFactory;<br/>
<br/>
public class Test {<br/>
  public static void main(String[] args) {<br/>
    String xml = "abcd";<br/>
    try {<br/>
        DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder()<br/>
        Document doc = builder.parse(new InputSource(new ByteArrayInputStream(xml.getBytes)))<br/>
    } catch(SaxParseException|IOException e) {<br/>
        <br/>
    }<br/>
  }<br/>
}</pre>

上面的代码就会输出<br/>
<blockquote>[Fatal Error] :1:1: Content is not allowed in prolog.</blockquote>

如果 xml 的值是空字符串 ""，输出为<br/>
<blockquote>[Fatal Error] :-1:-1: Premature end of file.</blockquote>

如果 xml 的值是 "&lt;s&gt;ss&amp;Emal&lt;/s&gt;"，输出为<br/>
<blockquote>[Fatal Error] :1:12: The reference to entity "Email" must end with the ';' delimiter.</blockquote>

是不是对上面的错误输出很熟悉啊。<br/>
<br/>
那就要看 DocumentBuilderFactory.newInstance.newDocumentBuilder 的两个过程，首先看 DocumentBuilderFactory.newInstance() 方法，见<br/>
<br/>
<a href="http://docs.oracle.com/javase/7/docs/api/javax/xml/parsers/DocumentBuilderFactory.html#DocumentBuilderFactory()" target="_blank">http://docs.oracle.com/javase/7/docs/api/javax/xml/parsers/DocumentBuilderFactory.html#DocumentBuilderFactory()</a><br/>
<br/>
看到它依次以四种方式找到 DocumentBuilderFactory 的实现类<br/>
<ol>

	<li>系统属性 javax.xml.parsers.DocumentBuilderFactory</li>

	<li>JRE 目录下的属性文件 "lib/jaxp.properties" 中的  javax.xml.parsers.DocumentBuilderFactory</li>

	<li>SPI 形式，classpath 下加载 META-INF/services/javax.xml.parsers.DocumentBuilderFactory, 一般在 jar 包中</li>

	<li>平台默认的 DocumentBuilderFactory 实例</li>

</ol>

默认的 JDK7 环境中 DocumentBuilderFactory.newInstance 是 com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl,<br/>
<br/>
DocumentBuilderFactory.newInstance.newDocumentBuilder 是 com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderImpl<br/>
<br/>
比如在 xercesImpl-2.11.0.jar 包下就有文件 META-INF/services/javax.xml.parsers.DocumentBuilderFactory, 内容是<br/>
<br/>
org.apache.xerces.jaxp.DocumentBuilderFactoryImpl, 相应的  DocumentBuilder 是 org.apache.xerces.jaxp.DocumentBuilderImpl<br/>
<br/>
在实例化 DocumentBuilderImpl 时并没有给 DocumentBuilder 或 DOMParser 设置 ErrorHandler，而是在解析发现问题是设置上 ErrorHandler，然后输出错误，见<br/>
<br/>
<img class="aligncenter size-large wp-image-6669" src="http://unmi.cc/wp-content/uploads/2014/09/java-xml-error-handler-800x875.png" alt="java-xml-error-handler" width="800" height="875" /><br/>
<br/>
上面设置了 DefaultErrorHandler, 点击 <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/com/sun/org/apache/xerces/internal/util/DefaultErrorHandler.java" target="_blank">DefaultErrorHandler</a> 看它的实现。它在 warning 和 error 时只打印错误，fatal 时除打印还抛出了异常。打印目的地是 System.err<br/>
<br/>
但是我们可以设置一个 java.xml.parsers.DocumentBuilderFactory 系统属性从而使用自定义的 DocumentBuilderFactory 实现，在自己的 DocumentBuilderFactory 中初始化 DocumentBuilder 时设置自己的 ErrorHandler。<br/>
<br/>
现在我们来实现自定义的 DocumentBuilderFactory:<br/>
<br/>
CustomDocumentBuilderFactory.java<br/>
<pre class="brush:java">package helper;<br/>
<br/>
import com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl;<br/>
import com.sun.org.apache.xml.internal.utils.DefaultErrorHandler;<br/>
<br/>
import org.xml.sax.*;<br/>
<br/>
import javax.xml.parsers.*;<br/>
<br/>
public class CustomDocumentBuilderFactory extends DocumentBuilderFactoryImpl {<br/>
  @Override<br/>
  public DocumentBuilder newDocumentBuilder() throws ParserConfigurationException {<br/>
    DocumentBuilder documentBuilder = super.newDocumentBuilder(); // 取回原本的 DocumentBuilder<br/>
    documentBuilder.setErrorHandler(new DefaultErrorHandler() {   // 只为替换掉 DefaultErrorHandler 的 fatalError() 方法<br/>
      @Override<br/>
      public void fatalError(SAXParseException exception) throws SAXException {<br/>
        System.err.println("CustomDocumentBuilderFactory Caught the XML fatal error: " + exception.getMessage());<br/>
        throw exception;<br/>
      }<br/>
    });<br/>
<br/>
    return documentBuilder;<br/>
  }<br/>
}</pre>

然后重写获得 DocumentBuilder 部分代码为<br/>
<pre class="brush:java">System.setProperty("javax.xml.parsers.DocumentBuilderFactory", "helper.CustomDocumentBuilderFactory");<br/>
DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();<br/>
Document doc = builder.parse(new InputSource(new ByteArrayInputStream("".getBytes())));</pre>

再次执行就只看到控制台的输出为<br/>
<blockquote>TestDocumentBuilderFactoryImpl Caught the XML fatal error: Premature end of file.</blockquote>

表明我们已经成功捕获到了 fataError 了，怎么输出这个错误是可控制的了。<br/>
<br/>
在不同的环境下，例如 Tomcat 中可以去查看下默认的 DocumentBuilderFactory 实现，然后自定义的 Factory 就可以继承它，只为设置自己的 ErrorHandler，同时也保证了不破坏该环境下原有其他的行为。<br/>
<br/>
比如在 Play2 中 DocumentBuilderFactory 实现是 org.apache.xerces.jaxp.DocumentBuilderFactoryImpl， DocumentBuilder 实现是 org.apache.xerces.jaxp.DocumentBuilderImpl，它们来自 xercesImpl 包，这时候我们自定义的 DocumentBuilderFactory 就可以继承自 org.apache.xerces.jaxp.DocumentBuilderFactoryImpl, 其中设置自己的 ErrorHandler。<br/>
<br/>
另外，我们也可以通过调用 DefaultErrorHandler 的另一个构造方法 DefaultErrorHandler(PrintWriter out) 来创造实例，通过 传递一个 PrintWriter 实例来接受输出，这样也能控制不把 Fatal Error 输出到控制台上。
