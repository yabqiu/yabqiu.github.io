---
title: Scala 2.10.0 新特性之动态属性、方法
url: /scala-2-10-0-new-feature-dynamic/
date: 2013-01-19T13:34:15-06:00
featured: false
draft: false
type: post
toc: false
# menu: main
usePageBundles: true
categories:
  - Java/JEE
  - Scala
  - PlayFramework
tags: 
  - Java
  - Scala
comment: true
codeMaxLines: 50
# additional
wpPostId: 5412 
wpStatus: publish
views: 1824
lastmod: 2021-09-03T14:52:55-05:00
---

最早的介绍 Scala 语言的书都是以 Scala 的静态类型系统为傲。Scala 也算是个脚本语言，却不像其他许多脚本语言那样类型是动态的，只有执行时才确定，而 Scala 在执行前就确定了类型，比如依赖于比 Java 更强大的类型推断行为。</p>
<br/>
静态类型不光是变量类型是确定的，还有比如在使用  qual.sel 时，sel 这个属性或是方法(Scala 的访问一致性，属性和方法有时候并没有那么大的区别)必须在 qual 的类型中声明了的。<br/><br/>
Scala 思考再三还是加入了 Dynamic Types，这个特性在 Scala 2.9 中是试验性的，必须用 <span style="color: #800000;">-Xexperimental</span> 进行开启，到了 Scala 2.10.0 中，只有代码中 <span style="color: #800000;">import scala.language.dynamics</span> 就可用了，或是编译时加 <span style="color: #800000;">-language:dynamics</span> 选项。<br/><br/>
虽然 Scala 2.10.0 加进了 Dynamic Types 特性，但 Scala 仍然是静态类型的语言，因为在编译器同样会检查多出来的类型。<br/><br/>
有了 Dynamic Types 之后，Scala 又可更 DSL 了，方法名的动态上可以让它随时包括深刻的业务含义。相比 Java 的 DSL 的能力就太逊了，我们几乎无法在 Java 面前提 DSL 这回事。<!--more--><br/><br/>
通俗点讲动态类型的类必须继承自 Dynamic，当使用 qual.sel，而 Qual 类未定义 sel 属性或方法时; 会调用 <span style="color: #800000;">selectDynamic(method: String) </span>方法，当 <span style="color: #800000;">qual.name = "Unmi"</span> 时会调用类似 <span style="color: #800000;">updateDynamic(method: String)(args: Any)</span> 这样的方法; 还有 applyDynamic，applyDynamicNamed 这两个方法的自动调用。<br/><br/>
所有的变化就在下面这四个方法中：<br/><br/>
selectDynamic<br />
updateDynamic<br />
applyDynamic<br />
applyDynamicNamed<br/><br/>
看个完整的例子，我不打算把上面四个方法的应用规则分开来演示：<br/><br/>
<pre class="lang:default decode:true">import scala.language.dynamics<br/><br/>
class Person extends Dynamic{
    
    def selectDynamic(method: String){
        println(s"selectDynamic-&gt;$method called\n")
    }
    
    def applyDynamic(method: String)(args: Any*){
        println(s"applyDynamic-&gt;$method called, args: $args\n")
    }
    
    def updateDynamic(method: String)(args: Any){
        println(s"updateDynamic-&gt;$method called, args: $args\n")
    }
    
    def applyDynamicNamed(method: String)(args: (String, Any)*) {
      println(s"applyDynamicNamed-&gt;$method called, args: $args")
      for((key, value) &lt;- args){
          println(s"key: $key, value: $value")
      }
    }
}<br/><br/>
val p = new Person<br/><br/>
p.sayHello  //calll selectDynamic
p.config("Hello","Unmi") //call applyDynamic
p.products = ("iPhone","Nexus") //call updateDynamic
p.showInfo(screenName="Unmi", email="fantasia@sina.com") //call applyDynamicNamed</pre>
<br/>
上面对 p 的每一个调用都说明了会委派给哪个动态方法，执行结果输出是：<br/><br/>
<pre class="lang:default decode:true ">selectDynamic-&gt;sayHello called<br/><br/>
applyDynamic-&gt;config called, args: WrappedArray(Hello, Unmi)<br/><br/>
updateDynamic-&gt;products called, args: (iPhone,Nexus)<br/><br/>
applyDynamicNamed-&gt;showInfo called, args: WrappedArray((screenName,Unmi), (email,fantasia@sina.com))
key: screenName, value: Unmi
key: email, value: fantasia@sina.com</pre>
<br/>
现在来看发生了什么，Person 继承自  Dynamic，并且有引入 scala.language.dynamics。对 p 调用的方法(属性) 都不存在，但是都调用到了正常的动态方法。所以仍然要对这四个动态方法(确切的讲是四种类型的方法，因为比如你可以定义多个不同的 updateDynamic 方法，其余三个也同此) 分别加以说明：<br/><br/>
<strong>1. selectDynamic</strong><br/><br/>
在调用找不到了无参方法时，会去寻找它，调用效果如下：<br/><br/>
p.sayHello  也可以写成  p.selectDynamic("sayHello")<br/><br/>
也就是说编译器在看到 p.sayHello 调用会根据  selectDynamic(method: String) 相当于创建了方法 def sayHello = .......，也就是把动态方法 selectDynamic(method: String) 换成   sayHello 却是。所以说 Scala 的 Dynamic 类中的 xxxDynamic 方法相当是模板方法。<br/><br/>
<span style="color: #0000ff;">applyDynamic，updateDynamic 和  applyDynamicNamed 这三个方法第二个括号中的参数类型，或个数需根据实际应用来定。这四个动态方法的第一个括号中的参数都是动态调用时的方法名。</span><br/><br/>
<strong>2. applyDynamic</strong><br/><br/>
在进行有参数的方法调用时，会去找寻它，调用效果如下：<br/><br/>
<span style="color: #800000;">p.config("Hello", "Unmi")</span> 可以写成 <span style="color: #800000;">p.applyDynamic("config")("Hello", "Unmi")</span><br/><br/>
还是这么理解: 把这个动态方法定义的方法名和第一个括号与参数替换成调用的方法名就知道怎么回事，例如把：<br/><br/>
<span style="color: #800000;">def applyDynamic(method: String)(args: Any*)</span> 中的 <span style="color: #800000;">applyDynamic(method: String)</span> 替换成被调用方法名  config，就是：<br/><br/>
<span style="color: #800000;">def config(args: Any*)        //p.config("Hello", "Unmi") 要调用的就是这么个方法</span><br/><br/>
<span style="color: #0000ff;">所以第二个括号中的参数由你自己来定，比如说想这么调用 p.config("Hello", 100, 30)，那么你可的动态方法可以这么定义：</span><br/><br/>
<span style="color: #0000ff;">def applyDynamic(method: String)(greeting: String, high: Int, low: Int) { ...... }</span><br/><br/>
<span style="color: #0000ff;">这个规则同样适用于 updateDynamic 和  applyDynamicNamed 这两个方法。</span><br/><br/>
<strong>3. updateDynamic</strong><br/><br/>
等号赋值操作时会调用 updateDynamic 方法，调用效果如下：<br/><br/>
<span style="color: #800000;">p.products = ("iPhone", "Nexus")</span>  可写成 <span style="color: #800000;">p.updateDynamic("products")(("iPhone", "Nexus"))</span>，按照同样的理解方法，相当于 Person 中定义了 <span style="color: #800000;">def products(args: Any) </span>方法。<br/><br/>
<strong>4. applyDynamicNamed</strong><br/><br/>
同样是 apply 开头，所以这个方法是对 applyDynamic 方法的补充，即使没有 applyDynamicNamed，单用 applyDynamic 也能达成我们的要求。applyDynamicNamed 只是让你用命名参数调用时方便，也就是像<br/><br/>
<span style="color: #800000;">p.showInfo(screenName="Unmi", email="fantasia@sina.com") </span>这样用命名参数的方式来调用动态方法时会调用 updateDynamicNamed 方法。有了这个方法在命名传递参数就方便处理 key/value 值。<br/><br/>
这四个方法在一个动态类中只能分别定义一个版本，否则会产生二义性，这和普通方法的重载不一样的。柯里化后的函数第二个括号中的参数可根据实际调用来定义，定义成  (args: Any*) 可包打天下。<br/><br/>
参考: 1. <a href="https://docs.google.com/document/d/1XaNgZ06AR7bXJA9-jHrAiBVUwqReqG4-av6beoLaf3U/edit?pli=1" target="_blank" rel="noopener">SIP 17: Type Dynamic<br />
</a>          2. <a href="http://www.scala-lang.org/api/current/index.html#scala.Dynamic" target="_blank" rel="noopener">http://www.scala-lang.org/api/current/index.html#scala.Dynamic</a><br />
          3. <a href="http://weblogs.java.net/blog/cayhorstmann/archive/2012/12/13/dynamic-types-scala-210" target="_blank" rel="noopener">Dynamic Types in Scala 2.10</a><br />
          4. <a href="http://www.blog.project13.pl/index.php/coding/1580/scala-2-10-class-ohmy-extends-dynamic/" target="_blank" rel="noopener">Scala 2.10: class OhMy extends Dynamic !</a><br />
          5. <a href="http://comments.gmane.org/gmane.comp.lang.scala/26451" target="_blank" rel="noopener">dynamic semantics</a>
