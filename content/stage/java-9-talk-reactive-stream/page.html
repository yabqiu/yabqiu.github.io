---
title: Java 9 - 说说响应式流
url: /java-9-talk-reactive-stream/
date: 2018-07-03T01:33:14-05:00
featured: false
draft: true
toc: false
# menu: main
usePageBundles: true
categories:
  - Java/JEE
tags: 
  - Java 9
comment: true
codeMaxLines: 50
# additional
wpPostId: 8877 
wpStatus: publish
views: 4339
lastmod: 2018-07-03T01:37:06-05:00
---

<p>最初看到 Java 9 的这个新特性没太在意，及至重新关注到 Spring 5/Springboot 2 的响应式编程的时候才真正重视起 Reactive Streams(响应式流或反应式流)。应用响应式流的编程也就叫做响应式编程(Reactive Programming)，无论是翻译成反应式编程都有些令人摸不准头脑。与此对应的在 Web 设计方面有一个叫做响应式 Web 设计(Responsive web design)，两个词都译作响应式，却有些差别，大概是 Reactive 被译为反应的原因之一。</p>

<p>通过这里对  Reactive Streams 的学习，主要目的是为了进一步掌握 Spring 5/Springboot 2 的响应式 MVC 作铺垫的，不至于猛然间见 Flux, Mono 而不知所措。</p>

<p><a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">函数式响应式编程</a>概念最早来自于九十年代末，这也激发了微软的 <a href="https://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist)">Erik Meijer</a> 设计开发了 .NET 的  Rx(Reactive eXtension) 库，以及到后来 Netflix 的  RxJava 也与他有关系。Reactive Stream 更像是一种编程模式，致力于解决一个生产者产生一系列消息，一个或多个去消费它们的问题。两者的名词我们会用: producer-consumer(生产者-消费者), source/sink(水源/水槽, Akka Stream 用了这个概念), publisher-subscriber(发布者-订阅者)。</p>

<p>既然 Reactive Stream 和 Java 8 引入的 Stream 都叫做流，它们之间有什么关系呢？有一点关系，Java 8 的 Stream 主要关注在流的过滤，映射，合并，而  Reactive Stream 更进一层，侧重的是流的产生与消费，即流在生产与消费者之间的协调。<!--more--></p>

<p>一流的公司制定规范，Reactive Stream 标准在 2013 年也开始有了一个雏形：异步的流处理，并支持非阻塞式的 backpressure(背压? 很拗口的翻译，就是生产者与消费者之者应有流量控制)。流量控制即消费者的速率慢于生产者的速率时，生产者需要把速率降下来，比如说流处理时能在推/拉模式之间自动切换。至于背后的异步，非阻塞的实现仍然得仰仗于多线程了。</p>

<p>在之后出现了Netflix 的 RxJava, 它的四个主要角色是: <code>Observable</code>, <code>Observer</code>, <code>Subscriber</code> 和 <code>Subject</code>。到 2015 年，正式的 Reactive Stream 出台，发布在 <a href="http://www.reactive-streams.org/">http://www.reactive-streams.org/</a>。从这里我们可以认识到规范有多粗暴，就是定义了四个接口，以及一句话说生产/消费者之间是异步的，并实现 backpresure，没有任何的实现参考。<a href="https://yanbin.blog/wp-content/uploads/2018/06/reactive-streams.png"><img class="aligncenter size-full wp-image-8878" src="https://yanbin.blog/wp-content/uploads/2018/06/reactive-streams.png" alt="" width="587" height="304" /></a></p>

<p>在  Reactive Stream 规范正式出来后，RxJava 也向它靠拢，实现了 <code>org.reactivestreams</code> 中的以上四个接口，RxJava 2 更是重写了。见 <a href="http://www.reactive-streams.org/announce-1.0.0">Reactive Streams 1.0.0 is here</a>, 看到该规范的拥趸还不少, 括号中为支持  Reactive Streams 的起始版本号。</p>

<ul><br/>
	<li><a href="http://akka.io/">Akka</a> Streams(1.0-RC2)</li>

	<li><a href="http://mongodb.org/">MongoDB</a>(1.0.0)</li>

	<li><a href="http://www.ratpack.io/"> Ratpack</a>(0.9.16), 可用来创建非阻塞式 HTTP 应用</li>

	<li><a href="https://github.com/ScalaConsultants/reactive-rabbit">Reactive Rabbit</a>(1.0.0), RabiitMQ/AMQP 的驱动</li>

	<li><a href="http://projectreactor.io/">Reactor</a>(Spring 5 的响应式 MVC 就是用的它)</li>

	<li><a href="http://reactivex.io/">RxJava</a>(1.0.0), Netflix 出品</li>

	<li><a href="http://slick.typesafe.com/"> Slick</a>(3.0.0), Scala 的函数式关系映射组件，用于操作数据库</li>

	<li><a href="http://vert-x3.github.io/">Vert.x 3.0</a>(milestone-5a), Eclipse 出品，也能用于构建非阻塞式 HTTP 应用</li>

</ul><br/>
<p>绕了一圈，该让 Java 9 与 Reactive Streams 发生关系了。Java 9 想必看到  Reactive Streams 是个好东西，于是把它纳入到 JDK 中来，但方式是无法容忍 JDK 中再出现 <code>org.reactivestreams</code> 这样的包定义，采用的做法是完全拷贝那四个接口定义，全收在了 <code>java.util.concurrent.Flow</code> 类中，作为 <code>Flow</code> 的内部静态接口存在。</p>

<p><a href="https://yanbin.blog/wp-content/uploads/2018/06/reactive-streams-2.png"><img class="aligncenter size-full wp-image-8880" src="https://yanbin.blog/wp-content/uploads/2018/06/reactive-streams-2.png" alt="" width="417" height="390" /></a></p>

<p>JDK 9 本身也没有用力去实现以上四个接口，有两个比较简陋的 <code>SubmissionPublisher</code> 和  <code>ConsumerSubscriber</code>。再就是还处于孵化器阶段的 <code>jdk.incubator.http</code> 包中的一些 <code>Publisher</code>, <code>Subscriber</code> 实现，这也是  Reactive Streams 最应大力发挥网络协议领域。</p>

<p>因为有 JDK 9 的不遵循包名的引入  Reactive Streams 规范，所以 reactivestreams.org 又发出一个库 org.reactivestreams:reactive-streams-flow-adapters:1.0.2, 用于在 org.reactivestreams 和 <code>java.util.consurrent.Flow</code>  间的  <code>Publisher</code>, <code>Subscriber</code>, <code>Processor</code>, <code>Subscription</code> 之间的类型转换。</p>

<p>Spring 5 第一个 Release 版本在  2017-09-28 发布的，而  Java 9 是在 2017-07-27 正式发布的，就是说在  Spring 5 发布时已经有了 Java 的 Reactive Streams。不过  Spring 5 的第一个里程碑版还是在  2016-07-28, 所以那时选择了 <a href="https://projectreactor.io/">Reactor</a>, 所以要使用  Spring 5 的响应式编程就必须了解  Flux 和 Mono，或许下一个  Spring 版本也要适配 Java 9 的  Reactive Streams Flow API，即双向转换或替换 API。</p>

<p>对于 Spring 5 可能发生的与 Java 9 Reactive Streams 的适配或许有些像  PlayFramework 兼容 Java 8 之前用的是它自己的 API <code>F.Option</code> 和 <code>F.Promise</code>, 后来从 Play 2.4 升级到  2.5 后完全采用了 Java 8 的  <code>Optional</code> 和  <code>CompletionStage</code> APIs 作为替代。</p>

<h3>Java 9 的  SubmissionPublisher 应用实例</h3><br/>
<p>前面提到过  Java 9 有两个简陋的 Publisher 和 Subscriber 实现，来看看 <code>SubmissionPublisher</code> 和 <code>ConsumerSubscriber</code> 的应用举例</p>

<pre class="lang:default decode:true">package cc.unmi;<br/>
<br/>
import java.util.concurrent.CompletableFuture;<br/>
import java.util.concurrent.SubmissionPublisher;<br/>
import java.util.stream.IntStream;<br/>
<br/>
public class TestFlow {<br/>
<br/>
    public static void main(String[] args) {<br/>
        CompletableFuture&lt;Void&gt; subTask;<br/>
        try (SubmissionPublisher&lt;Integer&gt; publisher = new SubmissionPublisher&lt;&gt;()) {<br/>
            subTask = publisher.consume(System.out::print);<br/>
            IntStream.rangeClosed(1, 3).forEach(publisher::submit);<br/>
        }<br/>
<br/>
        subTask.join();<br/>
    }<br/>
}</pre>

<p>运行，输出为</p>

<blockquote><br/>
<p>123</p>

</blockquote>

<p>没什么意外，看起来和直接用 Stream API 差不多，效果与下面仅一行代码是一样的</p>

<pre class="lang:default decode:true">IntStream.rangeClosed(1, 3).forEach(System.out::print);</pre>

<p>面实际上内部运作起来就完全是另一回事了，此间就有 Java Flow APIs 在运转。下面逐步来理解一下：</p>

<h4>从 SubmissionPublisher 构造函数起</h4><br/>
<p><code>SubmissionPublisher</code> 实现了  <code>Flow.Publisher</code> 接口，它有三个构造函数</p>

<blockquote><br/>
<p>SubmissionPublisher()   //默认线程池为 ForkJoinPool.commonPool(), 缓冲区大小为 256<br /><br/>
SubmissionPublisher(Executor executor, int maxBufferCapacity)<br /><br/>
SubmissionPublisher(Executor executor, int maxBufferCapacity, BiConsumer&lt;? super Flow.Subscriber&lt;? super T&gt;, ? super Throwable&gt; handler)</p>

</blockquote>

<h4>publisher.consume(consumer) 发生了什么</h4><br/>
<p>看 <code>SubmissionPublisher</code> 的  <code>consumer(...)</code> 方法</p>

<pre class="lang:default decode:true ">    public CompletableFuture&lt;Void&gt; consume(Consumer&lt;? super T&gt; consumer) {<br/>
        if (consumer == null)<br/>
            throw new NullPointerException();<br/>
        CompletableFuture&lt;Void&gt; status = new CompletableFuture&lt;&gt;();<br/>
        subscribe(new ConsumerSubscriber&lt;T&gt;(status, consumer));<br/>
        return status;<br/>
    }</pre>

<p>上面代码创建了一个 <code>ConsumerSubscriber</code> 实例，它实现了 <code>Flow.Subscriber</code> 接口，<code>subscribe(...)</code> 方法创建了 <code>Subscription</code> 实例</p>

<pre class="lang:default decode:true">BufferedSubscription&lt;T&gt; subscription = new BufferedSubscription&lt;T&gt;(subscriber, executor, onNextHandler, maxBufferCapacity);<br/>
</pre>

<p>并提交任务给线程池，该任务执行到了 ConsumerSubscriber 的  onSubscribe(Flow.Subscription subscription) 方法，看到</p>

<pre class="lang:default decode:true ">subscription.request(Long.MAX_VALUE);</pre>

<p>一下请求所有的元素。</p>

<h4>publisher.submit(T item) 生产消息</h4><br/>
<p><code>SubmissionPublisher.submit(item)</code> 发布消息后，<code>ConsumerSubscriber</code> 会收到 <code>onNext</code>, <code>onComplete</code> 事件，或出错时的  <code>onError</code>，对应方法</p>

<pre class="lang:default decode:true">onNext(T item)<br/>
void onComplete()<br/>
void onError(Throwable ex)</pre>

<p>从上面大概能看到一个  Reactive Streams 应用有  <code>Publisher</code>, <code>Subscriber</code>, <code>Subscription</code> 多个角色在参与协作。而一个 Reactive Streams 组件要做的事情就是就是尽可能的把它们做的更完美，高效率且接口更友好。</p>

<h3>SubmissionPublisher 可有多个订阅者</h3><br/>
<p>当给  <code>SubmissionPublisher</code> 指定多个 <code>Subscriber</code> 的时候，消息只需发布一次，这与 <code>IntStream.rangeClosed(1, 3).forEach(System.out::println);</code> 就不一样了</p>

<pre class="lang:default decode:true">    public static void main(String[] args) {<br/>
        CompletableFuture&lt;Void&gt; subTask1;<br/>
        CompletableFuture&lt;Void&gt; subTask2;<br/>
        try (SubmissionPublisher&lt;Integer&gt; publisher = new SubmissionPublisher&lt;&gt;()) {<br/>
            subTask1 = publisher.consume(System.out::print);<br/>
            subTask2 = publisher.consume(System.out::print);<br/>
            IntStream.rangeClosed(1, 3).forEach(publisher::submit);<br/>
        }<br/>
<br/>
        subTask1.join();<br/>
        subTask2.join();<br/>
    }</pre>

<p>执行后的输出顺序是不确定的，可能是下面任意情况</p>

<blockquote><br/>
<p>112233<br /><br/>
123123</p>

</blockquote>

<h3>Reactive Streams 和  Actor</h3><br/>
<p>在进行异步消息处理时，Reactive Streams 和  Actor 是两种不同的编程模式选择。Reactive Streams 规范相比 Actor 更简单，只是说收发消息异步，有流量控制。而 Actor 编程模式涉及到 Actor 容错管理，消息路由，集群，并支持远程消息等。</p>

<p>还有共同之处是: 它们定义的 API 都很简单，编码时都基本不需要关注线程本身，而实际消息的传递都是背后的线程池。所以线程的配置可延迟到部署阶段来进行优化处理。</p>

<hr /><br/>
<p>下一步，继续对 Spring 5 的响应式 MVC 应用进行实战体验</p>
