---
title: 应用 Castor 把 XML 转换成相应的 JavaBean(二)
url: /castor-xml-to-javabean-2/
date: 2011-04-23T04:38:13-05:00
featured: false
draft: true
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/http://unmi.cc/wp-content/uploads/2011/04/imagesCAOYA7MJ.jpg"
categories:
  - XML/DOM
  - Java/JEE
tags: 
  - JavaBean
  - xml
  - castor
  - data bingding
comment: true
codeMaxLines: 50
# additional
wpPostId: 3491 
wpStatus: publish
views: 1053
lastmod: 2021-09-03T14:06:29-05:00
---

紧接前一篇 <a href="http://unmi.cc/castor-xml-to-javabean-1" target="_blank" rel="noopener">应用 Castor 把 XML 转换成相应的 JavaBean(一)，</a>本例稍显复杂一些，也就是要使用到映射文件，更复杂的 JavaBean、XML 数据类型和结构，引入自定的 FieldHandler，还有存在 Namespace 的情形。</p>
<br/>
关于如何使用 Castor 来把 XML 映射成 JavaBean 请着重阅读这个链接 <a href="http://www.castor.org/reference/html/XML%20data%20binding.html">http://www.castor.org/reference/html/XML%20data%20binding.html</a> 中的内容，里面有说明支持的类型，如何定义自己的类型 Handler 及配置 Handler 的属性，mapping.xml 文件怎么写及各部份的意义；还有 castor.properties 的配置，比其中的 suppressNamespaces 为 true 时可以忽略掉 Namespace，默认为 false.<br/><br/>
直接看例子吧：<br/><br/>
1. persons.xml，这里放了一个 Namespace，并定义了一个 Address 类型，还使得节点名与 Bean 的属性名不一致：<!--more--><br/><br/>
<pre class="lang:default decode:true">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;Persons xmlns:i="http://www.w3.org/2001/XMLSchema-instance"&gt;
    &lt;Person i:Type="worker"&gt;
        &lt;Name&gt;Unmi&lt;/Name&gt;
        &lt;Address&gt;st1|st2&lt;/Address&gt;
    &lt;/Person&gt;
    &lt;Person i:Type="yuan"&gt;
        &lt;Name&gt;Fantasia&lt;/Name&gt;
        &lt;Address&gt;sz|gd&lt;/Address&gt;
    &lt;/Person&gt;
&lt;/Persons&gt;</pre>
<br/>
2. PersonList.java:<br/><br/>
<pre class="lang:default decode:true">package cc.unmi.castor;<br/><br/>
import java.util.List;<br/><br/>
/**
 * @author Unmi Qiu
 * CreateTime: Apr 23, 2011
 */
public class PersonList {
    List&lt;Person&gt; persons;<br/><br/>
    public List&lt;Person&gt; getPersons() {
        return persons;
    }<br/><br/>
    public void setPersons(List&lt;Person&gt; persons) {
        this.persons = persons;
    }
}</pre>
<br/>
3. Person.java:<br/><br/>
<pre class="lang:default decode:true">package cc.unmi.castor;<br/><br/>

/**
 * @author Unmi Qiu
 * CreateTime: Apr 23, 2011
 */
public class Person {
    private String name;
    private Address address;
    private String type;<br/><br/>
    //中间省去所有的 setter/getter 方法<br/><br/>
    public String toString() {
        return name + "," + address + "," + type;
    }
}
</pre>
<br/>
4. Address.java:<br/><br/>
<pre class="lang:default decode:true">package cc.unmi.castor;<br/><br/>
/**
 * @author Unmi Qiu
 * CreateTime: Apr 23, 2011
 */
public class Address {
    private String street1;
    private String street2;<br/><br/>
    //中间省去所有的 setter/getter 方法<br/><br/>
    public String toString() {
        return street1 + "|" + street2;
    }
}</pre>
<br/>
5. AddressHandler.java，自定义的类型处理器，用于在 XML 与 Bean 属性间转换特定的类型：<br/><br/>
<pre class="lang:default decode:true">package cc.unmi.castor;<br/><br/>
import org.exolab.castor.mapping.FieldHandler;
import org.exolab.castor.mapping.ValidityException;<br/><br/>
/**
 * Custom Address Handler
 * @author Unmi Qiu
 * CreateTime: Apr 23, 2011
 */
public class AddressHandler implements FieldHandler {
   
    public Object getValue(Object object) throws IllegalStateException {
        Person root = (Person)object;
        if(root.getAddress() == null){
            return null;
        }
        
        return root.getAddress().getStreet1()+"|" + root.getAddress().getStreet2();
    }<br/><br/>
    public void setValue(Object object, Object value) throws IllegalStateException, IllegalArgumentException {
        Person root = (Person)object;
        
        Address address = new Address();
        String[] streets  = ((String)value).split("\\|");
        address.setStreet1(streets[0]);
        address.setStreet2(streets[1]);
        
        root.setAddress(address);
    }<br/><br/>
    public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
    }<br/><br/>
    public void checkValidity(Object object) throws ValidityException, IllegalStateException {<br/><br/>
    }<br/><br/>
    public Object newInstance(Object parent) throws IllegalStateException {
        return null;
    }
}</pre>
<br/>
这个 Handler 可没有 JAXB 相对应的 Adapter 那么好理解，要复杂的多，习惯下吧。<br/><br/>
6. mapping.xml，映射文件，应该能看到它所表达的意思：<br/><br/>
<pre class="lang:default decode:true">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE mapping PUBLIC "-//EXOLAB/Castor Mapping DTD Version 1.0//EN"
                         "http://castor.org/mapping.dtd"&gt;<br/><br/>
&lt;mapping&gt;
    &lt;class name="cc.unmi.castor.PersonList"&gt;<br/><br/>
        &lt;field name="persons" collection="arraylist" type="cc.unmi.castor.Person"&gt;
            &lt;bind-xml name="Person" node="element" /&gt;
        &lt;/field&gt;
    &lt;/class&gt;<br/><br/>
    &lt;class name="cc.unmi.castor.Person"&gt;
        &lt;map-to xml="Person" /&gt;<br/><br/>
        &lt;field name="name" type="java.lang.String"&gt;
            &lt;bind-xml name="Name" node="element" /&gt;
        &lt;/field&gt;<br/><br/>
        &lt;field name="address" type="string" 
           handler="cc.unmi.castor.AddressHandler"&gt;
            &lt;bind-xml name="Address" node="element"/&gt;
        &lt;/field&gt;<br/><br/>
        &lt;field name="type" type="java.lang.String"&gt;
            &lt;bind-xml name="i:Type" QName-prefix="i" node="attribute"
                xmlns:i="http://www.w3.org/2001/XMLSchema-instance" /&gt;
        &lt;/field&gt;
    &lt;/class&gt;<br/><br/>
&lt;/mapping&gt;</pre>
<br/>
上面有几点得好好看清楚下：<br/><br/>
1） class 节点用 name 指定类型<br />
2） field 节点用 type 指定类型<br />
3） node 属性有是 element 也有对应于 attribute<br />
4） address 的 type 为 string，而不是 cc.unmi.castor.Address，写成后者会报错的。<br />
5） 对于 type 节点有 Namespace 时，写法确实很啰嗦的。不过如果在 castor.properties 的配置 suppressNamespaces 为 true 则可以忽略掉 Namespace。<br/><br/>
7. Client.java，最后是客户端调用代码：<br/><br/>
<pre class="lang:default decode:true ">package cc.unmi.castor;<br/><br/>
import java.io.InputStream;
import java.net.URL;<br/><br/>
import org.exolab.castor.mapping.Mapping;
import org.exolab.castor.xml.Unmarshaller;
import org.xml.sax.InputSource;<br/><br/>

public class Client {<br/><br/>
    public static void main(String[] args) throws Exception{
        Mapping mapping = new Mapping();
        URL urlMapping = ClassLoader.getSystemResource("mapping.xml");
        mapping.loadMapping(urlMapping);
        Unmarshaller unmarshaller = new Unmarshaller(PersonList.class);
        unmarshaller.setMapping(mapping);
        
        InputStream xmlInputStream = ClassLoader.getSystemResourceAsStream("persons.xml");
        InputSource inputSource = new InputSource(xmlInputStream);
        PersonList personList = (PersonList)unmarshaller.unmarshal(inputSource);
        System.out.println(personList.getPersons());
    }
}</pre>
<br/>
执行上面的代码控制台输出结果为：<br/><br/>
<strong>[Unmi,st1|st2,worker, Fantasia,sz|gd,yuan]</strong><br/><br/>
结果正确。<br/><br/>
最后还是说要用好下 Castor，请仔细阅读 <a href="http://www.castor.org/reference/html/XML%20data%20binding.html">http://www.castor.org/reference/html/XML%20data%20binding.html</a>。原以为 Castor 的资料比 JAXB 少，现在才知道错了。而且就这样稍加深入的了解了下，发现 Castor 确实够强悍的。<br/><br/>
参考：1. <a href="http://www.castor.org/xml-mapping.html">http://www.castor.org/xml-mapping.html</a><br />
             2. <a href="http://castor.org/spring-xml-intro.html">http://castor.org/spring-xml-intro.html</a><br />
             3. <a href="http://www.castor.org/xml-framework.html">http://www.castor.org/xml-framework.html</a><br />
             4. <a href="http://www.castor.org/reference/html/XML%20data%20binding.html">http://www.castor.org/reference/html/XML%20data%20binding.html</a>
