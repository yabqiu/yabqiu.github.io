---
title: 转换  Iterator 为 Java 8 的 Stream
url: /convert-iterator-to-java-8-stream/
date: 2019-07-03T21:20:27-05:00
featured: false
draft: true
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/http://unmi.cc/wp-content/uploads/2016/12/Java8-Logo.png"
categories:
  - Java8
tags: 
  - Stream
  - Iterator
comment: true
codeMaxLines: 50
# additional
wpPostId: 9469 
wpStatus: publish
views: 1604
lastmod: 2019-07-03T21:20:27-05:00
---

<p>Java 中有关抽象的可遍历的对象有 Iterator, Iterable 和 Java 8 的 Stream, Iterable 可简单的用如下代码转换为 Stream</p>

<blockquote><br/>
<p>StreamSupport.stream(iterable.spliterator(), false)</p>

</blockquote>

<p>再回过头来，为什么要把 Iterator 或 Iterable 转换为 Stream, 因为 Iterator 和 Iterable 只提供有限的遍历操作，如 Iterator 接口的全部四个方法</p>

<blockquote><br/>
<p>hasNext()<br /><br/>
next()<br /><br/>
forEachRemaining(consumer)<br /><br/>
remove()</p>

</blockquote>

<p>同样 Iterable 也只有 <code>iterator()</code>, <code>forEach(consumer)</code>, 和 <code>spliterator()</code> 方法。而 Java 8 的 Stream 就大不一样的，带有大量的链式操作方法，如 filter, map, flatMap, collect 等。</p>

<p>因此如果我们已有一个 Iterator 类型，能够被转换为 Stream 类型的话将会大大简化后续的转换，处理操作。具体的从 Iterator 到 Stream 的转换方式有两种<!--more--></p>

<h3>通过 Spliterators.spliteratorUnknownSize(...) 方法变 Iterator 为 Stream</h3><br/>
<p>由于 Iterator 的大小是不确定的，有多少个元素完全由 hasNext() 决定的，<code>spliteratorUnknownSize()</code> 方法正好应了这一情景。代码如下</p>

<pre class="lang:default decode:true">Iterator&lt;Integer&gt; sourceIterator = Arrays.asList(3, 1, 2, null, 2).iterator();<br/>
Stream&lt;Integer&gt; targetStream = StreamSupport.stream(<br/>
    Spliterators.spliteratorUnknownSize(sourceIterator, Spliterator.SORTED), false);<br/>
<br/>
System.out.println(Arrays.toString(targetStream.toArray()));</pre>

<p>输出会是</p>

<blockquote><br/>
<p>[3, 1, 2, null, 2]</p>

</blockquote>

<p>前面的 Spliterator.SORTED 参数值是 <code>characteristics</code>, 预定义了七个常量值，但是对于 <code>Spliterators.splieratorUnknownSize(...)</code> 方法来说无论传什么都不会影响到最终的结果。比如我们可以做下面一个测试</p>

<pre class="lang:default decode:true ">    public void test(int characteristics) {<br/>
        System.out.printf("characteristics %5d: ", characteristics);<br/>
        Iterator&lt;Integer&gt; sourceIterator = Arrays.asList(3, 1, 2, null, 2).iterator();<br/>
        Stream&lt;Integer&gt; targetStream = StreamSupport.stream(<br/>
            Spliterators.spliteratorUnknownSize(sourceIterator, characteristics), false);<br/>
        System.out.println(Arrays.toString(targetStream.toArray()));<br/>
    }<br/>
<br/>
    Arrays.asList(<br/>
        Spliterator.CONCURRENT,<br/>
        Spliterator.DISTINCT,<br/>
        Spliterator.IMMUTABLE,<br/>
        Spliterator.NONNULL,<br/>
        Spliterator.SIZED,<br/>
        Spliterator.SORTED,<br/>
        Spliterator.SUBSIZED).forEach(this::test);</pre>

<p>输出结果如下：</p>

<blockquote><br/>
<p>characteristics 4096: [3, 1, 2, null, 2]<br /><br/>
characteristics 1: [3, 1, 2, null, 2]<br /><br/>
characteristics 1024: [3, 1, 2, null, 2]<br /><br/>
characteristics 256: [3, 1, 2, null, 2]<br /><br/>
characteristics 64: [3, 1, 2, null, 2]<br /><br/>
characteristics 4: [3, 1, 2, null, 2]<br /><br/>
characteristics 16384: [3, 1, 2, null, 2]</p>

</blockquote>

<p>这里的 characteristics 传什么都行。</p>

<p>根据下面的分析，characteristics 用不着从常量定义中挑选，直接给 <code>0</code> 就行，写成下面那样</p>

<blockquote><br/>
<p>Spliterators.spliteratorUnknownSize(sourceIterator, 0)</p>

</blockquote>

<h3>经由 Iterable 把 Iterator 转换为 Stream</h3><br/>
<p>像最前面那样 Iterable 可以轻松转换为 Stream, 所以先把 Iterator 变为 Iterable 再转化为 Stream。</p>

<pre class="lang:default decode:true">Iterator&lt;Integer&gt; sourceIterator = Arrays.asList(3, 1, 2, null, 2).iterator();<br/>
Iterable&lt;Integer&gt; iterable = () -&gt; sourceIterator;<br/>
Stream&lt;Integer&gt; targetStream = StreamSupport.stream(iterable.spliterator(), false);<br/>
<br/>
System.out.println(Arrays.toString(targetStream.toArray()));</pre>

<p>注意到上面由一个 Lambda 变 Iterator 为 Iterable 了，看 Iterable 接口的源代码</p>

<pre class="lang:default decode:true">public interface Iterable&lt;T&gt; {<br/>
    Iterator&lt;T&gt; iterator();<br/>
<br/>
    default void forEach(Consumer&lt;? super T&gt; action) {<br/>
        Objects.requireNonNull(action);<br/>
        for (T t : this) {<br/>
            action.accept(t);<br/>
        }<br/>
    }<br/>
<br/>
    default Spliterator&lt;T&gt; spliterator() {<br/>
        return Spliterators.spliteratorUnknownSize(iterator(), 0);<br/>
    }<br/>
}</pre>

<p>只有一个抽象方法(其他两个为默认方法)，所以可用</p>

<blockquote><br/>
<p>Iterable&lt;Integer&gt; iterable = () -&gt; sourceIterator</p>

</blockquote>

<p>声明一个 iterator() 返回 sourceIterator 的 Iterable 类型。</p>

<p>再看 Iterable 的默认方法 spliterator() 的实现，同样是调用的</p>

<blockquote><br/>
<p>Spliterators.spliteratorUnknownsSize(iterator(), 0)</p>

</blockquote>

<p>这里的第二个参数 <code>0</code> 实际上不是 Spliterator 中的 <code>CONCURRENT</code>, <code>DISTINCT</code>, <code>IMMUTABLE</code>, <code>NONNULL</code>, <code>SIZED</code>, <code>SORTED</code>, <code>SUBSIZED</code> 中的任何一个值。</p>

<p>写到这里，通过参源代码阅读，前面所述的两种方式实质上没有一点区别。</p>

<h3>对由 Iterator 转换为 Stream 的一个测试</h3><br/>
<p>下面例子创建一个无限大小的 Iterator (hasNext() 永远返回 true)，然后由它转换成 Stream, 再调用 Stream 的 filter 和 limit 来检验它是一个真正的 Stream</p>

<pre class="lang:default decode:true ">    public Stream&lt;Integer&gt; convert(Iterator&lt;Integer&gt; sourceIterator) {<br/>
        Iterable&lt;Integer&gt; iterable = () -&gt; sourceIterator;<br/>
        return StreamSupport.stream(iterable.spliterator(), false);<br/>
    }<br/>
    <br/>
    @Test<br/>
    public void test() {<br/>
        Iterator&lt;Integer&gt; sourceIterator = new Iterator&lt;Integer&gt;() {<br/>
            private AtomicInteger count = new AtomicInteger(0);<br/>
            private Random random = new Random();<br/>
<br/>
            @Override<br/>
            public boolean hasNext() {<br/>
                return true;<br/>
            }<br/>
<br/>
            @Override<br/>
            public Integer next() {<br/>
                System.out.println("next: " + count.incrementAndGet()); //每一次遍历将会打印计数<br/>
                return random.nextInt(99999);<br/>
            }<br/>
        };<br/>
<br/>
        //无条件的获得 3 个元素即可<br/>
        System.out.println(Arrays.toString(convert(sourceIterator).limit(3).toArray()));<br/>
        System.out.println();<br/>
<br/>
        //从流中过虑出小于 30000 的 3 个元素<br/>
        System.out.println(Arrays.toString(convert(sourceIterator).filter(a -&gt; a &lt; 30000).limit(3).toArray()));<br/>
    }</pre>

<p>下面是某一次的执行输出</p>

<blockquote><br/>
<p>next: 1<br /><br/>
next: 2<br /><br/>
next: 3<br /><br/>
[11430, 20177, 64297]</p>

<p>next: 4<br /><br/>
next: 5<br /><br/>
next: 6<br /><br/>
next: 7<br /><br/>
next: 8<br /><br/>
next: 9<br /><br/>
next: 10<br /><br/>
next: 11<br /><br/>
next: 12<br /><br/>
next: 13<br /><br/>
next: 14<br /><br/>
next: 15<br /><br/>
next: 16<br /><br/>
next: 17<br /><br/>
[19378, 16142, 9354]</p>

</blockquote>

<p>该行为与 Stream 是相吻合的，因为 Stream 是一个 Lazy 的，它确实是一个流，无需事选知道流中将会有多少元素。</p>
