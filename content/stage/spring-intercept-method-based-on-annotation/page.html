---
title: Spring 下基于自定义注解拦截方法调用
url: /spring-intercept-method-based-on-annotation/
date: 2017-09-29T23:46:04-05:00
featured: false
draft: false
type: post
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/http://unmi.cc/wp-content/uploads/2016/10/spring-framework-project-logo-200x200.png"
categories:
  - Spring
tags: 
  - Aop
comment: true
codeMaxLines: 50
# additional
wpPostId: 8298 
wpStatus: publish
views: 1962
lastmod: 2021-09-10T12:56:32-05:00
---

其实很多年前就做过如此的实验，一翻开自己的日志有关于 <a href="https://www.google.com/search?q=aspectj+site%3Ayanbin.blog&amp;oq=aspectj+site&amp;aqs=chrome.0.69i59j69i57j0l3.7823j0j1&amp;sourceid=chrome&amp;ie=UTF-8">aspectj site:yanbin.blog</a>, 可以找到  2008 年写的日志。真是流光容易把人抛，红了樱桃，绿了巴蕉。只是那时候 Spring 刚步入 2.0, 才翻开强大 AOP 的篇章，还记得彼时只要是直接使用 AspectJ 就要写  *.aj 文件。而如今 Spring 都到 5.0 了，也就是一年前才重拾起 Spring, 这期间 AspectJ 早就可以不用 *.aj 文件，只需普通 Java 文件，加上 @Aspect 和 @Pointcut 之类的注解就行。</p>
<br/>
本文内容与几年前写过的日志大体相差不大，再缀上一篇纯粹是个人笔记。这里不以 Spring 5.0 为例，仍然是最新的 4.3.11.RELEASE, 并且直接用 Spring, 而非选择  Spring Boot, 因为用了 Spring Boot 常常搞不清楚哪些是自动配置了的。原生的 Spring 可以使自己掌握一个 Spring AOP 的基本要素。<br/><br/>
需求：@LogStartTime 注解的方法，在每次进入该方法时把当前时间写入 ThreadLocal 中去，被 @LogStartTime 注解的方法中随时可以获得进入方法的时间<!--more--><br/><br/>
接下来怎么能离开最具说明问题的代码呢？我们会通过 Main 方法和测试用例来验证。<br/><br/>
<a href="/wp-content/uploads/2017/09/spring-annotation-aop.png"><img class="aligncenter size-full wp-image-8299" src="/wp-content/uploads/2017/09/spring-annotation-aop.png" alt="" width="500" height="365" /></a><br/><br/>
这是项目所有的文件，下面逐一列出内容(为不值钱的篇幅考虑还是会对内容有所裁剪，比如省略 import 部分)<br/><br/>
<h4>pom.xml, 用到以下依赖，用简洁的格式表示</h4><br/><br/>
<pre class="lang:default decode:true ">org.springframework:spring-context:4.3.11.RELEASE:runtime
org.aspectj:aspectjweaver:1.8.9:runtime
javax.inject:javax.inject:1:runtime
junit:junit:4.12:test
org.springframework:spring-test:4.3.11.RELEASE:runtime</pre>
<br/>
<h4>@LogStartTime, 有该注解的方法将被拦截</h4><br/><br/>
<pre class="lang:default decode:true ">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LogStartTime {
}</pre>
<br/>
<h4>MethodStartAspect, 定义切面和 Advice</h4><br/><br/>
<pre class="lang:default decode:true ">@Named   //它也必须是一个 Spring bean，它要能被 Spring 扫描到
@Aspect  //说明这是一个切面定义类
public class MethodStartAspect {<br/><br/>
    private static ThreadLocal&lt;Long&gt; startTime = new ThreadLocal&lt;&gt;();<br/><br/>
    @Pointcut("@annotation(cc.unmi.aspects.LogStartTime)") //切面表达式, 从织入效率上还应该加上像 execution 限制
    private void logStartTime() {  //切面签名，凡是被 LogStartTime 注解的方法都是 logStartTime() 切面<br/><br/>
    }<br/><br/>
    @Before("logStartTime()")  //进入切面 logStartTime() 之前把当前系统时间存入 startTime, 以备后用
    public void setStartTimeInThreadLocal() {
        startTime.set(System.currentTimeMillis());
        System.out.println("saved method start time in threadLocal");
    }<br/><br/>
    public static Long getStartTime() {
        return startTime.get();
    }<br/><br/>
    public static void clearStartTime() {
        startTime.set(null);
    }
}</pre>
<br/>
这个类里就是用的 AspectJ 的语法来定义切面和 Advice 的，也可以定义普通方法。它同样是一个必须由 Spring 来管理的 Bean, 所以有 @Name 注解。代码中有详细的注释。<br/><br/>
Spring AOP 只支持基于方法的拦截，可以拦截到 public, protected 和 package-visible 方法，从设计交互上应该只拦截 public 方法。其他诸如属性，构造函数等的拦截就得用真正的 AspectJ 了.<br/><br/>
切面的定义还可以内联，如上面的 @Before("logStartTime()") 可以一句话写成 @Before("annotation(cc.unmi.aspects.LogStartTime)").<br/><br/>
<h4>AppConfig, Spring  的 Java  Config 文件</h4><br/><br/>
<pre class="lang:default decode:true">@Configuration
@EnableAspectJAutoProxy //在原生 Spring 中这个是必须的，在 Spring Boot 中默认是被启用了的
@ComponentScan(basePackages = "cc.unmi") //注意这个要兼顾到 @AspectJ 注释的类
public class AppConfig {<br/><br/>
}</pre>
<br/>
这个配置要能扫描到切面定义(@Aspect) 的类，如上面的 MethodStartAspect<br/><br/>
<h4>UserService, 有我们要拦截的方法</h4><br/><br/>
<pre class="lang:default decode:true">@Named
public class UserService {<br/><br/>
    @LogStartTime  //因为有了这个注解，在方法中便随时能拿到进入该方法的时间，在 ThreadLocal 中
    public String fetchUserById(int userId) {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }<br/><br/>
        System.out.println("start time: " + MethodStartAspect.getStartTime() + ", execution time: " +
            (System.currentTimeMillis() - MethodStartAspect.getStartTime()));<br/><br/>
        return "nameOf" + userId;
    }
}</pre>
<br/>
<h4>HelloAop, 应用类</h4><br/><br/>
<pre class="lang:default decode:true ">public class HelloAop {<br/><br/>
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);<br/><br/>
        UserService userService = context.getBean(UserService.class);
        System.out.println(userService.fetchUserById(234));
    }
}</pre>
<br/>
执行后输出如下：<br/><br/>
<blockquote>
saved method start time in threadLocal<br />
start time: 1506746277397, execution time: 2033<br />
nameOf234
</blockquote>
<br/>
<h4>HelloAopTest, 测试类中看效果</h4><br/><br/>
<pre class="lang:default decode:true ">@ContextConfiguration(classes = AppConfig.class)
@RunWith(SpringJUnit4ClassRunner.class)
public class HelloAopTest {<br/><br/>
    @Inject
    private UserService userService;<br/><br/>
    @Before
    public void setup() {
        MethodStartAspect.clearStartTime();
    }<br/><br/>
    @Test
    public void testSettingMethodStartTimeInThreadLocal() {
        userService.fetchUserById(9999);<br/><br/>
        assertThat(MethodStartAspect.getStartTime(), notNullValue());
    }
}</pre>
<br/>
执行后绿了<a href="/wp-content/uploads/2017/09/spring-annotation-aop-1.png"><img class="aligncenter size-full wp-image-8301" src="/wp-content/uploads/2017/09/spring-annotation-aop-1.png" alt="" width="730" height="95" /></a><br/><br/>
今天测试中碰到过在多模块的 Maven 项目中，把切面定义类 MethodStartAspect 放到另一个模块中方法拦截便失效了，不过刚刚的实验却是正常的，不知为何。<br/><br/>
再进一步，在注解 @LogStartTime 中，我们可以定义属性，然后在切面中根据注解属性的不同作出不同的行为响应，如清楚日志的 MDC ContextMap 等。<br/><br/>
<h4>如何获得注解参数</h4><br/><br/>
如果我们给注解 <code>@LogStartTime</code> 加个参数，那么它的声明就是<br/><br/>
<pre class="lang:default decode:true ">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LogStartTime {
    String value() default "";
}</pre>
<br/>
这时候要在切面中获得该注解的  value 参数的写法如下<br/><br/>
<pre class="lang:default decode:true ">@Named
@Aspect
public class MethodStartAspect {<br/><br/>
    @Pointcut("execution(* cc.unmi..*(..)) &amp;&amp; @annotation(logStartTime)")
    private void logStartTimePointcut(LogStartTime logStartTime) {<br/><br/>
    }<br/><br/>
    @Before("logStartTimePointcut(logStartTime)")
    public void setStartTimeInThreadLocal(LogStartTime logStartTime) {
        System.out.println(logStartTime.value());
    }
}</pre>
<br/>
Spring 中运用 AOP 时有三种写法风格：<br/><br/>
<ol>
    <li>AspectJ language code style:  就是我原来写过的 *.aj 文件的语法。Java5 之前的无奈之选</li>
    <li>AspectJ annotation style: Java 代码却不失 *.aj 的特性，我的钟爱。而且它是 Spring AOP 和 AspectJ 同时能理解的</li>
    <li>Spring XML style: 这都什么年代了，缺点多多</li>
</ol>
<br/>
本文完整代码可查看 Github 仓库 <a href="https://github.com/yabqiu/spring-annotation-aop" target="_blank" rel="nofollow noopener">spring-annotation-aop</a><br/><br/>
最好的帮助应该还是 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop">Spring 的官方文档 AOP</a> 篇。
