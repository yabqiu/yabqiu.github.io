---
title: Quartz Job Scheduling Framework［翻译］第十章. J2EE 中使用 Quartz (第二部分)
url: /quartz-job-scheduling-framework-10-2/
date: 2007-12-09T07:55:00-06:00
featured: false
draft: true
toc: false
# menu: main
usePageBundles: true
categories:
  - Quartz
tags: 
  - Quartz
  - 翻译
comment: true
codeMaxLines: 50
# additional
wpPostId: 459 
wpStatus: publish
views: 430
lastmod: 2021-09-02T21:08:01-05:00
---

<strong>·在 J2EE 应用服务器中运行 Quartz<br />
</strong></p>
<br/>
作为 J2EE 客户端运行 Quartz 比运行为外部 J2SE 应用程序稍显繁琐。这主要是因为部署一个应用到容器中有点了儿复杂，J2EE 规范对容器中的组件会有些约束。其中最大的原则之一就是涉及到该由谁来创建线程。因为 J2EE 容器有责任去管理所有资源，所以它并非允许谁想谁就能创建线程的。假如是这样的话，容器就会要更艰难的去管理环境和保证一切稳定性。Quartz 会创建自己的工作者线程，所以你必须依照一些步骤来保证它能正常的运转。<br/><br/>
确保代像代码 10.1 那样的一个无状态会话 Bean 已部署到容器中。最简单的部署 Quartz 到容器中的方式是构建一个包含所必须文件的 WAR 包，然后使用管理工具或 Eclipse 部署这个 Web 应用到容器中。<!--more--><br/><br/>
这个 Web 应用的目录结构像其他任何 Web 应用是一样的。你必须添加以下文件至其中：<br/><br/>
    ·<span style="color: #800080;">web.xml</span> (放置到 <span style="color: #800080;">WEB-INF</span> 下)<br/><br/>
    ·<span style="color: #800080;">quartz.properties</span> (放置在 <span style="color: #800080;">WEB-INF/classes</span> 下)<br/><br/>
    ·<span style="color: #800080;">quartz_jobs.xml</span> (放置在 <span style="color: #800080;">WEB-INF/classes</span> 下)<br/><br/>
    ·Quartz 二进制包 (放置在 <span style="color: #800080;">WEB-INF/lib</span> 下)<br/><br/>
    ·所需第三方包 (放置在 <span style="color: #800080;">WEB-INF/lib</span> 下)<br/><br/>
因为正在构建一个 Web 应用，所以要加入一个必备的 <span style="color: #800080;">web.xml</span> 作为部署描述文件。代码10.4 中显示了我们要安装到容器中的客户端应用的 <span style="color: #800080;">web.xml</span> 文件。<br/><br/>
<strong>代码 10.4. Quartz J2EE 客户端程序的 <span style="color: #800080;">web.xml</span> 文件<br />
</strong><br/><br/>
<pre class="lang:default decode:true">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/><br/>
&lt;web-app&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;QuartzServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;
      org.quartz.ee.servlet.QuartzInitializerServlet
    &lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;<br/><br/>
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;QuartzServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/servlet/QuartzServlet&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre>
<br/>
Quartz 框架包含有一个名为 <span style="color: #800080;">QuartzInitializerServlet</span> 的 Java Servlet，当被调用时它会初始化 Quartz 调度器并加载 Job 信息。在代码 10.4 中， 我们看到有设置 <span style="color: #800080;">&lt;load-on-startup&gt;</span> 标记值为 1，这指示着在容器启动的时候这个 servlet 会被自动加载并初始化。通过使用这个 servlet 去启动 Quartz 调度器，我们规避了容器中创建线程的约束，因为容器将允许 servlet 去创建用户线程的。<br/><br/>
<table style="border: 1px;" border="1" width="70%" align="center">
<tbody>
<tr>
<td>
<strong>加入 <span style="color: #800080;">QuartzInitializerListerner</span> 到 Quartz 中</strong>
不久前，一个新的名为 <span style="color: #800080;">QuartzInitializerListener</span> 被加入到 Quartz 中来，它实现了 <span style="color: #800080;">javax.servlet.ServletContextListener</span> 接口。前面也有提过，这个类可用来替代 <span style="color: #800080;">QuartzInitializerServlet</span> 类。 
</td>
</tr>
</tbody>
</table>
<br/>
接下来，你需要把标准的 <span style="color: #800080;">quartz.properties</span> 文件放入到 Web 应用的 <span style="color: #800080;">WEB-INF/classes</span> 目录中去。在这里的这个文件没什么特别的；实质上，这一步与前面同类的操作是一样的。然而，我们这里使用到 <span style="color: #800080;">JobInitializationPluin</span> (这在第八章，"使用 Quartz 插件"，它设计为从 XML 文件中加载 Job 信息)。默认情况下，这个插件查找一个叫做 <span style="color: #800080;">quartz_jobs.xml</span> 文件并从中加载所配置的 Job。如第八章描述的，使用这一特定的插件可以避免你写加载作业的代码，且在代码改变时不得不重新编译。<span style="color: #800080;">quartz_jobs.xml</span> 的内容如 代码 10.5 所示。<br/><br/>
<strong>代码 10.5. J2EE 客户端所用的 <span style="color: #800080;">quartz_jobs.xml</span> 文件<br />
</strong><br/><br/>
<pre class="lang:default decode:true ">&lt;?xml version='1.0' encoding='utf-8'?&gt;<br/><br/>
&lt;quartz&gt;
  &lt;job&gt;
    &lt;job-detail&gt;
        &lt;name&gt;HelloWorldJob&lt;/name&gt;
        &lt;group&gt;DEFAULT&lt;/group&gt;
        &lt;job-class&gt;org.quartz.jobs.ee.ejb.EJBInvokerJob&lt;/job-class&gt;
        &lt;volatility&gt;false&lt;/volatility&gt;
        &lt;durability&gt;false&lt;/durability&gt;
        &lt;recover&gt;false&lt;/recover&gt;<br/><br/>
        &lt;job-data-map allows-transient-data="true"&gt;
          &lt;entry&gt;
            &lt;key&gt;ejb&lt;/key&gt;
            &lt;value&gt;ejb/Test&lt;/value&gt;
          &lt;/entry&gt;
          &lt;entry&gt;
            &lt;key&gt;java.naming.factory.initial&lt;/key&gt;
            &lt;value&gt;org.openejb.client.RemoteInitialContextFactory&lt;/value&gt;
          &lt;/entry&gt;
          &lt;entry&gt;
            &lt;key&gt;java.naming.provider.url&lt;/key&gt;
            &lt;value&gt;127.0.0.1:4201&lt;/value&gt;
          &lt;/entry&gt;
          &lt;entry&gt;
            &lt;key&gt;method&lt;/key&gt;
            &lt;value&gt;helloWorld&lt;/value&gt;
          &lt;/entry&gt;
          &lt;entry&gt;
            &lt;key&gt;java.naming.security.principal&lt;/key&gt;
            &lt;value&gt;system&lt;/value&gt;
          &lt;/entry&gt;
          &lt;entry&gt;
            &lt;key&gt;java.naming.security.credentials&lt;/key&gt;
            &lt;value&gt;manager&lt;/value&gt;
          &lt;/entry&gt;
        &lt;/job-data-map&gt;
    &lt;/job-detail&gt;
    &lt;trigger&gt;
      &lt;simple&gt;
          &lt;name&gt;helloWorldTrigger&lt;/name&gt;
          &lt;group&gt;DEFAULT&lt;/group&gt;
          &lt;job-name&gt;HelloWorldJob&lt;/job-name&gt;
          &lt;job-group&gt;DEFAULT&lt;/job-group&gt;
          &lt;start-time&gt;2005-06-10 6:10:00 PM&lt;/start-time&gt;
          &lt;!- repeat indefinitely every 10 seconds &gt;
          &lt;repeat-count&gt;-1&lt;/repeat-count&gt;
          &lt;repeat-interval&gt;10000&lt;/repeat-interval&gt;
      &lt;/simple&gt;
    &lt;/trigger&gt;
  &lt;/job&gt;
&lt;/quartz&gt;</pre>
<br/>
你能看出在代码  10.5 中，我们仍然使用 <span style="color: #800080;">EJBInvokerJob</span>，只是声明在了  <span style="color: #800080;">quartz_jobs.xml</span> 文件中了。<br/><br/>
<table style="border: 1px;" border="1" width="70%" align="center">
<tbody>
<tr>
<td>
<strong>在 <span style="color: #800080;">quartz.properties</span> 中指定插件</strong>
第八章已讲过，在使用 Quartz 插件就必须在 <span style="color: #800080;">quartz.properties</span> 文件中指定相应的插件信息。对于 <span style="color: #800080;">JobInitialzationPluin</span>，你必须在这个属性文件中加入下面一行代码：
<span style="color: #800080;">org.quartz.plugin.jobInitializer.class = org.quartz.plugins.xml.JobInitializationPlugin</span>
</td>
</tr>
</tbody>
</table>
<br/>
上面的文件都配置好后，就可以构建一个 WAR 文件并部署到你的容器中。当容器启动之后，就会加载那个 servlet 并初化，进而启动了调度器。调度器利用 <span style="color: #800080;">JobInitializerPluin</span> 去从 <span style="color: #800080;">quartz_jobs.xml</span> 文件中加载作业信息。自此，<span style="color: #800080;">EJBInvokerJob</span> 就会调用 EJB 上的 <span style="color: #800080;">helloWorld()</span> 方法了。<br/><br/>
<strong>·包含 J2EE 客户端 JAR 包<br />
</strong><br />
在打包 J2EE 客户程序时，你需要把所需的特定于服务器的 J2EE 客户端 JAR 包打进来。针对不同的容器会有所不同，你需要参照具体文档予于决定。在构建一个独立运行的 Quartz 应用时，你还要加入所需的 Quartz 包。<br/><br/>
<strong>二：使用  J2EE 容器的数据源</strong><br/><br/>
直到此刻，我们有意没去提到 <span style="color: #800080;">JobStores</span> 和 <span style="color: #800080;">DataSources</span>。在第六章，"作业存储和持久化"，你已经学到可以把作业信息存储在内存中，或者假你需要作业信息在两次程序重启之间能持久保存下来，你就可以把作业信息存储到关系型数据库中。存在有两种类型的 JDBC 作业存储方式：<br/><br/>
    ·<span style="color: #800080;">JobStoreTX</span> 在持久化操作过程中自己管理自己的事特<br/><br/>
    ·<span style="color: #800080;">JobStoreCMT</span> 在持久化操作过程中技术容器管理事物(CMT)<br/><br/>
如果你使用了 J2EE 容器并选择了上面的种类型的 JDBC <span style="color: #800080;">JobStores</span>，这时候你最好应该用容器提供的数据源。参考前面第六章，当在 J2EE 容器中使用 JDBC <span style="color: #800080;">JobStores</span> 时如何设置 <span style="color: #800080;">quartz.properties</span> 文件。<br/><br/>
<strong>三：使用其他的 J2EE 资源</strong><br/><br/>
当部署 Quartz 到 J2EE 容器中，你可以利用  J2EE 组件可用的其他资源。例如，假如你需要发送 email，一种途径是得用 Quartz 的 SendMailJob，它依赖于 JavaMail。另一可用途径是，假如你把 Quartz 部署在容器中，能使用所有 J2EE 服务器都可提供的  mail session 资源，当然，前提是你在容器中已配置好的 mail session。那是作为 J2EE 客户端来部署 Quartz 好处之一。<br/><br/>
<pre class="brush:java">InitialContext initialContext = new InitialContext();
Session session = (Session)
initialContext.lookup(urlToMailSession);<br/><br/>
Message msg = new MimeMessage(session);
// ... build up msg
Transport.send(msg);</pre>
<br/>
<strong>四：EJB 2.1 规范：最后的曙光</strong><br/><br/>
在 EJB 2.1 的第 22 章中讨论到企业 JavaBean 的一个新的特性，定时器服务。这是一个容器管理的服务，给予需要基于时间事件的组件回调服务。实质上就是 EJB 能通过这一服务注册他们自己，当到了它们要执行的时间时就会接收到一个通知。定时器服务是被 EJB 容器实现并管理着的。现在还不知道 J2EE 厂商还要在那些规范后面加上多少功能。有些人争辩说 EJB 定时器的提议内容还不充分，同样的原因，java.util.Timer 类也不足以真正应付调度程序。最好也看看 EJB 的架构规范，可加入对框架的插件支持，例如 Quartz 就可以用来增强定时器服务的灵活性。
