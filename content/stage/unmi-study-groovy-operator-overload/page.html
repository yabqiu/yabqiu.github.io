---
title: Unmi 学习 Groovy 之操作符重载
url: /unmi-study-groovy-operator-overload/
date: 2008-09-02T05:32:00-05:00
featured: false
draft: true
toc: false
# menu: main
usePageBundles: true
categories:
  - Groovy
tags: 
  - Groovy
  - Overload
comment: true
codeMaxLines: 50
# additional
wpPostId: 337 
wpStatus: publish
views: 631
lastmod: 2021-09-02T14:26:00-05:00
---

Java 相比于 C++ 语法来说去除了指针及显式内存释放，受到不少赞誉，的确避免很多的出错的可能性，提高了生产率。可是把操作符重载也拿掉了，也没了条件编译。这两项特性在 C# 是有的。操作符在 C++ 中似乎不是很好理解，它可以带来很大的灵活性，和操作的直观性。Java 大约想的是过宽的灵活性怕带来过度的滥用，在大型项目会有所不利。</p>
<br/>
因此由 Java 所衍生的 Groovy 脚本像 Perl、Python、Ruby 一样又有了操作符重载，脚本基于其应用领域需要更多的灵活性和自由度。<br/><br/>
Groovy 中对操作的操作比起 C++ 中来说更简单，Groovy 中是把操作符映射到对应命名方法的调用，你只要重载了该命名方法便是重载了相应的操作符，比如说加号+ 映射到 <span style="color: #800080;">plus(obj)</span> 方法，你只要重载了 <span style="color: #800080;">plus(obj)</span> 即改变了加号+ 的形为。对于其他符号也是一样的。<!--more--><br/><br/>
举例说明，例如有一个 Basket，装着白菜和萝卜的数量分别为 cabbageAmt, radishAmt，当两个 Basket 中东西要摆放到一个大 Basket 里并返回一个新的 Basket 实例时，就要对先前两个篮子里的白菜和萝卜数量分别相加，这时候就是要重载 Basket 的 <span style="color: #800080;">plus</span> 方法，代码如下：<br/><br/>
<pre class="brush:groovy">class Basket{
    int cabbageAmt,radishAmt;
    def plus(Basket anotherBasket){ //两个 Basket 的加操作会调用这个方法
        return new Basket(cabbageAmt:this.cabbageAmt+anotherBasket.cabbageAmt,
            radishAmt:this.radishAmt+anotherBasket.radishAmt);
    }
    String toString(){
        return "In that basket, the amount of cabbage is "
            +cabbageAmt+" and the amount of radish is "+radishAmt;
    }
}<br/><br/>
Basket basket1 = new Basket(cabbageAmt:1,radishAmt:2);
Basket basket2 = new Basket(cabbageAmt:3,radishAmt:4);
Basket basket3 = basket1 + basket2;
println basket3;</pre>
<br/>
输出加操后的结果： In that basket, the amount of cabbage is 4 and the amount of radish is 6<br/><br/>
对于其他的操作符的重载，要重载的相应命名方法的对应表如下，也是 Groovy 语法目前所支持的所有操作符：<br/><br/>
<div>
<table id="table1" style="border-collapse: collapse;" border="1" width="75%" cellspacing="0" cellpadding="2">
<tbody>
<tr>
<td align="middle" width="93"><strong>Operator</strong></td>
<td align="middle" width="180"><strong>Name</strong></td>
<td align="middle" width="174"><strong>Method</strong></td>
<td align="middle"><strong>Works with</strong></td>
</tr>
<tr>
<td width="93">a + b</td>
<td width="180">Plus</td>
<td width="174">a.plus(b)</td>
<td>Number,string,collection</td>
</tr>
<tr>
<td width="93">a - b</td>
<td width="180">Minus</td>
<td width="174">a.minus(b)</td>
<td>Number,string,collection</td>
</tr>
<tr>
<td width="93">a * b</td>
<td width="180">Star</td>
<td width="174">a.multiply(b)</td>
<td>Number,string,collection</td>
</tr>
<tr>
<td width="93">a / b</td>
<td width="180">Divide</td>
<td width="174">a.div(b)</td>
<td>Number</td>
</tr>
<tr>
<td width="93">a % b</td>
<td width="180">Modulo</td>
<td width="174">a.mod(b)</td>
<td>Integral number</td>
</tr>
<tr>
<td width="93">a++</td>
<td width="180">Post increment</td>
<td rowspan="2" width="174">a.next()</td>
<td rowspan="2">Number,string,range</td>
</tr>
<tr>
<td width="93">++a</td>
<td width="180">Pre increment</td>
</tr>
<tr>
<td width="93">a--</td>
<td width="180">Post decrement</td>
<td rowspan="2" width="174">a.previous()</td>
<td rowspan="2">Number,string,range</td>
</tr>
<tr>
<td width="93">--a</td>
<td width="180">Pre decrement</td>
</tr>
<tr>
<td width="93">a**b</td>
<td width="180">Power</td>
<td width="174">a.power(b)</td>
<td>Number</td>
</tr>
<tr>
<td width="93">a | b</td>
<td width="180">Numerical or</td>
<td width="174">a.or(b)</td>
<td>Integral number</td>
</tr>
<tr>
<td width="93">a &amp; b</td>
<td width="180">Numerical and</td>
<td width="174">a.and(b)</td>
<td>Integral number</td>
</tr>
<tr>
<td width="93">a ^ b</td>
<td width="180">Numerical xor</td>
<td width="174">a.xor(b)</td>
<td>Integral number</td>
</tr>
<tr>
<td width="93">~a</td>
<td width="180">Bitwise complement</td>
<td width="174">a.negate()</td>
<td>Integral number,string<br />
(the latter returning a regular expression pattern)</td>
</tr>
<tr>
<td width="93">a[b]</td>
<td width="180">Subscript</td>
<td width="174">a.getAt(b)</td>
<td>Object,list,map,string、Array</td>
</tr>
<tr>
<td width="93">a[b] = c</td>
<td width="180">Subscript assignment</td>
<td width="174">a.puAt(b,c)</td>
<td>Object,list,map,StringBuffer,<br />
Array</td>
</tr>
<tr>
<td width="93">a &lt;&lt; b</td>
<td width="180">Left shift</td>
<td width="174">a.leftShift(b)</td>
<td>Integral number, also used like "append" to StringBuffers, Writers, Files, Sockets, Lists</td>
</tr>
<tr>
<td width="93">a &gt;&gt; b</td>
<td width="180">Right shift</td>
<td width="174">a.rightShift(b)</td>
<td>Integral number</td>
</tr>
<tr>
<td width="93">a &gt;&gt;&gt; b</td>
<td width="180">Right shift unsigned</td>
<td width="174">a.rightShiftUnsigned(b)</td>
<td>Integral number</td>
</tr>
<tr>
<td width="93">switch(a){<br />
case b:<br />
}</td>
<td width="180">Classification</td>
<td width="174">b.isCase(a)</td>
<td>Object, range, list, collection, pattern, closure; also used with collection c in c.grep(b), which returns all items of c where b.isCase(item)</td>
</tr>
<tr>
<td width="93">a == b</td>
<td width="180">Equals</td>
<td width="174">a.equals(b)</td>
<td>Object, consider hashCode()</td>
</tr>
<tr>
<td width="93">a != b</td>
<td width="180">Not equals</td>
<td width="174">!a.equals(b)</td>
<td>Object</td>
</tr>
<tr>
<td width="93">a &lt;=&gt; b</td>
<td width="180">Spaceship</td>
<td width="174">a.compareTo(b)</td>
<td rowspan="5">java.lang.Comparable</td>
</tr>
<tr>
<td width="93">a &gt; b</td>
<td width="180">Greater than</td>
<td width="174">a.compareTo(b) &gt; 0</td>
</tr>
<tr>
<td width="93">a &gt;= b</td>
<td width="180">Greater than or equal to</td>
<td width="174">a.compareTo(b) &gt;= 0</td>
</tr>
<tr>
<td width="93">a &lt; b</td>
<td width="180">Less than</td>
<td width="174">a.compareTo(b) &lt; 0</td>
</tr>
<tr>
<td width="93">a &lt;= b</td>
<td width="180">Less than or equal to</td>
<td width="174">a.compareTo(b) &lt;= 0</td>
</tr>
<tr>
<td width="93">a as type</td>
<td width="180">Enforced coercion</td>
<td width="174">a.asType(typeClass)</td>
<td>Any type</td>
</tr>
</tbody>
</table>
</div>
<br/>
重载 equals() 方法时，Java 强烈建议重载 <span style="color: #800080;">hashCode()</span> 方法，对象相等时希望 hashcode 也是一样，尽管是非必要的，参看 java.lang.Object#equals 的 API 说明。<br/><br/>
严格意义上讲，还有更多的符号可以重载，例如，引用字段和方法的点(.) 操作符就可以被重载了。通过对 Date 的 . 操作重载可以支持以下代码的写法(这要用到 <span style="color: #800080;">MetaClass</span> 来改造原有类)，这要再来一篇细究的：<br/><br/>
<span style="color: #0000ff;">newDate = date + 1.month + 3.days + 5.hours;</span> //IBM DB2 数据库就支持这种更人性化的写法<br/><br/>
还应注意以下几个情况：<br/><br/>
<strong>1)</strong> 在 Groovy 中的 <span style="color: #0000ff;">a==b</span> 比较操作是依照 <span style="color: #800080;">equals()</span> 方法来比较的。而在 Java 的 <span style="color: #0000ff;">a==b</span> 比较操作，到了 Groovy 中就要用 <span style="color: #0000ff;">a.is(b)</span>。<br/><br/>
<strong>2)</strong> 有些操作已经在许多的 Java 类或是 Groovy 数据结构中实现了，那么就可以直接使用，例如对两个 Double 类型可以用 <span style="color: #800080;">==</span>、<span style="color: #800080;">&gt; </span>等符号进行比较；<br />
还有 Groovy 中的集合，如<br/><br/>
<pre class="brush:groovy">list = [1,2,3]
println list[2]  //Groovy 为集合实现了的索引操作符[]</pre>
<br/>
<strong>3)</strong> Groovy 在使用比较操作符时对 null 值处理很优雅。换句话说，如果一个(或者两个) 值为 null，就不会抛出 <span style="color: #ff1493;">java.lang.NullPointerException</span>。<br/><br/>
比如再给上面的 Basket 加上方法<br/><br/>
<pre class="lang:default decode:true ">def equals(Basket anotherBasket){
    return this.cabbageAmt==anotherBasket.cabbageAmt
           &amp;&amp; this.radishAmt==anotherBasket.radishAmt
}</pre>
<br/>
再执行以下代码:<br/><br/>
<pre class="brush:groovy">Basket basket1 = new Basket(cabbageAmt:1,radishAmt:2);
Basket basket2 = null;<br/><br/>
println basket1 == basket2;</pre>
<br/>
执行后的输出为 <span style="color: #800080;">false</span>，如果按照 Java 中的思维, <span style="color: #0000ff;">basket1 ==basket2</span> 会调用 Basket 的 <span style="color: #800080;">equals()</span> 方法，而 basket2 为 null，在执行 <span style="color: #800080;">equals()</span> 方法时就会抛出 <span style="color: #ff1493;">java.lang.NullPointerException</span> 异常，而实质上是 Groovy 在生成 <span style="color: #800080;">equals()</span> 方法时插入了 null 检查代码，所以不抛出异常。<br/><br/>
<strong>4)</strong> 因为被重载的符号是映射到相应的方法，所以 <span style="color: #0000ff;">basket1 + basket2</span> 实际和 <span style="color: #0000ff;">basket1.plus(basket2)</span> 是一致的，即调用第一个操作数的 <span style="color: #800080;">plus()</span> 方法，第二个操作数为参数。这里前后两个操作数是同类型的，所以应用加号的交互法则，写成 <span style="color: #800080;">basket2 + basket1</span> 也成立，因为对 <span style="color: #800080;">baksket2.plus(basket1)</span> 调用是合法的。<br/><br/>
不过，要是在 Basket 类中定义如下方法：(加上一个整数，我们假定给篮子加 1 的意义在于白菜和萝卜的数量各加上 1)<br/><br/>
<pre class="brush:groovy">def plus(int i){
    return new Basket(cabbageAmt:this.cabbageAmt+i,
        radishAmt:this.radishAmt+i);
}</pre>
<br/>
那么我们写下这样的代码<br/><br/>
<span style="color: #0000ff;">basket1 + 1;</span><br/><br/>
OK,没问题，如果还想当然的可以互换，写成 <span style="color: #800080;">1 + basket1</span>; 那就有异常了，<br/><br/>
<span style="color: #ff0000;">groovy.lang.MissingMethodException: No signature of method: java.lang.Integer.plus() is applicable for argument types: (Basket)</span><br/><br/>
因为这时候是通过 <span style="color: #800080;">Integer</span> 来调用 <span style="color: #800080;">plus(bakset)</span> 的，即 <span style="color: #800080;">1.plus(basket1)</span>，而 <span style="color: #800080;">Integer</span> 是没有定义 <span style="color: #800080;">plus(Basket basket)</span> 这样一个方法，所以出错。如果两边都定义了相应的 <span style="color: #800080;">plus()</span> 方法，就可以把加数和被加数互换了。这个问题在其他有符号重载特性的语言中同样是存在的，只要留意了被重载的方法内部实际是如何被调用的就不会有问题了。<br />
参考：1. 《Java 脚本编程语言、框架与模式》第 4 章<br />
2. 《Groovy in Action》2.2 Overriding operators
