---
title: 逐步理解 Flask 的 Blueprint(蓝本)
url: /understand-flask-blueprint/
date: 2021-12-06T14:30:30-06:00
featured: false
draft: false
type: post
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/https://yanbin.blog/wp-content/uploads/2020/07/flask-logo.png"
categories:
  - Python
  - Flask
tags: 
  - Flask
comment: true
codeMaxLines: 50
# additional
wpPostId: 12013 
wpStatus: publish
views: 969
lastmod: 2021-12-07T22:30:38-06:00
---

Python 的 <a href="https://flask.palletsprojects.com/">Flask</a> 框架能让我们快速的建立一个轻量级的 Web 或 REST API。对于小应用由一个 @app 装饰一撸到底就行，当项目稍具规模或要更清晰就要考虑模块化，于是来到了我们今天的话题，首先是<br/><br/>
<h3>为什么需要 Blueprint?</h3><br/><br/>
比如说我们一定超级简单的 Flask 应用 main.py 的代码如下：<br/><br/>
<pre class="lang:default decode:true">from flask import Flask<br/><br/>
app = Flask(__name__)<br/><br/>

@app.route('/', methods=['GET'])
def hello():
    return "hello world!"
</pre>
<br/>
<!--more-->现在需要加上一个后端管理 admin 模块，可以继续在 main.py 中加代码，并且依然用 @app 来装饰<br/><br/>
<pre class="lang:default decode:true">from flask import Flask<br/><br/>
app = Flask(__name__)<br/><br/>

@app.route('/admin/user', methods=['POST'])
def add_user():
    return 'add user'<br/><br/>

@app.route('/', methods=['GET'])
def hello():
    return "hello world!"
</pre>
<br/>
这只是用 URL 前缀来区分了功能，分别是<br/><br/>
<ol>
    <li>GET /</li>
    <li>POST /admin/users</li>
</ol>
<br/>
再进一步, 我们可在同一个模块中使用 Blueprint，main.py 的代码变为<br/><br/>
<pre class="lang:default mark:4,7,17 decode:true ">from flask import Flask, Blueprint<br/><br/>
app = Flask(__name__)
admin = Blueprint('admin_blueprint', __name__)<br/><br/>

@admin.route('/user', methods=['POST'])
def add_user():
    return 'add user'<br/><br/>

@app.route('/', methods=['GET'])
def hello():
    return "hello world!"<br/><br/>

app.register_blueprint(admin, url_prefix='/admin')
</pre>
<br/>
实现的功能与前面的 main.py 是一样的。从这里高亮行可以看出实现一个 Blueprint 需要基本的三步<br/><br/>
<ol>
    <li>声明一个 Blueprint</li>
    <li>用 Blueprint 实例去装饰函数</li>
    <li>注册 Blueprint 到 Flask 应用实例上</li>
</ol>
<br/>
由 Blueprint 装饰的函数，访问时必须加上它的 <code>url_prefix</code> 前缀。如<br/><br/>
<blockquote>
@admin.route('/user', methods=['POST'])
</blockquote>
<br/>
访问时要加上 <code>/admin</code> 前缀，就是<br/><br/>
<blockquote>
POST /admin/users
</blockquote>
<br/>
注：有两种方式指定 Blueprint 的 url_prefix<br/><br/>
<ol>
    <li>声明 Blueprint 时可以指定 url_prefix: 相当于是默认的 url_prefix</li>
    <li>向 app 注册 Blueprint 时也可以指定 url_prefix：注册时不指定就用声明时的 url_prefix, 否则会覆盖声明时的 url_prefix</li>
</ol>
<br/>
Blueprint 的 url_prefix 就像是 Java 的 Spring MVC 中 Controller 类的 @RequestMapping 定义一样，定义在类级别的 @RequestMapping path 会作为 Controller 方法的 URL 前缀。<br/><br/>
<h3>使用 Blueprint 模块化应用</h3><br/><br/>
上一节中我们体验了在同一个 Python 使用 Blueprint, 虽然 Blueprint 是通了，但那样不能算作真正的模块化。要实现模块化至少得把功能分到不同的 Python 文件中去，最好是有各自的目录。也就产生了两种使用 Blueprint 模块化的方式，使用模块和包<br/><br/>
<h4>Blueprint 定义在不同的模块中</h4><br/><br/>
首先进行文件分家，我们要把 <code>/admin</code> 下的实现挪到  <code>admin.py</code>  文件中去，于是 <code>main.py</code> 和 <code>admin.py</code> 的内容就变成了<br/><br/>
admin.py<br/><br/>
<pre class="lang:default decode:true">from flask import Blueprint<br/><br/>
admin = Blueprint('admin_blueprint', __name__)<br/><br/>

@admin.route('/users', methods=['POST'])
def add_user():
    return 'add user'</pre>
<br/>
在 admin 中像使用 @app 一样用 @admin 装饰，并且不需要知道哪个 Flask 应用去注册它<br/><br/>
main.py<br/><br/>
<pre class="lang:default decode:true ">from flask import Flask
from admin import admin<br/><br/>
app = Flask(__name__)<br/><br/>

@app.route('/', methods=['GET'])
def hello():
    return "hello world!"<br/><br/>

app.register_blueprint(admin, url_prefix='/admin')</pre>
<br/>
注册第二行的引用是从模块 admin 中引用同名的  admin 变量<br/><br/>
<h4>Blueprint 定义在不同的包(目录) 中</h4><br/><br/>
对于更复杂的应用，把不同功能分布到不同的模块文件中还不够，用包(目录)来组织不同的功能就显得十分的必要了。<br/><br/>
如果在 admin 中只有一个 user 模块使用了 Blueprint，我们可以用下面的目录结构<br/><br/>
<blockquote>
my-project<br />
├── admin<br />
│   └── user.py<br />
└── main.py
</blockquote>
<br/>
在 user.py 中<br/><br/>
<pre class="lang:default decode:true ">from flask import Blueprint<br/><br/>
admin = Blueprint('admin', __name__)<br/><br/>

@admin.route('/users', methods=['POST'])
def add_user():
    return 'add user'</pre>
<br/>
在 main.py 中就是<br/><br/>
<pre class="lang:default decode:true">from flask import Flask
from admin.user import admin<br/><br/>
app = Flask(__name__)<br/><br/>

@app.route('/', methods=['GET'])
def hello():
    return "hello world!"<br/><br/>

app.register_blueprint(admin, url_prefix='/admin')</pre>
<br/>
现在两个 API<br/><br/>
<ol>
    <li>GET /</li>
    <li>POST /admin/users</li>
</ol>
<br/>
再往 admin 包中添加一个  order 模块，情形就变得稍微复杂了，由 order 和  user 都必须使用同一个 Blueprint 实例，所以需要在 __init__.py 中初始化它。同时为了在 Flask 启动时加载 admin/user 和 admin/order 模块，也就要在 __init__.py 中导入它们(main 导入 admin 包时还要立即导入其下的  user 和  order 模块)。所以，重新组织后的目录结构如下<br/><br/>
<blockquote>
my-project<br />
├── admin<br />
│   ├── __init__.py<br />
│   ├── order.py<br />
│   └── user.py<br />
└── main.py
</blockquote>
<br/>
每个文件的内容如下<br/><br/>
admin/order.py<br/><br/>
<pre class="lang:default decode:true ">from admin import admin<br/><br/>

@admin.route('/orders', methods=['GET'])
def list_orders():
    return 'all orders'</pre>
<br/>
admin/user.py<br/><br/>
<pre class="lang:default decode:true ">from admin import admin<br/><br/>

@admin.route('/users', methods=['POST'])
def add_user():
    return 'add user'</pre>
<br/>
admin/__init__.py<br/><br/>
<pre class="lang:default decode:true ">from flask import Blueprint<br/><br/>
admin = Blueprint('admin', __name__)<br/><br/>
from . import user
from . import order</pre>
<br/>
这个文件的内容必须在声明 Blueprint 后把使用了它的模块导入到命包空间来，否则不能注册那些 endpoints。其目的就是当我们在 main.py 中用<br/><br/>
<blockquote>
from admin import admin
</blockquote>
<br/>
导入 admin 包时能立即导入 admin 包中的 user 和 order 模块<br/><br/>
如果不想在 admin/__init__.py 中逐个导入子模块，而需要把所有子模块全部自动引入的话，就在 __init__.py 中加入下方的代码<br/><br/>
<pre class="lang:default decode:true ">import pkgutil
for loader, module_name, is_pkg in pkgutil.walk_packages(__path__):
    _module = loader.find_module(module_name).load_module(module_name)
    globals()[module_name] = _module</pre>
<br/>
或者<br/><br/>
<pre class="lang:default decode:true ">import importlib
import pkgutil<br/><br/>
for loader, module_name, is_pkg in pkgutil.walk_packages(__path__, __name__ + '.'):
    importlib.import_module(module_name)</pre>
<br/>
IDE 可能会提示后面的  <code>import</code> 语句要提到前面去，这时候不能听它的，否则出现错误<br/><br/>
<blockquote>
ImportError: cannot import name 'admin' from partially initialized module 'admin' (most likely due to a circular import)
</blockquote>
<br/>
main.py<br/><br/>
<pre class="lang:default decode:true">from flask import Flask
from admin import admin<br/><br/>
app = Flask(__name__)<br/><br/>

@app.route('/', methods=['GET'])
def hello():
    return "hello world!"<br/><br/>

app.register_blueprint(admin, url_prefix='/admin')</pre>
<br/>
main.py 文件没什么变化，关键的部分应该是在 admin/__init__.py 中<br/><br/>
现在运行  Flask，就有以下三个 API<br/><br/>
<ol>
    <li>GET /</li>
    <li>GET /admin/orders</li>
    <li>POST /admin/users</li>
</ol>
<br/>
<h3>关于  Flask Blueprint 的其他知识</h3><br/><br/>
更多的关于 Blueprint 的用法可参考源码中的 Bluepint 初始函数和 Flask.register_blueprint 注册函数。<br/><br/>
由于 Blueprint 相当于一个 Flask 应用的子站点，所以它可以定义自己的静态文件映射，子域名。Blueprint 可以嵌套，也就是一个 Blueprint 还能注册另一个 Blueprint<br/><br/>
<pre class="lang:default decode:true ">blueprint_aa = Blueprint("aa", __name__)
blueprint_bb = Blueprint("aa", __name__)
blueprint_aa.register_blueprint(bb, url_prefix="/bb")<br/><br/>
app.register_blueprint(blueprint_aa, url_prefix="/aa")</pre>
<br/>
那么 blueprint_bb 中的 /user 的 API 完整路径就是<br/><br/>
<blockquote>
/aa/bb/user
</blockquote>
<br/>
我们或许还可以考虑把 Flask app 和 Blueprint 实例作为参数传递给别的模块使用。<br/><br/>
链接：<br/><br/>
<ol>
    <li><a href="https://flask.palletsprojects.com/en/2.0.x/blueprints/">Modular Applications with Blueprints</a></li>
    <li><a href="https://realpython.com/flask-blueprint/">Use a Flask Blueprint to Architect Your Applications</a></li>
</ol>
