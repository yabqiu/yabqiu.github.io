---
title: 使用 Java8 Optional 的正确姿势
url: /proper-ways-of-using-java8-optional/
date: 2016-09-05T01:52:54-05:00
featured: false
draft: false
type: post
toc: false
# menu: main
usePageBundles: true
categories:
  - Java/JEE
  - Java8
tags: 
  - java8
  - Optional
comment: true
codeMaxLines: 50
# additional
wpPostId: 7415 
wpStatus: publish
views: 9846
lastmod: 2021-09-03T17:15:36-05:00
---

我们知道 Java 8 增加了一些很有用的 API, 其中一个就是 Optional. 如果对它不稍假探索, 只是轻描淡写的认为它可以优雅的解决 NullPointException 的问题, 于是代码就开始这么写了<br/><br/>
<blockquote>
Optional&lt;User&gt; user = ...... <br />
if (user.isPresent()) {<br />
    return user.getOrders();<br />
} else {<br />
    return Collections.emptyList();<br />
}
</blockquote>
<br/>
那么不得不说我们的思维仍然是在原地踏步, 只是本能的认为它不过是 User 实例的包装, 这与我们之前写成<br/><br/>
<blockquote>
User user = .....<br />
if (user != null) {<br />
    return user.getOrders();<br />
} else {<br />
    return Collections.emptyList();<br />
}
</blockquote>
<br/>
实质上是没有任何分别. 这就是我们将要讲到的使用好 Java 8 Optional 类型的正确姿势.<br/><br/>
在里约奥运之时, 新闻一再提起五星红旗有问题, 可是我怎么看都看不出来有什么问题, 后来才道是小星星膜拜中央的姿势不对. 因此我们千万也别对自己习以为常的事情觉得理所当然, 丝毫不会觉得有何不妥, 换句话说也就是当我们切换到 Java 8 的 Optional 时, 不能继承性的对待过往 null 时的那种思维, 应该掌握好新的, 正确的使用 Java 8 Optional 的正确姿势.<!--more--><br/><br/>
直白的讲, 当我们还在以如下几种方式使用 Optional 时, 就得开始检视自己了<br/><br/>
<ol>
    <li>调用 <code>isPresent()</code> 方法时</li>
    <li>调用 <code>get()</code> 方法时</li>
    <li>Optional 类型作为类/实例属性时</li>
    <li>Optional 类型作为方法参数时</li>
</ol>
<br/>
<code>isPresent()</code> 与 <code>obj != null</code> 无任何分别, 我们的生活依然在步步惊心. 而没有 <code>isPresent()</code> 作铺垫的 <code>get()</code> 调用在 IntelliJ IDEA 中会收到告警<br/><br/>
<blockquote>
Reports calls to java.util.Optional.get() without first checking with a isPresent() call if a value is available. If the Optional does not contain a value, get() will throw an exception. (调用 Optional.get() 前不事先用 isPresent() 检查值是否可用. 假如 Optional 不包含一个值, get() 将会抛出一个异常)
</blockquote>
<br/>
把 Optional 类型用作属性或是方法参数在 IntelliJ IDEA 中更是强力不推荐的<br/><br/>
<blockquote>
Reports any uses of java.util.Optional&lt;T&gt;, java.util.OptionalDouble, java.util.OptionalInt, java.util.OptionalLong or com.google.common.base.Optional as the type for a field or a parameter. Optional was designed to provide a limited mechanism for library method return types where there needed to be a clear way to represent "no result". Using a field with type java.util.Optional is also problematic if the class needs to be Serializable, which java.util.Optional is not. (使用任何像 Optional 的类型作为字段或方法参数都是不可取的. Optional 只设计为类库方法的, 可明确表示可能无值情况下的返回类型. Optional 类型不可被序列化, 用作字段类型会出问题的)
</blockquote>
<br/>
所以 Optional 中我们真正可依赖的应该是除了 <code>isPresent()</code> 和 <code>get()</code> 的其他方法:<br/><br/>
<ol>
    <li>public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper)</li>
    <li>public T orElse(T other)</li>
    <li>public T orElseGet(Supplier&lt;? extends T&gt; other)</li>
    <li>public void ifPresent(Consumer&lt;? super T&gt; consumer)</li>
    <li>public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</li>
    <li>public&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper)</li>
    <li>public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X</li>
</ol>
<br/>
我略有自信的按照它们大概使用频度对上面的方法排了一下序.<br/><br/>
先又不得不提一下 Optional 的三种构造方式: <code>Optional.of(obj)</code>,  <code>Optional.ofNullable(obj)</code> 和明确的 <code>Optional.empty()</code><br/><br/>
<code>Optional.of(obj)</code>: 它要求传入的 obj 不能是 null 值的, 否则还没开始进入角色就倒在了 <code>NullPointerException</code> 异常上了.<br/><br/>
<code>Optional.ofNullable(obj)</code>: 它以一种智能的, 宽容的方式来构造一个 Optional 实例. 来者不拒, 传 null 进到就得到 <code>Optional.empty()</code>, 非 null 就调用 <code>Optional.of(obj)</code>.<br/><br/>
那是不是我们只要用 <code>Optional.ofNullable(obj)</code> 一劳永逸, 以不变应二变的方式来构造 Optional 实例就行了呢? 那也未必, 否则 <code>Optional.of(obj)</code> 何必如此暴露呢, 私有则可?<br/><br/>
我本人的观点是:  1. 当我们非常非常的明确将要传给 <code>Optional.of(obj)</code> 的 <code>obj</code> 参数不可能为 null 时, 比如它是一个刚 <code>new</code> 出来的对象(<code>Optional.of(new User(...))</code>), 或者是一个非 null 常量时;  2. 当想为 <code>obj</code> 断言不为 null 时, 即我们想在万一 <code>obj</code> 为 null 立即报告 <code>NullPointException</code> 异常, 立即修改, 而不是隐藏空指针异常时, 我们就应该果断的用 <code>Optional.of(obj)</code> 来构造 Optional 实例, 而不让任何不可预计的 null 值有可乘之机隐身于 Optional 中.<br/><br/>
现在才开始怎么去使用一个已有的 Optional 实例, 假定我们有一个实例 <code>Optional&lt;User&gt; user</code>, 下面是几个普遍的, 应避免 <code>if(user.isPresent()) { ... } else { ... }</code> 几中应用方式.<br/><br/>
<h3>存在即返回, 无则提供默认值</h3><br/><br/>
<pre class="lang:default decode:true">return user.orElse(null);  //而不是 return user.isPresent() ? user.get() : null;
return user.orElse(UNKNOWN_USER); </pre>
<br/>
<h3>存在即返回, 无则由函数来产生</h3><br/><br/>
<pre class="lang:default decode:true">return user.orElseGet(() -&gt; fetchAUserFromDatabase()); //而不要 return user.isPresent() ? user: fetchAUserFromDatabase();</pre>
<br/>
<h3>存在才对它做点什么</h3><br/><br/>
<pre class="lang:default decode:true">user.ifPresent(System.out::println);<br/><br/>
//而不要下边那样
if (user.isPresent()) {
  System.out.println(user.get());
}</pre>
<br/>
<h3>map 函数隆重登场</h3><br/><br/>
当 <code>user.isPresent()</code> 为真, 获得它关联的 <code>orders</code>, 为假则返回一个空集合时, 我们用上面的 <code>orElse</code>, <code>orElseGet</code> 方法都乏力时, 那原本就是 <code>map</code> 函数的责任, 我们可以这样一行<br/><br/>
<pre class="lang:default decode:true">return user.map(u -&gt; u.getOrders()).orElse(Collections.emptyList())<br/><br/>
//上面避免了我们类似 Java 8 之前的做法
if(user.isPresent()) {
  return user.get().getOrders();
} else {
  return Collections.emptyList();
}</pre>
<br/>
<code>map</code>  是可能无限级联的, 比如再深一层, 获得用户名的大写形式<br/><br/>
<pre class="lang:default decode:true">return user.map(u -&gt; u.getUsername())
           .map(name -&gt; name.toUpperCase())
           .orElse(null);</pre>
<br/>
这要搁在以前, 每一级调用的展开都需要放一个 null 值的判断<br/><br/>
<pre class="lang:default decode:true">User user = .....
if(user != null) {
  String name = user.getUsername();
  if(name != null) {
    return name.toUpperCase();
  } else {
    return null;
  }
} else {
  return null;
}</pre>
<br/>
针对这方面 Groovy 提供了一种安全的属性/方法访问操作符 <code>?.</code><br/><br/>
<pre class="brush:groovy ">user?.getUsername()?.toUpperCase();</pre>
<br/>
Swift 也有类似的语法, 只作用在  Optional 的类型上.<br/><br/>
用了 <code>isPresent()</code> 处理 NullPointerException 不叫优雅, 有了  orElse, orElseGet 等, 特别是 <code>map</code> 方法才叫优雅.<br/><br/>
其他几个, <code>filter()</code> 把不符合条件的值变为 <code>empty()</code>,  <code>flatMap()</code> 总是与 <code>map()</code> 方法成对的,  <code>orElseThrow()</code> 在有值时直接返回, 无值时抛出想要的异常.<br/><br/>
<span style="color: #0000ff; font-size: 12pt;">一句话小结: 使用 <code>Optional</code> 时尽量不直接调用 <code>Optional.get()</code> 方法, <code>Optional.isPresent()</code> 更应该被视为一个私有方法, 应依赖于其他像 <code>Optional.orElse()</code>, <code>Optional.orElseGet()</code>, <code>Optional.map()</code> 等这样的方法.</span><br/><br/>
最后, 最好的理解 Java 8 Optional 的方法莫过于看它的源代码<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/Optional.java"> java.util.Optional</a>, 阅读了源代码才能真真正正的让你解释起来最有底气, Optional 的方法中基本都是内部调用  <code>isPresent()</code> 判断, 真时处理值, 假时什么也不做.<br/><br/>
参考链接:<br/><br/>
<ol>
    <li><a href="http://blog.jhades.org/java-8-how-to-use-optional/">Java 8 Optional: How to Use it</a></li>
    <li><a href="http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html">Tired of Null Pointer Exceptions? Consider Using Java SE 8's Optional!</a></li>
</ol>
