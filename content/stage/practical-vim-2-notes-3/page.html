---
title: 《Practical Vim》阅读笔记 (3)
url: /practical-vim-2-notes-3/
date: 2017-05-09T00:49:04-05:00
featured: false
draft: true
type: post
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/http://unmi.cc/wp-content/uploads/2017/01/vim-logo-en.png"
categories:
  - Vim
  - ReadingNotes
tags: 
  - vim
comment: true
codeMaxLines: 50
# additional
wpPostId: 7819 
wpStatus: publish
views: 295
lastmod: 2017-05-11T00:47:06-05:00
---

<p>1. 学习完前面的三大模式：正常模式，插入模式和可视模式后，现在步入了命令模式。<code>:</code>, <code>/</code> 或 <code>?</code>, 和 <code>&lt;C-r&gt;=</code> 分别进入到 <code>Ex</code> 命令，搜索和表达式，它们都被称作命令模式, 以前还常常把正常模式说成是命令模式。<code>:</code> 后的是 <code>Ex</code> 命令，是因为我们仍然沿袭了 Vim 的前身 Ex。我在 Mac 下输入命令 <code>ex</code> 就会看到这个</p>

<p><img class="aligncenter size-full wp-image-7821" src="http://unmi.cc/wp-content/uploads/2017/02/Ex-mode.png" alt="" width="536" height="95" /></p>

<p>进入到 Vim 的 Ex mode, 输入 <code>visual</code> 命令就是正常的 Vim 界面。Vim 之于 Ex 就像 Gui 之于 Shell, Vim 的 Ex 命令可以做任何操作，见 <code>:h ex-cmd-index</code>。</p>

<p>2. 命令模式在 <code>:</code> 提示符下输入时可以使用插入模式下的很多命令，如 <code>&lt;C-w&gt;</code>, <code>&lt;C-u&gt;</code>, <code>&lt;C-k&gt;</code>, <code>&lt;C-v&gt;</code>, <code>&lt;C-r&gt;{reg}</code>, 甚至是 <code>&lt;C-r&gt;=</code>，就是不能用 motion 命令，光标移得靠方向键</p>

<p>3. 在阅读本章之前对 Vi 的命令模式只能用不觉明厉来形容，它对我的贡献仅仅是 <code>:wq</code> 之类的，模式查找，简单替换，再就是执行一些未设置快捷键插件功能。也一直未理解替换怎么是 <code>%s/abc/dev</code>, 只是依葫芦画瓢，现在终于可以在本章中理解那些命令了。从中真的能体会到 Ex 命令模式的乐趣，Ex 是不会把整个文件内容显示在屏幕上的, Ex 命令通常由 范围 + 命令 组成。</p>

<blockquote><br/>
<p>:2           -- 光标跳到第一行，正常模式下可以 2G, 或 2gg<br /><br/>
 :print    -- 打印当前行的内容</p>

</blockquote>

<p>范围和命令一般会写在一块，范围可借用同样意义的特殊字符，默认操作当前行，因此下面一系列的命令就好理解了<!--more--></p>

<ul><br/>
	<li><code>:$p</code>: 打印最后一行, 与 <code>.,$p</code>, 或 <code>,$p</code> 相同。因为 Ex 是行编辑，所以 <code>$</code> 不再是当前行最后一列的意思。</li>

	<li><code>:2,5p</code>: 打印第 2 至第 5 行的内容，如果是从当前行算起可以用 <code>.,5p</code>, 或 <code>,5p</code></li>

	<li><code>:%d</code>: 删除全文，等效于用 <code>ggdG</code></li>

	<li><code>%j</code>: 把全文连成一行， <code>%</code> 代表文件全部行, <code>j</code> 是 <code>join</code> 命令，也就是正常模式下的 <code>J</code> 命令</li>

	<li><code>:%s/abc/def</code>: 终于理解了这个操作了，这里的 <code>%</code> 代表全部行，所以是替换<strong>每行第一次出现</strong>的 abc 为 def, 需要全局替换就是 <code>:%s/abc/def/g</code>, <code>s</code> 是 <code>substitute</code> 命令的缩写</li>

	<li><code>:5m$</code>: 第 5 行内容移到最后，更多命令用 <code>:h ex-cmd-index</code> 查看</li>

</ul><br/>
<p>4. Vim 对选择区的范围在 Ex 命令中的表示是 <code>'&lt;,'&gt;</code>, 从选择区的开始 <code>'&lt;</code> 到(<code>,</code>) 选择区的结束 <code>'&gt;</code>, 对该区域的操作就是 <code>'&lt;,'&gt;p</code>. 在选择模式下选择后键入 <code>:</code> 就能看到</p>

<p>5. 用模式匹配来指定范围，如 <code>:/&lt;html&gt;/,&lt;\/html&gt;/p</code></p>

<p>6. 位置偏移，如 :/<code>&lt;html&gt;/+1,&lt;\/html&gt;-1p</code>, html 标签内部的内容, <code>:.,.+3p</code> 输出当前后往下数三行，或者是 <code>:,.+3p</code>, <code>:,+3p</code>. <code>+3p</code> 只会打印出往下的第三行(一行)的内容</p>

<p>7. 进入命令模式的方式：1）正常模式下，<code>:</code>, 插入模式下可以 <code>&lt;C-o&gt;:</code>, 选择模式下直接按 <code>:</code>. 当前插入模式到正常模式切换可用 <code>Esc</code> 或 <code>&lt;C-[</code></p>

<p>8. 正常模式可做与命令模式一样的事情，如 <code>:6t.</code>, 从第六行拷贝一行到当前行下，正常模式下必须移光标到第六行 <code>yy</code>, 再移下当前行 <code>p</code>, 所以选择命令模式还是正常模式是命令模式近距离，命令模式可远距离操作。命令模式这个操作还不会覆盖寄存器的内容。</p>

<p>9. Ex 命令配上正常模式下的命令就更无敌了。如 <code>A;&lt;Esc&gt;</code> 后 <code>:'&lt;,'&gt;normal .</code>  就能在选择的多行上重复末尾加分号。 <code>:%normal A;</code> 更简单的所有行后加分号; <code>:2,4normal i//</code> 用 // 注释掉从第 2 到第 4 行。Ex 命令一次性作用多行，与 normal 下的命令一结合就起化学反应了。<code>normal</code> 可以简写为 <code>norm</code>, 如 <code>:%norm A;</code>。</p>

<p>10. 正常模式上次修改的重复用 <code>.</code>, 而对 Ex 命令的重复操作是用 <code>@:</code>, 如果执行过一次 <code>@:</code>, 那就可以不断的按 <code>@@</code> 来重复放到 <code>:</code> 寄存器中的 Ex 命令了。同时 <code>@@</code> 的每次执行指令都会丢到  Jump List 中，这时按 <code>&lt;C-o&gt;</code> 会反着执行 Jump List 中的指令。可以在有多个 buffer 时试下 <code>:bnext</code>, <code>@:</code>, <code>@@</code>, <code>@@</code>, <code>&lt;C-o&gt;</code>, <code>&lt;C-o</code></p>

<p>11. Ex 命令的自动完成, <code>&lt;Tab&gt;</code> 单行列出可选项，并可用 <code>&lt;Tab&gt;</code> 或 <code>&lt;S-Tab&gt;</code> 往前往后的选择。新玩艺是 <code>&lt;C-d&gt;</code>, 例如输入 <code>:b&lt;C-d&gt;</code> 会多行列出所有的以 <code>b</code> 开头的 Ex 命令。不妨对比下 <code>:b&lt;Tab&gt;</code>, 或 <code>:colorscheme &lt;C-d&gt;</code> 和 <code>:colorscheme&lt;Tab&gt;</code></p>

<p>12. 在输入 Ex 命令时可以按 <code>&lt;C-r&gt;&lt;C-w</code> 提取缓冲区光标所在单词到命令输入窗口中。例如当前光标在单 hello 上，输入 <code>:%s/abc/&lt;C-r&gt;&lt;C-w&gt;</code> 就会变成 <code>%s/abc/hello</code>, 继续完成该 Ex 命令，<code>&lt;C-r&gt;&lt;C-a&gt;</code> 也类似，但有小区别</p>

<p>13. 一次可以同时执行多个 Ex 命令，用管道符分开, <code>:write | !ruby %</code>. <code>q:</code> 可以打开命令行窗口，在其中可以以 Vim 的方式编辑历史命令，<code>&lt;CR&gt;</code> 会执行命令行窗口中当前行的 Ex 命令，并且作用在打开命令行窗口前的编辑窗口。<code>q:</code> 或 <code>&lt;CR&gt;</code> 退出命令行窗口</p>

<p>14. 在输入 Ex 命令时可以按 <code>&lt;C-f&gt;</code> 切换到命令行窗口对当前命令进行编辑，完后 <code>&lt;CR&gt;</code> 执行。因为搜索有自己的历史，所以相应的 <code>q/</code> 可以打开搜索历史的命令行窗口。</p>

<p>15. Ex 中执行 Shell 命令，Shell 命令前加一个感叹号，如 <code>:!ls</code> 执行完回车返回到 Vim. Ex 命令中 <code>%</code> 代表当前文件名，可以这么用 <code>:!ruby %</code>, <code>:!echo %</code> 可以看到输出的当前文件名。如果想一次运行多个 Shell 命令，那就 <code>:shell</code> 进入交互界面，其实它没什么特别的，用个 <code>:!bash</code> 也行，用 <code>exit</code> 退回。还有一个等效的操作是：在 Vim 中按 <code>&lt;C-z&gt;</code> 把 Vim 送到后台(jobs 命令可以列出它), 执行完 shell 命令后，再用 <code>fg</code> 命令再回到刚才 Vim 界面</p>

<p>16. 用缓冲区的内容作为 shell 命令的标准输入与输出。 <code>:read !{cmd}</code> 缓冲区为 shell 命令的标准输出; <code>:write !{cmd}</code> 缓冲区(或选择区) 为 shell 命令的标准输入，每一行触发一次执行。</p>

<p>17. 外部命令过滤缓冲区内容，外部命令逐行读入并替换掉选择区内容即完成了 map 操作，例如 <code>%!sort</code> 对缓冲区按行排序，可以尝试像 cut, awk, sed 这样的命令。<code>!{motion}</code> 可以便捷的选择区域并附加上感叹号，如正常模式下 <span style="color: #666666; font-family: monospace;"><span style="background-color: #fafafa;"><code>!G</code> 就会在 Ex 命令输入中变成 <code>:.,$!</code> 等待后续输入</span></span></p>

<p>18. Vim 还允许像批处理一样把 Ex 命令逐行写在一个外部文件中，然后在 Vim 中用  <code>:source batch.vim</code> 来执行其中定义的一系列 Ex 命令。注意：写在 batch.vim 中的 Ex 命令不用前导的 <code>:</code>, 并且推荐用全命令名，以增强可读性。如</p>

<blockquote><br/>
<p>global/href/join<br /><br/>
 vglobal/href/delete<br /><br/>
 %normal yi"$p</p>

</blockquote>

<p>可以手工对每个打开的文件执行上面的批命令, <code>:args</code>, <code>:first</code>, <code>:source batch.vim</code>, <code>:next</code>, <code>:source batch.vim</code>; 也可以用 <code>:argdo</code> 一次性对所有的 buffer 执行批命令，<code>:argdo source batch.vim</code></p>
