---
title: Python logging 使用笔记
url: /python-logging-usages/
date: 2024-10-16T16:49:58-05:00
featured: false
draft: false
type: post
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/http://unmi.cc/wp-content/uploads/2016/06/python-icon-200x200.png"
categories:
  - Python
tags: 
  - Python
  - logging
comment: true
codeMaxLines: 50
# additional
wpPostId: 13775 
wpStatus: publish
views: 160
lastmod: 2024-10-21T10:26:06-05:00
---

使用 Python 的话用不着像 Java 那样是考虑用 Logback  还是 Log4J 的问题，因为它内置提供了完备功能的 logging 库。虽然 JDK  也有 java.util.logging(JUL), 它的特性其实也不差，如日志级别，输出格式，不同的输出目的地的选择，但在 Logback 和 Log4J 的光环之下几乎无人问津。相比而言 Python 的 logging 却极为受宠，非必要时基本不会去考虑引入第三方的日志库，如 <a href="https://github.com/Delgan/loguru">Loguru</a>, <a href="https://github.com/getlogbook/logbook">LogBook</a>, <a href="https://github.com/hynek/structlog">Structlog</a>, <a href="https://github.com/microsoft/picologging">Picologging</a>, 尽管它们也很出色，毕竟是庶出。</p>
<br/>
<h3>logging 的最基本用法</h3><br/><br/>
在基本前面加是<code>最</code> 字，是因为这一节仅仅是如何让 logging 作为 print() 的替代品，暂不涉及到参数的传递，异常的输出，以及格式定制，日志往哪里输出的问题。<br/><br/>
<pre class="lang:default decode:true ">import logging<br/><br/>
logging.info("hello")</pre>
<br/>
运行，什么也看不到，因为 Python logging 的默认级别是 warning, 这不符合人的基本认知，一般 logging.info() 起码是用来替代 print() 的，居然直接用无法输出，不知该库的设计者是怎么个想法。<!--more--><br/><br/>
如果用<br/><br/>
<pre class="lang:default decode:true ">logging.warning("hello")</pre>
<br/>
输出便是<br/><br/>
<blockquote>
WARNING:root:hello
</blockquote>
<br/>
但谁会突兀的用 logging.warning() 代替 print 呢？所以还是需要配置 logging 的默认级别为 INFO。在设置 LogLevel 之前先查看一下它的默认级别，用代码<br/><br/>
<pre class="lang:default decode:true ">print(logging.root.level)
print(logging.getLevelNamesMapping())
</pre>
<br/>
将会看到<br/><br/>
<blockquote>
30<br />
{'CRITICAL': 50, 'FATAL': 50, 'ERROR': 40, 'WARN': 30, 'WARNING': 30, 'INFO': 20, 'DEBUG': 10, 'NOTSET': 0}
</blockquote>
<br/>
所以对应的 30 为 WARN<br/><br/>
<pre class="lang:default decode:true ">logging.root.setLevel(logging.INFO)
logging.info("hello")</pre>
<br/>
现在有了<br/><br/>
<blockquote>
INFO:root:hello
</blockquote>
<br/>
到目前为止我们一直专注到 root logger, 像 Java 的 Logback 和 Log4J 一样，对 root 的 LogLevel 设置会自动应用到其他的 logger, 但前提是 root logger 有过一次日志输出调用<br/><br/>
<pre class="lang:default decode:true">logging.root.setLevel(logging.INFO)
logging.info("hello")           # 注释掉该行将看不到 hello again 输出<br/><br/>
log_abc = logging.getLogger("abc")
log_abc.info("hello again")
</pre>
<br/>
输出为<br/><br/>
<blockquote>
INFO:root:hello<br />
INFO:abc:hello again
</blockquote>
<br/>
要是把第二行的 <code>logging.info("hello")</code> 注释掉的话，就没有 <code>hello again</code> 了，原因是在第一次 <code>logging.xxx("hello")</code> 调用时会进行 basicConfig 的配置<br/><br/>
<pre class="lang:default decode:true">def info(msg, *args, **kwargs):
    if len(root.handlers) == 0:
        basicConfig()
    root.info(msg, *args, **kwargs)</pre>
<br/>
因此更为主动配置 root 及其他所有 logger 的输出级别的做法是直接用 basicConfig()<br/><br/>
<pre class="lang:default decode:true ">logging.basicConfig(level=logging.INFO)<br/><br/>
log_abc = logging.getLogger("abc")
log_abc.info("hello again")
</pre>
<br/>
这样所有的 logger 就有了 INFO 级别了，上面的输出为<br/><br/>
<blockquote>
INFO:abc:hello again
</blockquote>
<br/>
Python logging 默认的日志输出格式是<br/><br/>
<blockquote>
'%(levelname)s:%(name)s:%(message)s'
</blockquote>
<br/>
<h3>Python logging 中的 logger</h3><br/><br/>
Python 有一个开箱即用的 logger 实例，即 logging, 如果不想要申明别的 logger 的话，完全可以用 logging.info(), logging.error() 一撸到底，通过 LogFormat 在日志在输出所在的模块, 方法, 代码行等信息。<br/><br/>
当然也可以像 Java 那样为每个包和模块创建自己的 logger 实例， 通常做法是<br/><br/>
<pre class="lang:default decode:true ">logger = logging.getLogger(__name__)</pre>
<br/>
__name__ 包含了包名和模块名，比如上面代码声明在 xxx/yyy/zzz.py 中，则创建的 logger 名为 xxx.yyy.zzz，如果 logging.getLogger(__name__) 声明在 xxx/yyy/__init__.py 文件中的话，创建的 logger 名为 xxx.yyy。和 Logback 和 Log4J 一样，<code>xxx.yyy.zzz</code> 的 logger名实际构建出了 logger 之间的父子关系，如<br/><br/>
logging.getLogger("xxx.yyy.zzz") 和  logging.getLogger("xxx.yyy.kkk") 是 logging.getLogger("xxx.yyy")  的 children.<br/><br/>
<pre class="lang:default decode:true">logger_p = logging.getLogger('xxx.yyy')
logger_p.setLevel(logging.DEBUG)<br/><br/>
logger_c1 = logging.getLogger('xxx.yyy.zzz')
logger_c2 = logging.getLogger('xxx.yyy.kkk')<br/><br/>
print(logger_p.getChildren())
print(logging.getLogger("xxx"))</pre>
<br/>
输出为<br/><br/>
<blockquote>
{&lt;Logger xxx.yyy.zzz (DEBUG)&gt;, &lt;Logger xxx.yyy.kkk (DEBUG)&gt;}<br />
&lt;Logger xxx (WARNING)&gt;
</blockquote>
<br/>
并且父 logger 的配置会影响到其所有子 logger<br/><br/>
<h3>logging 的参数与异常输出</h3><br/><br/>
logger 的日志输出方法有 debug(), info(), warning(), error(), fatal() 和 critical(), 还有 exception(), 从日志级别来讲 fatal() 和  critical() 是在一个级别，即 50。它们的方法原型都是一样的，以 info() 为例<br/><br/>
<pre class="lang:default decode:true ">def info(self, msg, *args, **kwargs):</pre>
<br/>
如果在 IntelliJ IDEA 或 PyCharm 中自动提示时把其中的 **kwargs 可能支持值更明确化<br/><br/>
<pre class="lang:default decode:true ">logging.info(msg, args, exc_info, stack_info, stacklevel, extra)</pre>
<br/>
实际上是无论 info(), warning() 等方法都会来到 logging.__init__.py 中的<br/><br/>
<pre class="lang:default decode:true">def _log(self, level, msg, args, exc_info=None, extra=None, stack_info=False, stacklevel=1):</pre>
<br/>
msg 和 args 是调用 msg % args 来格式化消息<br/><br/>
<pre class="lang:default decode:true">logging.info("%s says hello to %s", "aa", "bb")</pre>
<br/>
<blockquote>
INFO:root:aa says hello to bb
</blockquote>
<br/>
所以 msg 中的 % 点位符与所提供的参数数量不符都会看到类似下面的错误<br/><br/>
太少<br/><br/>
<blockquote>
    msg = msg % self.args<br />
              ~~~~^~~~~~~~~~~<br />
TypeError: not enough arguments for format string
</blockquote>
<br/>
太多<br/><br/>
<blockquote>
msg = msg % self.args<br />
          ~~~~^~~~~~~~~~~<br />
TypeError: not all arguments converted during string formatting
</blockquote>
<br/>
&nbsp;<br/><br/>
<h4>输出异常信息</h4><br/><br/>
<pre class="lang:default decode:true">try:
    raise Exception("something wrong")
except Exception as ex:
    logging.error("got error due to %s", str(ex))</pre>
<br/>
输出为<br/><br/>
<blockquote>
ERROR:root:got error due to something wrong
</blockquote>
<br/>
Python 的 logging 可不能像 Logback 和 Log4J 那样在最后位置上放上 ex 本身就会输出异常栈信息，在 Python 中 logging.error("error", ex) 会报错的。<br/><br/>
正确的做法是用 exc_info=True 或 stack_info=True 参数<br/><br/>
<pre class="lang:default decode:true">logging.error("got error due to %s", str(ex), exc_info=True)</pre>
<br/>
输出为<br/><br/>
<pre class="lang:default decode:true ">ERROR:root:got error due to something wrong
Traceback (most recent call last):
  File "/opt/project/test.py", line 6, in &lt;module&gt;
    raise Exception("something wrong")
Exception: something wrong</pre>
<br/>
同时加上 stack_info=True<br/><br/>
<pre class="lang:default decode:true ">logging.error("got error due to %s", str(ex), exc_info=True, stack_info=True)</pre>
<br/>
后的输出为<br/><br/>
<pre class="lang:default decode:true">ERROR:root:got error due to something wrong
Traceback (most recent call last):
  File "/opt/project/test.py", line 6, in &lt;module&gt;
    raise Exception("something wrong")
Exception: something wrong
Stack (most recent call last):
  File "/opt/project/test.py", line 8, in &lt;module&gt;
    logging.error("got error due to %s", str(ex), exc_info=True, stack_info=True)</pre>
<br/>
或者用 exception() 方法替代直接 error() 方法，exception() 方法的实现是<br/><br/>
<pre class="lang:default decode:true">def exception(self, msg, *args, exc_info=True, **kwargs):
   self.error(msg, *args, exc_info=exc_info, **kwargs)</pre>
<br/>
exception() 就是 exc_info=True 的 error() 方法。<br/><br/>
<h3>stacklevel 参数的功效</h3><br/><br/>
stacklevel 默认为 1，即输出调用 logging 方法的当前代码处的信息(即当前桢)，这其实是回溯的，stacklevel=1 即为栈底，stacklevel=2 则往顶上一层，感觉保持默认的 stacklevel=1 就足够了。为了演示 stacklevel 的效果，需要配置一下日志的输出格式，让其初输出包，模块，函数及代码行的信息<br/><br/>
<pre class="lang:default decode:true">import logging<br/><br/>
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s  %(module)s - %(funcName)s:%(lineno)d - %(message)s")<br/><br/>
def foo():
    bar()<br/><br/>

def bar():
   logging.info("hello", stacklevel=1)<br/><br/>
if __name__ == '__main__':
    foo()
</pre>
<br/>
上面的代码输出为<br/><br/>
<blockquote>
2024-10-16 19:38:26,460 - INFO test - bar:12 - hello
</blockquote>
<br/>
即调用 logging.info("hello", stacklevel=1) 处的信息，如果把 stacklevel 调整为 2 (stacklevel=2)，输出则变为<br/><br/>
<blockquote>
2024-10-16 19:39:48,881 - INFO test - foo:8 - hello
</blockquote>
<br/>
即 <code>%(module)s - %(funcName)s:%(lineno)d</code> 全部回到了上一层 foo() 的调用处，其实意义不大。如果再往，比如设置一个很大的值，像 stacklevel=20，不回有错，再大也是在最顶层，输出信息就是<br/><br/>
<blockquote>
2024-10-16 19:41:04,182 - INFO test - &lt;module&gt;:15 - hello
</blockquote>
<br/>
<h3>logger 方法的 extra 参数</h3><br/><br/>
logging.info(extra: dict) 的 extra 参数是用来补充在日志格式中自定义的字段或覆盖 <a href="https://docs.python.org/3/library/logging.html#logrecord-attributes">LogRecord attributes</a> 中预定义的字段值，但覆盖 <code>asctime</code> 和 <code>message</code> 是不被允许的。从下面的例子中可以很轻松的理解<br/><br/>
<pre class="lang:default decode:true ">logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(request_id)s %(user_id)s - %(message)s")<br/><br/>
if __name__ == '__main__':
    request_id= 'xx-yy-zz'
    user_id = '001'
    logging.info("hello extra example", extra={'request_id': f'{request_id=}', 'user_id': f'{user_id=}'})</pre>
<br/>
输出为<br/><br/>
<blockquote>
2024-10-16 19:54:44,345 request_id='xx-yy-zz' user_id='001' - hello extra example
</blockquote>
<br/>
这很方便我们在 format 中自定义字段，但问题是在每次 logging.info() 等方法中都必须提供自定义字段的值，否则在最后格式化日志消息是会报错。<br/><br/>
<h3>Python logging 的扩展点</h3><br/><br/>
说到 Python logging 的扩展点，不得不回到  basicConfig() 方法调用<br/><br/>
在使用 basicConfig() 方法时留意到它可不止是用到配置 level 的，它几乎是 Python logging 的精髓所在<br/><br/>
<a href="https://yanbin.blog/wp-content/uploads/2024/10/python-logging-basicConfig.png"><img class="aligncenter wp-image-13776" src="https://yanbin.blog/wp-content/uploads/2024/10/python-logging-basicConfig-800x53.png" alt="" width="850" height="56" /></a><br/><br/>
参数的简单讲解<br/><br/>
<ol>
    <li>filename, filemode, encoding, errors: 日志文件名和打开文件的模式(默认为 a) 和文件编码, 指定了 filename 的话日志只输出到文件。没有 handlers 参数则由 filename 决定是创建 FileHandler(filename, filemode, encoding, errors) 还是 StreamHandler(stream|none)</li>
    <li>format: 日志输出格式，预定义字段请参考 <a href="https://docs.python.org/3/library/logging.html#logrecord-attributes">LogRecord attributes</a></li>
    <li>datefmt: 默认时间格式为 '%Y-%m-%d %H:%M:%S'</li>
    <li>style: 可选值为 "%", "{", 和 "$", 它决定了在 format 中是用 <code>%(name)s</code>, <code>${name}</code>, 还是 <code>{name}</code>, 与 logger.info("hello %s", "Pythong") 中的 "%s" 无关</li>
    <li>stream: 未指定 handlers  将使用 stream 创建 StreamHandle(stream) 作为唯一的 handler</li>
    <li>handlers, force: 如果指定了值，则将忽略 filename, stream, 直接用该 handlers，force=True/False, 决定是否先把 root logger 中已有的 handlers 清空并关闭，然后添加参数 handlers 中的 handler 到 root 的 handlers 列表。force 默认为 False, force 用于擦除系统已注册的 handler 还是挺有用，比如给 Python AWS Lambda 重新配置 handler</li>
</ol>
<br/>
Python logging 的主要的扩展类是 Filter, Handler, 以及 Format 中的自定义字段，它们与 Logger 的关系交织在一起，例如<br/><br/>
<pre class="lang:default decode:true">logger.addFilter(filter)
logger.addHandler(handler)
    
logger.handlers[0].addFilter(filter)
logger.handlers[1].setFormatter(formatter)
</pre>
<br/>
filter 既可以关联到 logger 也可以关联到 handler, formatter 配置在 handler 上的，handler 是与 logger 相关联的. filter 处理的是 LogRecord, 除此之外还有 LoggerAdapter 类。<br/><br/>
而最终 logger.addFilter(filter) 也会把 filter 添加到相关联 handler 上去。Python logging 起决定性的作用是 Handler, 一个 logger 可以对应一或多个 Handler 决定以什么格式向哪里输出，每个  Handler 有 filter 来处理 LogRecord<br/><br/>
logger, handler, format, filter 之间的关系大概是下图的样子<br/><br/>
<a href="https://yanbin.blog/wp-content/uploads/2024/10/python-logging-handler-filter.png"><img class="aligncenter wp-image-13781 size-full" src="https://yanbin.blog/wp-content/uploads/2024/10/python-logging-handler-filter.png" alt="" width="490" height="233" /></a><br/><br/>
除了 logging.basicConfig()，还有 logging.config 中的另外两个配置函数, 方法原型如下<br/><br/>
<pre class="lang:default decode:true">import logging.config<br/><br/>
logging.config.fileConfig(fname:str|bytes|PathLike[str]|IO[str]|RawConfigParser, defaults, disable_existing_loggers, encoding)
logging.config.dictConfig(config: _DictConfigArgs | dict[str, Any])</pre>
<br/>
<h4>fileConfig()</h4><br/><br/>
fileConfig() 需要是一个能被 Python 的 configparser 解析的类似于 Windows INI 文件格式. 下面是一个 fileConfig 例子，文件名为 logconfig.ini<br/><br/>
<pre class="lang:default decode:true">[loggers]
keys=root,sampleLogger<br/><br/>
[handlers]
keys=consoleHandler,fileHandler<br/><br/>
[formatters]
keys=simpleFormatter,detailedFormatter<br/><br/>
[logger_root]
level=INFO
handlers=consoleHandler<br/><br/>
[logger_sampleLogger]
level=DEBUG
handlers=fileHandler
qualname=sampleLogger
propagate=0<br/><br/>
[handler_consoleHandler]
class=StreamHandler
level=INFO
formatter=simpleFormatter
args=(sys.stdout,)<br/><br/>
[handler_fileHandler]
class=FileHandler
level=DEBUG
formatter=detailedFormatter
args=('sample.log', 'a')<br/><br/>
[formatter_simpleFormatter]
format=%(asctime)s - %(name)s - %(levelname)s - %(message)s<br/><br/>
[formatter_detailedFormatter]
format=%(asctime)s - %(name)s - %(levelname)s - %(message)s - %(pathname)s:%(lineno)d</pre>
<br/>
Python 代码<br/><br/>
<pre class="lang:default decode:true ">import logging
import logging.config
logging.config.fileConfig("logconfig.ini")<br/><br/>
logging.info("hello console")
logging.getLogger("sampleLogger").info("hello file")</pre>
<br/>
在控制台输出为<br/><br/>
<blockquote>
2024-10-16 21:10:42,318 - root - INFO - hello console
</blockquote>
<br/>
在 sample.log 文件中的输出为<br/><br/>
<blockquote>
2024-10-16 21:10:42,319 - sampleLogger - INFO - hello file - /opt/project/test.py:11
</blockquote>
<br/>
logger.config.configDict() 的方式这里不细说，Python 的 logging 不同于 Java 的  Logback/Log4J, 个人感觉用 Python 代码的配置方式似乎要优于 fileConfig() 和  configDict() 的配置方式，更易于理解与排错。<br/><br/>
<h3>一个相当于 Java 的 MDC 实现</h3><br/><br/>
MDC 类<br/><br/>
<pre class="lang:default decode:true">import logging
import threading<br/><br/>
class MDC(logging.Filter):<br/><br/>
    def __init__(self):
        super().__init__()
        self.thread_local = threading.local()
        self.thread_local.mdc = {}<br/><br/>
    def request_id(self, request_id):
        self.set('request_id', request_id)
        return self<br/><br/>
    def user_id(self, user_id):
        self.set('user_id', user_id)
        return self<br/><br/>
    def clear(self, key):
        if key in self.thread_local.mdc:
            del self.thread_local[key]<br/><br/>
    def set(self, key, value):
        self.thread_local.mdc[key] = value<br/><br/>
    def get_xfields_string(self):
        return " ".join([f'{key}={value}' for (key, value) in self.thread_local.mdc.items()])<br/><br/>
    def filter(self, record):
        record.xfields = self.get_xfields_string()
        return True</pre>
<br/>
配置使用 MDC 类<br/><br/>
<pre class="lang:default decode:true">from logging import StreamHandler<br/><br/>
mdc = MDC()
handler = StreamHandler(None)
handler.addFilter(mdc)<br/><br/>
logging.basicConfig(
    level=logging.INFO,
    format= '%(asctime)s - %(levelname)s - %(module)s - %(funcName)s:%(lineno)d - %(xfields)s message="%(message)s"',
    handlers=[handler],
    force=True
)<br/><br/>
mdc.request_id("xxx-yyy-zzz").user_id('yanbin')
logging.info("hello")<br/><br/>
mdc.request_id("aaa-bbb-ccc")
mdc.set("app_name", "demo")
logging.getLogger("abc").info("hello")</pre>
<br/>
输出为<br/><br/>
<blockquote>
2024-10-16 21:47:23,429 - INFO - test - &lt;module&gt;:48 - request_id=xxx-yyy-zzz user_id=yanbin message="hello"<br />
2024-10-16 21:47:23,431 - INFO - test - &lt;module&gt;:52 - request_id=aaa-bbb-ccc user_id=yanbin app_name=demo message="hello"
</blockquote>
<br/>
最后，也没什么好总结的，就一篇关于 Python logging 的使用笔记，自然有些杂乱无章，方便日后重新翻出来参考。<br/><br/>
<h3>2024-10-21 补充一个 ContextVar 版本的 MDC 实现</h3><br/><br/>
<pre class="lang:default decode:true ">import logging
from contextvars import ContextVar<br/><br/>
class MDC(logging.Filter):<br/><br/>
    def __init__(self):
        super().__init__()
        self.mdc = ContextVar("MDC")
        self.mdc.set({})<br/><br/>
    def request_id(self, request_id):
        self.set('request_id', request_id)
        return self<br/><br/>
    def user_id(self, user_id):
        self.set('user_id', user_id)
        return self<br/><br/>
    def clear(self, key):
        if key in self.mdc.get():
            del self.mdc.get()[key]<br/><br/>
    def set(self, key, value):
        self.mdc.get()[key] = value<br/><br/>
    def get_xfields_string(self):
        return " ".join([f'{key}={value}' for (key, value) in self.mdc.get().items()])<br/><br/>
    def filter(self, record):
        record.xfields = self.get_xfields_string()
        return True</pre>
<br/>
不仅适用于多线程环境也能用于 asyncio 中。
