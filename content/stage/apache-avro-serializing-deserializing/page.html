---
title: Apache Avro 序列化与反序列化 (Java 实现)
url: /apache-avro-serializing-deserializing/
date: 2016-10-15T16:54:28-05:00
featured: false
draft: true
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/http://unmi.cc/wp-content/uploads/2016/10/apache-avro.png"
categories:
  - Java/JEE
tags: 
  - Avro
comment: true
codeMaxLines: 50
# additional
wpPostId: 7488 
wpStatus: publish
views: 4416
lastmod: 2021-09-03T17:06:33-05:00
---

像两个人交流一样要找一个互相能理解的语言, 在国内为普通话, 跑国外多用英语相通, 两个进程间通信也需要找一个大家都能理解的数据格式. 简单的如 JSON, XML, 那是自我描述性格式, XML 有 Schema 定义, 但尚无正式的 <a href="http://json-schema.org/">JSON Schema</a> 规范. 在讲求效率的场合, 纯文本式的数据交换格式无法满足要求, 于是有二进制的 Google Protobuf 和 Apache Avro. 在 Apache 的生态像 Hadoop, Kafka 中自然是选用 Avro.<br/><br/>
Avro 支持多种语言, 如 C, C++, C#, Java, PHP, Python 和 Ruby. 它使用 JSON 来定义 Schema, 通过工具可以由 Schema 生成相应语言的数据对象, 比如 Java 的  avro-tools.jar. 这样可以在跨进程跨语言透明的实现为对象交换.<br/><br/>
本文体验 Java 环境中 Avro 数据格式的序列化与反序列化.<br/><br/>
Avro Schema 文件就是数据生产和消费端的通信协议; 我们可以由 Schema 生成相应的 Java 对象, 然后以具体的 Java 对象交换, 或者不生成 Java 对象而纯粹以 <code>GenericRecord</code> 交互. 为操作数据的简单, 我们通常采用前一种方式, 即生成具体数据传输对象.<!--more--><br/><br/>
<h2>首先定义一个 Schema</h2><br/><br/>
<pre class="lang:default decode:true">{
  "namespace": "cc.unmi.data",
  "type": "record",
  "name": "User",
  "fields": [
    {"name": "name", "type": "string"},
    {"name": "address", "type": ["string", "null"]}
  ]
}</pre>
<br/>
对于 Schema 不多加说明, 这里只定义了一个 User 对象, 有两个属性 name 和  address. Schema 的详细解释可打开 <a href="http://avro.apache.org/docs/1.8.1/spec.html">http://avro.apache.org/docs/1.8.1/spec.html</a>.<br/><br/>
假设文件名为 <code>user.avsc</code>, <code>avsc</code> 应该是 <code>Avro</code> Schema 文件, 我至今都未查到 <code>Avro</code> 是什么的缩写.<br/><br/>
<h2>由 Schema 生成 Java 对象</h2><br/><br/>
我们需要用到 <code>avro-tools-1.x.x.jar</code> 工具包, 当前版本是 1.8.1, 命令格式是<br/><br/>
<blockquote>
<span style="color: #800000;">java -jar /path/to/avro-tools-1.8.1.jar compile schema user.avsc .</span>
</blockquote>
<br/>
上面命令会在当前目录生成 <code>cc/unmi/data/User.java</code> 文件. 下面的例子会使用 <code>org.apache.avro:avro-maven-plugin</code> 来从 Schema 生成 Java 对象.<br/><br/>
可以大致看一下生成的 <a href="https://github.com/yabqiu/apache-avro-demo/blob/master/src/main/java/cc/unmi/data/User.java">User.java</a> 的片断<br/><br/>
<pre class="lang:default decode:true">@org.apache.avro.specific.AvroGenerated
public class User extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  private static final long serialVersionUID = 3019453098083125873L;
  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"User\"....");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }
  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
............</pre>
<br/>
生成的对象中包含完整的 Schema 定义内容, 可由静态方法 <code>getClassSchema()</code> 和实例方法 <code>getSchema()</code> 获得相应的 Schema, 所以拥有了这个对象类通信时就不再需要 <code>user.avsc</code> 文件了. 在它的父类 <code>SpecificRecordBase</code> 类中定义了抽象方法 <code>getSchema()</code>.<br/><br/>
并且这个类提供了多种方式来创建一个实例<br/><br/>
<ol>
    <li>User user = new User(); user.setName("Yanbin")..., user.put(2, "Chicago")..., user.put("name", "Qiu")</li>
    <li>User user = new User("Yanbin", "Chicago")</li>
    <li>User user = User.newBuilder().setName("Yanbin").setAddress("Chicago").build()</li>
</ol>
<br/>
<h2>序列化</h2><br/><br/>
下面的代码把一个 User 对象序列化为字节数组, 也可以序列化为外部文件<br/><br/>
<pre class="lang:default decode:true">private static byte[] serializeUser(User user) throws IOException {
    DatumWriter&lt;User&gt; userDatumWriter = new SpecificDatumWriter&lt;&gt;(User.class);
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    BinaryEncoder binaryEncoder = EncoderFactory.get().directBinaryEncoder(outputStream, null);
    userDatumWriter.write(user, binaryEncoder);
    return outputStream.toByteArray();
}</pre>
<br/>
光有序列化代码无法验证序列化后的数据是否正确, 于是要有下面的反序列化代码<br/><br/>
<h2>反序列化</h2><br/><br/>
<pre class="lang:default decode:true">private static User deserializeUser(byte[] data) throws IOException {
    DatumReader&lt;User&gt; userDatumReader = new SpecificDatumReader&lt;&gt;(User.class);
    BinaryDecoder binaryEncoder = DecoderFactory.get().directBinaryDecoder(new ByteArrayInputStream(data), null);
    return userDatumReader.read(new User(), binaryEncoder);
}</pre>
<br/>
从上面方法输出的字节数组中反序列化出相等的对象来,  <code>userDatumReader.read(new User(), binaryEncoder)</code> 执行后的返回值与被更新后的第一个参数是一样的, 所以这个方法要是能写成 <code>reutnr userDatumReader.read(User.class, binaryEncoder);</code> 会好看些.<br/><br/>
有了上面的两个方法需要串联起来, 序列化的输出作为反序化的输出就能能证明两个操作是否正确<br/><br/>
<h2>验证序列化与反序列化</h2><br/><br/>
<pre class="lang:default decode:true">public static void main(String[] args) throws IOException {
    User originalUser =  new User("Yanbin", "Chicago");
    User deserializedUser = deserializeUser(serializeUser(originalUser));
    System.out.println("Same object? " + (deserializedUser == originalUser));
    System.out.println("Objects equal? " + (deserializedUser.equals(originalUser)));
    System.out.println("All fields: " + deserializedUser);
}</pre>
<br/>
执行输出结果如下<br/><br/>
<blockquote>
<span style="color: #800000;">Same object? false</span><br />
<span style="color: #800000;">Objects equal? true</span><br />
<span style="color: #800000;">All fields: {"name": "Yanbin", "address": "Chicago"}</span>
</blockquote>
<br/>
准确无误, 大功告成<br/><br/>
本例实作是一个 Maven  项目, <code>pom.xml</code> 文件内容如下:<br/><br/>
<pre class="lang:default decode:true ">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br/><br/>
    &lt;groupId&gt;cc.unmi&lt;/groupId&gt;
    &lt;artifactId&gt;avrodemo&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;<br/><br/>
    &lt;name&gt;Apache Avro Demo&lt;/name&gt;<br/><br/>
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.avro&lt;/groupId&gt;
            &lt;artifactId&gt;avro&lt;/artifactId&gt;
            &lt;version&gt;1.8.1&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;<br/><br/>
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.avro&lt;/groupId&gt;
                &lt;artifactId&gt;avro-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.8.1&lt;/version&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;phase&gt;generate-sources&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;schema&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;sourceDirectory&gt;${project.basedir}/src/main/avro/&lt;/sourceDirectory&gt;
                            &lt;outputDirectory&gt;${project.basedir}/src/main/java/&lt;/outputDirectory&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;</pre>
<br/>
由 <code>user.avsc</code> 生成 Java 对象是挂在 <code>generate-sources</code> 阶段执行的, 所以在 <code>mvn compile</code> 时会生成 <code>User.java</code> 文件.<br/><br/>
完整的项目文件在 GitHub 上 <a href="https://github.com/yabqiu/apache-avro-demo">https://github.com/yabqiu/apache-avro-demo</a>.<br/><br/>
相关链接:<br/><br/>
<ol>
    <li><a href="http://avro.apache.org/docs/1.8.1/gettingstartedjava.html">Apache Avro™ 1.8.1 Getting Started (Java)</a></li>
    <li><a href="http://blog.jqian.net/post/avro.html">Avro序列化方法</a></li>
    <li><a href="https://www.iteblog.com/archives/1008">Apache Avro使用入指南</a></li>
</ol>
