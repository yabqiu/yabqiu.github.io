---
title: 跳过构造函数创建 Java 对象(测试)
url: /create-java-instance-bypass-constructor/
date: 2018-08-21T23:31:52-05:00
featured: false
draft: true
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/https://unmi.cc/wp-content/uploads/2017/09/junit5_logo.png"
categories:
  - Java/JEE
tags: 
  - jMockit
  - mockito
  - 测试
  - UnitTest
comment: true
codeMaxLines: 50
# additional
wpPostId: 8967 
wpStatus: publish
views: 2767
lastmod: 2019-11-05T10:20:44-06:00
---

如果一个 Java 类在初始化时会有外部依赖，这就给单元测试创建它的实例时造成困难。当然被测试类可以改造为依赖全部构造时注入或创建实例后延迟注入，这里不考虑这种改造。</p>
<br/>
可以参看我以前一篇类似的日志：<a href="https://yanbin.blog/jmockit-mock-constructors/" target="_blank" rel="noopener noreferrer">使用 JMockit 来 mock 构造函数</a><br/><br/>
来说下面的例子<br/><br/>
<pre class="lang:default decode:true ">public class OrderService {
    private PriceInquiry priceInquiry = new PriceInquiry();
    .........<br/><br/>
    public double totalPrice() {
      return priceInquiry.retrieve(....);
    }
}</pre>
<br/>
假如上面的代码是不能改动的，并且在 <code>new PriceInquiry()</code> 时依赖于网络环境，所以单机情况不能创建成功。也就使得测试时试图<br/><br/>
<blockquote>
new OrderService();
</blockquote>
<br/>
会失败。并且试图用 Mockito 的 <code>@InjectMocks</code> 也不行<!--more--><br/><br/>
<pre class="lang:default decode:true">@RunWith(MockitoJUnitRunner.class)
public class OrderServiceTest {<br/><br/>
    @Mock
    private PriceInquiry priceInquiry;<br/><br/>
    @InjectMocks
    private OrderService testMe;<br/><br/>
    @Test
    public void fooTest() {
        ....
    }
}</pre>
<br/>
会出类似下面的借<br/><br/>
<blockquote>
org.mockito.exceptions.base.MockitoException: <br />
Cannot instantiate @InjectMocks field named 'testMe' of type 'class cc.unmi.OrderService'.<br />
You haven't provided the instance at field declaration so I tried to construct the instance.<br />
However the constructor or the initialization block threw an exception : xxxxxxxxxxxxxxxx
</blockquote>
<br/>
想要千方百计先创建出实例再转换掉内部的 <code>priceInquiry</code> 属性值的打算也落空了，因为无论是用 <code>new</code> 还是 <code>@InjectMocks</code> 怎么都跳不过构造函数的执行(实例成员的初始化会放到构造函数中去，没有声明构造函数会有一个默认构造函数)<br/><br/>
因此上面的需求就是如何在测试类跳过构造函数，初步想到的办法有四<br/><br/>
<h3>一. 反序列化跳过构造函数</h3><br/><br/>
ObjectInputstream.readObject() 反列化出 OrderService 对象，但前提是先要有序列化出的字节数据，所以不好操作，还会有 <code>serialVersionUID</code> 不一致的问题<br/><br/>
<h3>二. 使用 sun.misc.Unsafe 内部 API </h3><br/><br/>
<pre class="lang:default decode:true">@Test
public void fooTest() {
    OrderService testMe = createTestedInstance(OrderService.class);<br/><br/>
    PriceInquiry priceInquiry = Mockito.mock(PriceInquiry.class);
    Whitebox.setInternalState(testMe, "priceInquiry", priceInquiry);  //通过反射转换掉内部属性以使用 Mock 对象<br/><br/>
    //Your test here
}<br/><br/>
@SuppressWarnings("unchecked")
private &lt;T&gt; T createTestedInstance(Class&lt;T&gt; clazz) {
    try {
        Field singleoneInstanceField = Unsafe.class.getDeclaredField("theUnsafe");
        singleoneInstanceField.setAccessible(true);
        Unsafe unsafe = (Unsafe) singleoneInstanceField.get(null);
        return (T)unsafe.allocateInstance(clazz);
    } catch (Exception e) {
        throw new RuntimeException("cannot instantiate " + clazz + " bypassing default constructor");
    }
}</pre>
<br/>
但是上面的代码编译时会有警告<br/><br/>
<blockquote>
[WARNING] COMPILATION WARNING :<br />
...........................................sun.misc.Unsafe is internal proprietary API and may be removed in a future release
</blockquote>
<br/>
并且是没法用 `SuppressWarnings` 抑制住的警告，如果用 Maven 时配置了用 <code>-Werror</code> 编译选项的话将无法构建成功。除非不用 <code>-Werror</code> 选项，否则用他法来通过构建还不容易搞<br/><br/>
<h3>三. 用 JMockit 来 mock 构造函数</h3><br/><br/>
又要体验到 JMockit 比 Mockito 强大之处，我们不是一般问题还不愿意祭出 JMockit 来<br/><br/>
<pre class="lang:default decode:true ">@Test
public void fooTest() { 
    new MockUp&lt;OrderService&gt;() {
        @mockit.Mock
        public void $init() { //这样就不会调用 OrderService 实际的构造函数
        }
    };
    
    OrderService testMe = new OrderService();
    Whitebox.setInternalState(testMe, "priceInquiry", mockedPriceInquiry);<br/><br/>
    //Your test here
}</pre>
<br/>
通常情况下我只是用 JMockit 来辅助 Mockito, 因为更习惯于 Mockito 流畅的打桩(Stubbing) 和校验(Verifying) API。<br/><br/>
<h3>四. Deencapsulation.newUninitializedInstance(clazz), JMockit 更直截的方式</h3><br/><br/>
写本文之前只想到前面三种方式，借此机会又重新看了一个 JMockit 的 <code>Deencapsulation</code> API，发现一个更直截了当的方式，方法名为 <code>newUninitializedInstance(clazz)</code>。顾名思义，就是构造实例不初始化内部状态，恰恰是我所追求的。于是事情变得更为明了<br/><br/>
<pre class="lang:default decode:true">@Test
public void fooTest() {
    OrderService testMe = Deencapsulation.newUninitializedInstance(OrderService.class);
    Deencapsulation.setField(testMe, "priceInquiry", mockedPriceInquiry);<br/><br/>
    //Your test here
}</pre>
<br/>
连设置内部状态的 API <code>Deencapsulation</code> 也提供了，用不着模仿着 Mockito 1 做了一个 <code>Whitebox</code> 类来进行反射操作。<br/><br/>
最后，在测试中着重推荐用第四种方式，第三种方式也行，它们都是 JMockit 提供的实现。用 JMockit 来辅助 Mockito 跳过构造函数创建实例，而后替换实例的内部状态，再然后就是 Mockito 的事情了。如果被测试类的外部依赖能够通过构造函数或 setter 方法来注入就更简单了，常规手段而无需跳过构造函数就能创建被测试类的实例了。<br/><br/>
以上方式只是实例变量不被初始化，静态变量(即类变量) 不受影响，也就是说如果类中有<br/><br/>
<pre class="lang:default decode:true">private static Logger logger = LoggerFactory.getLogger(OrderService.class);</pre>
<br/>
<code>logger</code> 静态变量总是会被初始化。
