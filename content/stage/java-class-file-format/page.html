---
title: java class文件格式解析(摘)
url: /java-class-file-format/
date: 2009-04-11T13:34:00-05:00
featured: false
draft: false
type: post
toc: false
# menu: main
usePageBundles: true
categories:
  - JVM
tags: 
  - java class
comment: true
codeMaxLines: 50
# additional
wpPostId: 279 
wpStatus: publish
views: 440
lastmod: 2015-06-30T22:02:28-05:00
---

<p><strong><span style="font-size: medium;">1．目的<br /> </span></strong></p><p>大型软件系统开发时，某些Java组件可能涉及到多种数据库或中间件系统的连接和应用，例如一个数据传递组件需要从DB2中读取数据，并将数据通过中间件WebSphere MQ发送到其他系统，这类组件功能单一，但却需要连接多种第三方产品，使得程序员的单元测试变的非常不便，程序员不得不注视或修改部分源代码，或者在本地安装所需第三方产品。无疑这两种选择都是痛苦的。</p><p>基于以上的不便，本文开发了解析Java Class文件程序，目的是将第三方产品API的Class文件转换为Java源文件（不包括Java类的方法实现），在源文件的各种程序所需的方法里实现一些简单的语句，例如数据库连接方法永远返回true，获得数据方法永远返回 ”Hello world” 等，用JDK重新编译转换后的Java源文件，来替换真正的API 文件，这样程序员在UT测试时，无需修改源代码，也无需安装任何产品，并且能通过修改替换的API Java源文件实施各种UT测试。<!--more--></p><p>为了实现以上需求，必须先要了解Java Class文件格式。Java虚拟机识别的class文件格式包含Java虚拟机指令（或者bytecodes）和一个符号表以及其他的辅助信息。本文将使用VC++语言解析Java Class文件符号表，逆向生成Java源代码结构。如图1：</p><p> <img src="http://unmi.cc/wp-content/uploads/2009/04/tu1.jpg" alt="tu1.jpg" width="750" height="493" border="0" /></p><p>图1</p><p> 之所以使用VC++而不使用Java的主要是因为VC++界面开发简单；运行速度快，不需要虚拟机；需要用指针建立复杂的数据结构。</p><p><strong><span style="font-size: medium;">2．实现<br /> </span><br /> </strong><br /> 实现该工具的过程如下：</p><p>1．解析Class文件，从Class文件中读取数据并保存到称为ClassFile结构体中；</p><p>2．解析ClassFile结构体，生成源代码字符串；</p><p>3．将字符串显示到视图中。</p><p>2.1 解析Class文件</p><p>为实现第1步，首先需要了解Class文件格式规范，参考《Java虚拟机规范》第四章class文件格式，总结class文件的数据结构如图2。</p><p><strong><br /> <span style="font-size: medium;">2.1.1 Class文件格式</span><br /> </strong></p><p>Class文件格式ClassFile结构体的C语言描述如下：</p><p>struct ClassFile<br /> {<br />               u4 magic;                                 //识别Class文件格式，具体值为0xCAFEBABE，<br />               u2 minor_version;            // Class文件格式副版本号，<br />               u2 major_version;            // Class文件格式主版本号，<br />               u2 constant_pool_count; //  常数表项个数，<br />               cp_info **constant_pool;// 常数表，又称变长符号表，<br />               u2 access_flags;               //Class的声明中使用的修饰符掩码，<br />               u2 this_class;                   //常数表索引，索引内保存类名或接口名，<br />               u2 super_class;                //常数表索引，索引内保存父类名，<br />               u2 interfaces_count;        //超接口个数，<br />               u2 *interfaces;                 //常数表索引，各超接口名称，<br />               u2 fields_count;       //类的域个数，<br />               field_info **fields;          //域数据，包括属性名称索引，//域修饰符掩码等，<br />               u2 methods_count;          //方法个数，<br />               method_info **methods;//方法数据，包括方法名称索引，方法修饰符掩码等，<br />               u2 attributes_count;        //类附加属性个数，<br />               attribute_info **attributes; //类附加属性数据，包括源文件名等。<br /> };</p><p>其中u2为unsigned short，u4为unsigned long：</p><p>typedef unsigned char   u1;<br /> typedef unsigned short  u2;<br /> typedef unsigned long   u4;</p><p>cp_info **constant_pool是常量表的指针数组，指针数组个数为constant_pool_count，结构体cp_info为</p><p>struct cp_info<br /> {<br />               u1 tag;       //常数表数据类型<br />               u1 *info;   //常数表数据<br /> };</p><p>常数表数据类型Tag定义如下：</p><p>#define CONSTANT_Class                                         7     <br /> #define CONSTANT_Fieldref                                     9<br /> #define CONSTANT_Methodref                                10<br /> #define CONSTANT_InterfaceMethodref                  11<br /> #define CONSTANT_String                                                      8<br /> #define CONSTANT_Integer                                                  3<br /> #define CONSTANT_Float                                                       4<br /> #define CONSTANT_Long                                                       5<br /> #define CONSTANT_Double                                      6<br /> #define CONSTANT_NameAndType                         12<br /> #define CONSTANT_Utf8                                                        1</p><p>每种类型对应一个结构体保存该类型数据，例如CONSTANT_Class 的info指针指向的数据类型应为CONSTANT_Class_info</p><p>struct CONSTANT_Class_info<br /> {<br />               u1 tag;<br />               u2 name_index;<br /> };</p><p><img src="http://unmi.cc/wp-content/uploads/2009/04/tu2.jpg" alt="tu2.jpg" width="731" height="972" border="0" /></p><p>图2</p><p>CONSTANT_Utf8的info指针指向的数据类型应为CONSTANT_Utf8_info</p><p>struct CONSTANT_Utf8_info<br /> {<br />               u1 tag;<br />               u2 length;<br />               u1 *bytes;<br /> };</p><p>Tag和info的详细说明参考《Java虚拟机规范》第四章4.4节。</p><p>access_flags为类修饰符掩码，域与方法都有各自的修饰符掩码。</p><p>#define ACC_PUBLIC                                0x0001 <br /> #define ACC_PRIVATE                             0x0002<br /> #define ACC_PROTECTED                                   0x0004<br /> #define ACC_STATIC                                0x0008<br /> #define ACC_FINAL                                              0x0010<br /> #define ACC_SYNCHRONIZED                         0x0020<br /> #define ACC_SUPER                                                0x0020<br /> #define ACC_VOLATILE                                        0x0040<br /> #define ACC_TRANSIENT                                      0x0080 <br /> #define ACC_NATIVE                               0x0100<br /> #define ACC_INTERFACE                                      0x0200 <br /> #define ACC_ABSTRACT                                       0x0400 <br /> #define ACC_STRICT                                      0x0800</p><p>例如类的修饰符为public abstract则access_flags的值为ACC_PUBLIC | ACC_ABSTRACT=0x0401。</p><p>this_class的值是常数表的索引，索引的info内保存类或接口名。例如类名为com.sum.java.swing.SwingUtitlities2在info保存为com/sum/java/swing/SwingUtitlities2</p><p>super_class的值是常数表的索引，索引的info内保存超类名，在info内保存形式和类名相同。</p><p>interfaces是数组，数组个数为interfaces_count，数组内的元素为常数表的索引，索引的info内保存超接口名，在info内保存形式和类名相同。</p><p>field_info **fields是类域数据的指针数组，指针数组个数为fields_count，结构体field_info定义如下：</p><p>struct field_info<br /> {<br />               u2 access_flags;                 //域修饰符掩码<br />               u2 name_index;                 //域名在常数表内的索引<br />               u2 descriptor_index;          //域的描述符，其值是常数表内的索引<br />               u2 attributes_count;           //域的属性个数<br />               attribute_info **attributes; //域的属性数据，即域的值<br /> };</p><p>例如一个域定义如下：</p><p>private final static byte UNSET=127;</p><p>则该域的修饰符掩码值为：ACC_PRIVATE | ACC_STATIC | ACC_FINAL=0x001A</p><p>常数表内name_index索引内保存数据为UNSET，常数表内descriptor_index索引内保存的数据为B（B表示byte, 其他类型参考《Java虚拟机规范》第四章4.3.2节）。attributes_count的值为1，其中attributes是指针数组。指针数组个数为attributes_count，在此为1，attribute_info结构体如下：</p><p>struct attribute_info<br /> {<br />               u2 attribute_name_index;   //常数表内索引<br />               u4 attribute_length;            //属性长度<br />               u1 *info;                             //根据属性类型不同而值不同<br /> }; </p><p>attribute_info可以转换(cast)为多种类型ConstantValue_attribute，Exceptions_attribute，LineNumberTable_attribute，LocalVariableTable_attribute，Code_attribute等。</p><p>因为域的属性只有一种：ConstantValue_attribute，因此此结构体转换为</p><p>struct ConstantValue_attribute<br /> {<br />               u2 attribute_name_index;        //常数表内索引<br />               u4 attribute_length;                 //属性长度值，永远为2<br />               u2 constantvalue_index;         //常数表内索引，保存域的值<br />                                                           //在此例中，常数表内保存的值为127<br /> };</p><p>method_info **methods是方法数据的指针数组，指针数组个数为methods_count，结构体method_info定义如下：</p><p>struct method_info<br /> {<br />               u2 access_flags;                   //方法修饰符掩码<br />               u2 name_index;                   //方法名在常数表内的索引<br />               u2 descriptor_index;            //方法描述符，其值是常数表内的索引<br />               u2 attributes_count;             //方法的属性个数<br />               attribute_info **attributes;  //方法的属性数据，<br />                                                        //保存方法实现的Bytecode和异常处理<br /> };</p><p>例如一个方法定义如下：</p><p>public static boolean canAccessSystemClipboard(){<br />               ...<br /> }</p><p>则access_flags的值为 ACC_PUBLIC | ACC_STATIC =0x0009，常数表内name_index索引内保存数据为canAccessSystemClipboard，常数表内descriptor_index索引内保存数据为()Z；(括号表示方法参数，Z表示返回值为布尔型，详细说明参照《Java虚拟机规范》第四章4.3.2节)。attribute_info **attributes是方法的属性指针数组，个数为attributes_count，数组内保存的是常数表索引，info为Code_attribute或Exceptions_attribute。</p><p>本文不解析方法内容，因此忽略Code_attribute和Exceptions_attribute的内容。</p><p>ClassFile结构体中的attribute_info **attributes是附加属性数组指针，个数为attributes_count，本文只识别SourceFile属性。</p><p>struct SourceFile_attribute<br /> {<br />               u2 attribute_name_index; //常数表内索引<br />               u4 attribute_length;          //属性长度值，永远为2<br />               u2 sourcefile_index;         //常数表内索引，info保存源文件名<br /> };</p><p>例如com.sum.java.swing.SwingUtitlities2类的源文件名为SwingUtitlities2.java。</p><p>              以上是本文需要解析的Class文件格式。</p><p><span style="font-size: medium;"><br /> <strong>2.1.2 读取数据</strong><br /> </span></p><p>定义CJavaClass类完成解析Class文件，生成Java源程序字符串。使用VC++的MFC类CFile从Class文件读取数据。例如：用16进制编辑器打开Class文件，如图3，前4个byte分别是CA FE BA BE，使用CFile::Read(tmp,sizeof(u4))读取后，tmp的值为0xBEBAFECA，所以需要位转换。定义以下方法从文件读取定长数据：</p><p>  void readu1(u1 *buff);<br />   void readu2(u2 *buff);<br />   void readu4(u4 *buff);</p><p>定义如下方法读取变长数据。</p><p>void readun(void *buff,u4 len)；</p><p>读取的u2和u4的数据需要位转换：</p><p>U1  [0]<br /> U1 [1] <br /> U1   [1] <br /> U1 [0]<br />  <br /> U2：</p><p>U1  [0] <br /> U1 [1] <br /> U1   [3]<br />  <br /> U4：<br />  <br /> U1 [2] <br /> U1  [3] <br /> U1 [2] <br /> U1   [0] <br /> U1 [1]<br />  <br /> 调用void readu4(u4 *buff);后buff的值为0xCAFEBABE，该值为ClassFile的magic，识别该文件是Java Class文件。</p><p><img src="http://unmi.cc/wp-content/uploads/2009/04/tu3.jpg" alt="tu3.jpg" width="750" height="193" border="0" /></p><p>图3</p><p>              magic的后面是Class格式的版本号，图3的版本为0x00000030=0.48。版本后面是常数表的元素个数，图3的常数表的元素个数为0xD2=210个。常数表的元素个数之后如ClassFile结构体定义的常数表，类信息，接口信息，域信息，方法信息和附加属性等。</p><p><strong><br /> <span style="font-size: medium;">2.2 生成Java源文件</span><br /> </strong></p><p>              解析Class文件后，生产ClassFile结构体。遍历该结构体数据，则可根据Java语言规范生成Java源文件。例如根据ClassFile的access_flags值获得Java类的修饰符，其中access是CArray&lt;CString,CString&amp;&gt;，保存类所有的修饰符：</p><p>              if((flag &amp; ACC_PUBLIC )==ACC_PUBLIC)<br />               {<br />                           access.Add(CString("public"));<br />               }</p><p>              if((flag &amp; ACC_PRIVATE)==ACC_PRIVATE)<br />               {<br />                           access.Add(CString("private"));<br />               }</p><p>              if((flag &amp; ACC_PROTECTED)==ACC_PROTECTED)<br />               {<br />                          access.Add(CString("protected"));<br />               }</p><p>…</p><p><span style="font-size: medium;"><br /> <strong>2.3显示视图<br /> </strong><br /> </span></p><p>              将获得的Java源代码显示在MFC的CScrollView视图非常简单，可以添加一些关键字颜色，例如注释显示为草绿色等，如图4。</p><p><img src="http://unmi.cc/wp-content/uploads/2009/04/tu4.jpg" alt="tu4.jpg" width="750" height="399" border="0" /></p><p>图4</p><p><strong><br /> <span style="font-size: medium;">3．总结</span><br /> </strong></p><p>              本文根据《Java虚拟机规范》开发了解析Java Class文件格式，并生成Java源代码结构的工具。其优点是：</p><p>1．脱离Java 虚拟机或Java开发环境；</p><p>2．可查阅没有Java源代码的Class文件的内容；</p><p>3．为一些复杂的Java Jar包生成相同类名的替代类，方便开发调试。例如，用返回固定字符串的java源文件更换需要网络链接的相同java类，有助于本地运行与调试。</p><p>缺点是：</p><p>1．由于没有反编译Bytecode，工具生成的部分Java源文件需要手动添加一些Java属性值；</p><p>2．Java源文件内的所需要使用的Java方法内容需要程序员手动实现。</p><p>摘自：<a href="http://blog.csdn.net/zhy05/archive/2007/09/25/1800309.aspx">http://blog.csdn.net/zhy05/archive/2007/09/25/1800309.aspx</a></p>
