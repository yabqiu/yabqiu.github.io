---
title: postgres in (?,?) 和 =any(?) 用法/性能对比
url: /postgres-in-vs-any-comparison/
date: 2023-08-09T11:29:20-05:00
featured: false
draft: true
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/https://unmi.cc/wp-content/uploads/2018/05/postgresql-logo.png"
categories:
  - Java/JEE
  - Database
tags: 
  - JDBC
  - PostgreSQL
comment: true
codeMaxLines: 50
# additional
wpPostId: 13143 
wpStatus: publish
views: 805
lastmod: 2024-04-30T09:48:41-05:00
---

<p>刚刚回顾了一下 <a href="https://yanbin.blog/jdbc-sql-server-pass-list-parameter/">JDBC 操作 SQL Server 时如何传入列表参数</a>，即如何给 in (?) 条件直接传入一个列表参数，然而本质上是不支持，最终不得不展开为 in (?, ?,...?) 针对每个元素单独设置参数，不定长的参数对于重用已编译 PreparedStatement 语句的帮助不大。</p>

<p>那么 JDBC 操作 PostgreSQL 是何种状态呢？展开为多个参数当然是有效的。继续尝试 Spring 提供的 NamedParameterJdbcTemplate 的操作方式</p>

<blockquote><br/>
<p>String query = "select * from users where id in (:ids)";<br /><br/>
Map&lt;String, Object&gt; parameters = new HashMap&lt;&gt;();<br /><br/>
parameters.put("ids", IntStream.rangeClosed(1, 5).boxed().collect(toList()));<br /><br/>
List&lt;Map&lt;String, Object&gt;&gt; maps = namedParameterJdbcTemplate.queryForList(query, parameters);</p>

</blockquote>

<p>执行后查看到实际执行的语句是</p>

<blockquote><br/>
<p>select * from users where id in (?, ?, ?, ?, ?)</p>

</blockquote>

<p><!--more--></p>

<h3>使用 p6spy 捕获所执行的 SQL 语句</h3><br/>
<p>在 PostgreSQL 中试着查询视图 pg_stat_activity 来找到历史查询语句，但未成功，所以用了 <a href="https://github.com/p6spy/p6spy">p6spy</a> 来打印底层执行的 SQL 语句。十数年之前写过如何用 p6spy 来监控 SQL 语句的文章，p6spy 发展到现在使用起来也谈到简单了，只需在项目中引入依赖 p6spy:p6spy:3.9.1，然后再辅以两步</p>

<ol>

	<li>JDBC URL 稍作变化，在 jdbc 与数据库类型之间加入 p6spy 即可。如 <code>jdbc:postgresql://localhost/postgres</code> 变身为 <code>jdbc:p6spy:postgresql://localhost/postgres</code></li>

	<li>启动 Java 程序时加上系统属性 <code>-Dp6spy.config.appender=com.p6spy.engine.spy.appender.StdoutLogger</code></li>

</ol>

<p>如此操作数据库时就会在控制台实时打印出实际执行的语句，如上面的完整输出是</p>

<blockquote><br/>
<p>1691564330238|79|statement|connection 0|url jdbc:p6spy:postgresql://localhost/postgres|select * from users where id in (?, ?, ?, ?, ?)|select * from users where id in (1, 2, 3, 4, 5)</p>

</blockquote>

<h3>in (?, ?) 是有参数个数限制的</h3><br/>
<p>到这里我们不难看出，所谓的 <code>in (?, ?)</code> 形式是最笨拙的实现方式，效率上感觉不太妙。</p>

<p>那么 PostgreSQL 在用 in (?,?) 的方式时是否有参数个数的限制呢？测试了 10000</p>

<blockquote><br/>
<p>parameters.put("ids", IntStream.rangeClosed(1, 10000).boxed().collect(toList()));</p>

</blockquote>

<p>能正常返回结果。加到 10000</p>

<blockquote><br/>
<p>parameters.put("ids", IntStream.rangeClosed(1, 100000).boxed().collect(toList()));</p>

</blockquote>

<p>这下报错了</p>

<blockquote><br/>
<p>Caused by: org.postgresql.util.PSQLException: An I/O error occurred while sending to the backend.<br /><br/>
at org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:349)<br /><br/>
    ......<br /><br/>
at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:651)<br /><br/>
... 7 more<br /><br/>
Caused by: java.io.IOException: Tried to send an out-of-range integer as a 2-byte value: 100000<br /><br/>
at org.postgresql.core.PGStream.sendInteger2(PGStream.java:349)</p>

</blockquote>

<p>说是超过了有符号的两字节整数(int2) 的最大小值, 也就是说最大 32767, 超过这个值就会得到同样的错误。</p>

<p>注：在使用 PostgreSQL 15, JDBC 驱动为 42.7.3 的情况下，参数个数可以达到 65535, 即两字节无符号整数大小(uint2)。限制在 PgPreparedStatement 类中找到(这是 postgresql 42.7.3 驱动中的代码)</p>

<pre class="lang:default decode:true ">  final int maximumNumberOfParameters() {<br/>
    return connection.getPreferQueryMode() == PreferQueryMode.SIMPLE ? Integer.MAX_VALUE : 65535;<br/>
  }</pre>

<p>默认 preferQueryMode 是 extended, 所以限制是 65535, 如果在 JDBC URL 中配置了 ?preferQueryMode=simple, 则参数个数可达到 Java 整数的最大值 2,147,483,647, 但性能上会差</p>

<blockquote><br/>
<p>Specifies which mode is used to execute queries to database: simple means ('Q' execute, no parse, no bind, text mode only), extended means always use bind/ execute messages, extendedForPrepared means extended for prepared statements only.</p>

</blockquote>

<h3>使用 =any(?) 形式的查询</h3><br/>
<p>与 <code>=any(?)</code> 相配合的就是 PostgreSQL 驱动的 setArray() 和 createArrayOf() 方法实现，完整的代码如下</p>

<pre class="lang:default decode:true">String jdbcUrl = "jdbc:p6spy:postgresql://localhost/postgres";<br/>
Connection conn = DriverManager.getConnection(jdbcUrl, "sa", "mypassword");<br/>
<br/>
String query = "select * from users where id = any(?)";<br/>
PreparedStatement pstmt = conn.prepareStatement(query);<br/>
Object[] params = IntStream.rangeClosed(1, 3).boxed().toArray();<br/>
pstmt.setArray(1, conn.createArrayOf("int", params));<br/>
ResultSet rs = pstmt.executeQuery();<br/>
<br/>
while (rs.next()) {<br/>
    System.out.println(rs.getString(1));<br/>
}<br/>
</pre>

<p>执行上面的代码，p6spy 打印出</p>

<blockquote><br/>
<p>1691566338490|83|statement|connection 0|url jdbc:p6spy:postgresql://localhost/postgres|select * from users where id = any(?)|select * from users where id = any('{"1","2","3"}')</p>

</blockquote>

<p>这里 params 有三个元素，无论多少个元素，原始的 <code>select * from users where id = any(?)</code> 是不会变的。我们也可以测试一下它能接收多少个元素</p>

<blockquote><br/>
<p>Object[] params = IntStream.rangeClosed(1, 10000).boxed().toArray();</p>

</blockquote>

<p>10000 个元素，没问题; 100000 也行，1000000 也能应对。应该可以说 <code>=any(?)</code> 接收数组的大小无限制，和直接写 SQL 语句时的 <code>in (1, 2, ...n)</code> 一样的。</p>

<h3>JdbcTemplate 使用 <code>=any(?)</code></h3><br/>
<p>借助于 JdbcTemplate 时尝试过传递参数时同时传入 <code>int[] argTypes</code> 指定参数类型 ，无论是 Types.INTEGER 还是 Types.ARRAY 都未成功，最后只能用 <code>PreparedStatementCreator</code> 来显式调用 setArray() 方法，代码如下</p>

<pre class="lang:default decode:true">String query = "select * from users where id = any(?)";<br/>
Object[] params = IntStream.rangeClosed(1, 5).boxed().toArray();<br/>
List&lt;String&gt; values = jdbcTemplate.query(<br/>
        conn -&gt; {<br/>
            PreparedStatement pstmt = conn.prepareStatement(query);<br/>
            pstmt.setArray(1, conn.createArrayOf("int", params));<br/>
            return pstmt;<br/>
        }, (rs, idx) -&gt; rs.getString(2)<br/>
);</pre>

<p>并未增加多少代码</p>

<h3>in(?, ?) 与 =any(?) 的性能比较</h3><br/>
<p>这基本上二者还未上擂台就能猜出输赢来，比较的同时还得把另一种写法拉扯进来</p>

<pre class="lang:default decode:true ">select * from (values (1),(2),(3) ) tmp_users(id)</pre>

<p>在测试表 users 中有 439175 条记录，id 为主键，也就意味着有索引，然后随机从 users 表中取出若干 id 值作为查询条件。我们在使用 p6spy 输出 Query 时打印的第二列即为查询消耗的时间。</p>

<p>测试下 Schema</p>

<pre class="lang:default decode:true">create table users(<br/>
   id serial,<br/>
   name varchar(32),<br/>
   age int<br/>
);<br/>
</pre>

<p>完整的测试代码如下</p>

<pre class="lang:default decode:true">public class TestPostgreSQL {<br/>
<br/>
    public static void main(String[] args) throws Exception {<br/>
        String jdbcUrl = "jdbc:p6spy:postgresql://localhost/postgres";<br/>
        Connection conn = DriverManager.getConnection(jdbcUrl, "sa", "mypassword");<br/>
<br/>
        Integer[] userIds = getRandomUserIds(100);<br/>
        testSelectValues(conn, userIds);<br/>
        testIn(conn, userIds);<br/>
        testAny(conn, userIds);<br/>
    }<br/>
<br/>
    private static void testSelectValues(Connection conn, Integer[] params) throws Exception {<br/>
        String query = String.format("select id from (values %s) tmp_users(id)",<br/>
                Arrays.stream(params).map(i-&gt;"("+i+")").collect(Collectors.joining(",")));<br/>
        Statement stmt = conn.createStatement();<br/>
        stmt.executeQuery(query);<br/>
    }<br/>
<br/>
    private static void testIn(Connection conn, Integer[] params) throws Exception {<br/>
        String query = String.format("select id from users where id in (%s)",<br/>
                IntStream.rangeClosed(1, params.length).boxed().map(i-&gt;"?").collect(Collectors.joining(",")));<br/>
        PreparedStatement pstmt = conn.prepareStatement(query);<br/>
        for (int i = 0; i &lt; params.length; i++) {<br/>
           pstmt.setInt(i+1, params[i]);<br/>
        }<br/>
        pstmt.executeQuery();<br/>
    }<br/>
<br/>
    private static void testAny(Connection conn, Integer[] params) throws Exception {<br/>
        String query = "select id from users where id = any(?)";<br/>
        PreparedStatement pstmt = conn.prepareStatement(query);<br/>
        pstmt.setArray(1, conn.createArrayOf("int", params));<br/>
        pstmt.executeQuery();<br/>
    }<br/>
<br/>
    private static Integer[] getRandomUserIds(int num) throws IOException {<br/>
        List&lt;Integer&gt; userIds = Files.readAllLines(Paths.get("/Users/yanbin/user_ids.txt"))<br/>
                .stream().map(Integer::valueOf).collect(toList());<br/>
        Collections.shuffle(userIds);<br/>
        return userIds.subList(0, num).toArray(new Integer[]{});<br/>
    }<br/>
}<br/>
</pre>

<p>下面是 getRandomUserIds 取不同数量值时查询执行的时间(测试时所用驱动的参数个数限制是 32767)</p>

<table style="border-collapse: collapse; width: 100%; height: 216px;">

<tbody>

<tr style="height: 24px;">

<td style="width: 25%; height: 24px;">Number of RandomUserIds</td>

<td style="width: 25%; height: 24px;">testSelectValues(ms)</td>

<td style="width: 25%; height: 24px;">testIn(ms)</td>

<td style="width: 25%; height: 24px;">testAny(ms)</td>

</tr>

<tr style="height: 24px;">

<td style="width: 25%; height: 24px;">100</td>

<td style="width: 25%; height: 24px;">83</td>

<td style="width: 25%; height: 24px;">79</td>

<td style="width: 25%; height: 24px;">75</td>

</tr>

<tr style="height: 24px;">

<td style="width: 25%; height: 24px;">1,000</td>

<td style="width: 25%; height: 24px;">168</td>

<td style="width: 25%; height: 24px;">92</td>

<td style="width: 25%; height: 24px;">81</td>

</tr>

<tr style="height: 24px;">

<td style="width: 25%; height: 24px;">10,000</td>

<td style="width: 25%; height: 24px;">560</td>

<td style="width: 25%; height: 24px;">330</td>

<td style="width: 25%; height: 24px;">123</td>

</tr>

<tr style="height: 24px;">

<td style="width: 25%; height: 24px;">20,000</td>

<td style="width: 25%; height: 24px;">734</td>

<td style="width: 25%; height: 24px;">410</td>

<td style="width: 25%; height: 24px;">171</td>

</tr>

<tr style="height: 24px;">

<td style="width: 25%; height: 24px;">32767</td>

<td style="width: 25%; height: 24px;">934</td>

<td style="width: 25%; height: 24px;">611</td>

<td style="width: 25%; height: 24px;">262</td>

</tr>

<tr style="height: 24px;">

<td style="width: 25%; height: 24px;">60,000</td>

<td style="width: 25%; height: 24px;">1140</td>

<td style="width: 25%; height: 24px;">N/A</td>

<td style="width: 25%; height: 24px;">544</td>

</tr>

<tr style="height: 24px;">

<td style="width: 25%; height: 24px;">100,000</td>

<td style="width: 25%; height: 24px;">1446</td>

<td style="width: 25%; height: 24px;">N/A</td>

<td style="width: 25%; height: 24px;">785</td>

</tr>

<tr style="height: 24px;">

<td style="width: 25%; height: 24px;">300,000</td>

<td style="width: 25%; height: 24px;">4828</td>

<td style="width: 25%; height: 24px;"> </td>

<td style="width: 25%; height: 24px;">3875</td>

</tr>

</tbody>

</table>

<!-- wp:paragraph --><!-- /wp:paragraph --><br/>
<p>以上测试数据仅供参考</p>

<p>在 UserIds 量少的情况下分别不大，在多数时候 <code>=any(?)</code> 的方式还是最有效的。在超过 300,000 个 UserIds 时 SelectValues 和 <code>=any(?)</code> 没多大的差别，其实上面设计的测试本身就有问题了, SelectValues 总是从内存中查询数据，而 <code>=any(?)</code> 要从物理表中查询。</p>

<p>从简洁和效率上来讲, 在 JDBC 中还是优先考虑使用 PostgreSQL 的 <code>=any(?)</code> 处理列表参数。 </p>
