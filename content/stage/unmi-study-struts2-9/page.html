---
title: Unmi 的 Struts2 学习笔记(九)
url: /unmi-study-struts2-9/
date: 2008-04-14T10:24:00-05:00
featured: false
draft: true
type: post
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/https://yanbin.blog/wp-content/uploads/2007/05/struts-logo.jpeg"
categories:
  - Struts
tags: 
  - Struts2
comment: true
codeMaxLines: 50
# additional
wpPostId: 414 
wpStatus: publish
views: 318
lastmod: 2020-03-22T11:16:10-05:00
---

中世纪的欧洲《礼仪书》中说：痰不要吐到桌子上，也不要飞过桌子。1774年，欧洲的《礼仪与基督教礼貌守则》中说：我们再也不能原谅那些把痰吐到窗户外、墙上或者家具上的人。可见，欧洲人的素质也是在他们工业化富了之后的事。至少那个时候，我们的老祖宗再不争气，也绝不会把痰吐到桌子上。</p>
<br/>
1. OGNL 中有生成 List 和 Map 的表达式，分别是：{e1,e2,e3,...} 和 #{key1:val1,key2:val2,...}。对集合 OGNL 提供了两个操作符 in 和 not in，如：<br />
   &lt;s:if test="'foo' in {'foo','bar'}" ... &lt;/s:if&gt;            ---- not in 的用法当然是一样的了。<br />
之外，OGNL 还允许通过某个规则取集合的子集<br />
    ·? ：取出所有符合条件逻辑的元素<br />
    ·^：取出符合条件的第一个元素<!--more--><br />
    ·$：取出符合条件的最后一个元素<br />
请将上面这三个符号与正则表达式的表示法联系起来<br />
例了：persons.relatives.{? #this.gender == 'male'}        //取出集合 persons 中所有 gender 属性为 'male' 的子集。<br />
OGNL 还支持基本的 Lambda(λ) 表达式语法，不过好像有点复杂，暂不关顾。<br/><br/>
2. Struts2 的各路标签已是面目全非了。<br />
    &lt;s:if test="exp"&gt;...&lt;/s:if&gt;&lt;s:elseif test="exp"&gt;...&lt;/s:elseif&gt;&lt;s:else&gt;...&lt;/s:else&gt; 对应了 java 的 if/else if/else<br />
    &lt;s:iterator.../&gt; value 未指定是默认为 ValueStack 栈顶集合。id 为当前元素变量名。status 为 IteratorStatus 实例，包含奇还是偶行，当前索引，是否第一或最后一条记录。<br/><br/>
3. iterator 可以迭代 List、Set 和数组，也可以迭代 Map，用法如下：<br />
    &lt;s:iterator value="{'e1','e2','e3'}" id="name" status="st"&gt;   //这是用 OGNL 生成的 List<br />
         &lt;s:property value="name"/&gt;           //也可以写成 &lt;s:property value="#name"/&gt;<br />
           &lt;s:if test="#st.odd"&gt;偶数位&lt;/s:if&gt;<br />
           // st 其他属必如：#st.count、#st.index、#st.even、#st.first、#st.last，前面的 # 号不能少<br />
    &lt;/s:iterator&gt;<br />
   迭代 Map，用 key 和 map 对应<br />
   &lt;s:iterator value="#{'key1':'val1','key2':'val2','key3':'val3'}"&gt;<br />
      &lt;s:property value="key"/&gt; | &lt;s:property value="value"/&gt;   //不能写成 #key 和 #value，对 OGNL 还不熟<br />
   &lt;/s:iterator&gt;<br/><br/>
4. &lt;s:append.../&gt; 用于将多个集合拼成一个新集合，从而能用一个&lt;s:iterator .../&gt; 对多个集合迭代，也能拼 Map 的。&lt;s:merge .../&gt; 也是用来拼接集合，只是不像 &lt;s:append .../&gt; 那样依次保持着顺序，&lt;s:merge .../&gt; 是交错的。可以理解为前一个是深度拼接，后一个是广度拼接。<br/><br/>
5. 在学习 &lt;s:generator .../&gt; 时我们能同时体验一下 Struts2 标签是如何操作栈的，当然这里指的是 ValueStack，而非 Java 的方法栈。<br />
    &lt;s:generator val="'1,2,3'" separator=","&gt;  <span style="color: #800080;">&lt;!--字符串'123'以","分隔生成一个集合，并压栈--&gt;</span><br />
        &lt;s:iterator&gt;      <span style="color: #800080;">&lt;!-- 这里没有指定 value 属性，默认弹栈，并取一个元素压栈 --&gt;</span><br />
           &lt;s:property/&gt; <span style="color: #800080;">&lt;!-- 也没有指定 value 属性，默认也是取栈顶元素 --&gt;</span><br />
        &lt;/s:iterator&gt;     <span style="color: #800080;">&lt;!-- 迭代完成则从集合遍历的最后一个元素出栈 --&gt;</span><br />
    &lt;/s:generator&gt;      <span style="color: #800080;">&lt;!-- 最后，<strong>自动出栈</strong>，generator 生成的集合出栈 --&gt;</span><br />
    汇编是基于寄存器操作的，而 Java 是基于栈的操作，Struts2 引入了存放在 request 中的 ValueStack 正好完美再现了 Java 的这一原始本性，并可使标签使用更简洁，灵活。Struts2 还有很多标签也有这个特性：<br />
    1) 生成的新实例，压栈，标签结束后自动出栈<br />
    2) 在未指定数据来源时，默认从栈顶取数据。<br />
    不禁回想起 Struts1 的 &lt;nested:root&gt; 等 nested 标签要显示的声明操作的根元素，是多么麻烦的一件事。<br />
    补充：如果指定了 &lt;s:generator .../&gt; 的 id 属性的话，同时还会把生成的集合放到 pageContext 中，key 就是 id 指定的值。<br/><br/>
6. &lt;s:subset .../&gt; 是用来取集合子集的，可从 source (未指定则为栈顶集合) 集合的 start 位置起取 count 个元素。或者按自定义的 decider 条件，取符合条件的子集。你的 decider 要实现 SubsetIteratorFilter.Decider 接口的 decide(object element) 方法，符合条件的返回 true。此处不列出具体用法的实例。<br/><br/>
7. &lt;s:sort .../&gt; 依据 comparator 指定的比较器，对 source (未指定则为栈顶集合) 集合排序。排序头的集合当然也是压入栈中，标签结束自动出栈。<br/><br/>
8. &lt;s:debug/&gt; 会在页面生成一个 debug 链接，展开能看到 ValueStack  和 Stack Context 中的内容，该页面有显示用 #key 能获取到 Stack Context 中的值。&lt;s:property .../&gt; 在前面用很多次了，就相当于 Struts1 的  &lt;bean:write .../&gt;，value 未指定，输出栈顶值；若要输出的值为 null 时，指定了 default 属性则输出它；escape 指定是否忽略 HTML 代码，同 &lt;bean:write .../&gt; 的 ignore 属性。<br/><br/>
 9. &lt;s:push .../&gt; 用于将某个值压栈，标签结束后自动出栈，可方便某些操作，Struts1 的 &lt;nested:root&gt; 有类似功能。&lt;s:set .../&gt; 标签用于把某个值放入指定范围内，用 scope 指定，如 application、session、request、page、action。若未指定 scope 则放到 Stack Context 中；name 为新变量名；value 为欲处理的变量，未指定则取栈顶值。<br/><br/>
10. 从前面的标签，你也许已经注意到，Struts2 常操作的几个数据结构有 ValueStack、pageContext 和 StackContext。例如：generator、sort、subset 等生成的新实例会压到栈顶，并在标签结束自动出栈；如果 sort、subset 未指定 source 源集合，则从栈顶取，iterator、property 也是一样的；若为 generator 指定了 id 属性，则生的集合会存到 pageContext 中，key 就是 id 对应值；如果为 bean 指定了 id 属性，则会把 bean 实例存入到 Stack Context 中，key 就是 id 对应值，Stack Conext 中的值可以用 #key 取得。其他标签类似的地方应该要注意到。<br/><br/>
最后再来一贴，理解 ValueStack 和 Stack Context：<br />
   1)  ValueStack 可以用 request.getAttribute("struts.valueStack") 取得的一个 com.opensymphony.xwork2.util.OgnlValueStack 实例，它实现为一个栈，有 peek()、pop()、push(obj) 方法。<br />
   2)  Stack Context 是在前面的 ValueStack 的上下中的一个 java.util.Stack 实例：<br />
   //stack 为 ValueStack 实例，COMPONENT_STACK="__component_stack"<br />
   // org.apache.struts2.components.Component.getComponentStack() 中的代码<br />
   Stack componentStack = (Stack) stack.getContext().get(COMPONENT_STACK);
