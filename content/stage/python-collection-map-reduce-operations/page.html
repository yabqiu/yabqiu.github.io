---
title: Python 集合的遍历,推导及 filter/map/reduce 操作
url: /python-collection-map-reduce-operations/
date: 2019-01-29T19:21:37-06:00
featured: false
draft: false
type: post
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/http://unmi.cc/wp-content/uploads/2016/06/python-icon-200x200.png"
categories:
  - Python
tags: 
  - Map
  - Reduce
  - Filter
comment: true
codeMaxLines: 50
# additional
wpPostId: 9280 
wpStatus: publish
views: 1115
lastmod: 2019-01-29T19:27:20-06:00
---

<p>借鉴于其他多数语言中集合的 map/reduce 操作，也想总结一下在 Python 中如何对集合进行 map/reduce。而不是对于 Python 集合只会用简单的 <code>for ... in</code> 遍历，处于之间的是 Python 的  Comprehension 操作，更倾向于译作推导; 在 Scala 中也有类似的  <code>for-comprehension</code> 语法。</p>

<p>因此本文将涉及到三个方面的知识，基本的集合遍历操作，集合的推导，与 filter/map/reduce 操作。我无法写出诸如 掌握 Python 集体看这一篇就够了 的文章，但基本由本篇出发能了解到 Python 集合的基本遍历，转换操作。其余如切片，和更多能作用于 Python 集合的函数未有提及, 请查阅相关文档。</p>

<h3>集合的基本遍历操作</h3><br/>
<p>这一块主要是复习功课， 希望由此熟练掌握常用的集合遍历操作方式<!--more--></p>

<h4>基本遍历</h4><br/>
<pre class="lang:default decode:true ">for a in [1, 2, 3]:<br/>
    print(a)</pre>

<p>这个 <code>for ... in</code> 语法可应用于 <code>list</code>, <code>tuple</code>, 和 <code>set</code>, 还有  <code>range</code>, <code>map</code> 等。</p>

<p>不过上面的语法应用于 <code>dict</code> 只是对 <code>key</code> 进行遍历</p>

<pre class="lang:default decode:true">x = {"a": 1, "b": 2}<br/>
for key in x:     # 这里相当于是 for key in dict.keys():<br/>
    print(key, "=&gt;", x['key'])</pre>

<p>对于 dict 既然可以对 <code>keys()</code> 进行遍历，也就可以对值 <code>values()</code> 进行遍历</p>

<pre class="lang:default decode:true">x = {"a": 1, "b": 2}<br/>
for value in x.values():<br/>
    print(value)       # 依次输出 1, 2</pre>

<p><code>x.keys()</code> 的类型是 <code>dict_keys</code>，<code>list(x.keys()</code> 可以得到所有 key 组成的 <code>list</code>。<code>set(x.keys()</code> 得到相应的 <code>set</code></p>

<p><code>x.values()</code> 的类型是 <code>dict_values</code>。也可以用 <code>list(x.values()</code> 和 <code>set(x.values()</code> 转换为相应的 <code>list</code> 和 <code>set</code></p>

<h4>对 <code>dict</code> 同时遍历 key, value</h4><br/>
<pre class="lang:default decode:true ">map = {"a": 1, "b": 2}<br/>
for key, value in map.items():<br/>
    print(key, "=&gt;", value)</pre>

<p><code>map.items()</code> 类型是 <code>dict_items</code>, 看下方</p>

<pre class="lang:default decode:true ">&gt;&gt;&gt; map.items()<br/>
dict_items([('a', 1), ('b', 2)])<br/>
&gt;&gt;&gt; list(map.items())<br/>
[('a', 1), ('b', 2)]<br/>
&gt;&gt;&gt; set(map.items())<br/>
{('b', 2), ('a', 1)}</pre>

<p>因为每个元素是由 (key, value) 组成的  <code>tuple</code>, 所以能用 <code>for key, value</code> 进行拆解(unpack)。</p>

<h4>遍历时得到索引</h4><br/>
<p>这时候要用到 <code>enumerate</code> 函数</p>

<pre class="lang:default decode:true ">x = [1, 5, 3]<br/>
for index, value in enumerate(x):<br/>
    print(index, "=&gt;", value)</pre>

<p>可以想像它实质遍历的是 <code>list(enumerate(x))</code> 列表</p>

<pre class="lang:default decode:true ">&gt;&gt;&gt; list(enumerate(x))<br/>
[(0, 1), (1, 5), (2, 3)]</pre>

<p>它的每一个元素是由索引与值组成的  <code>tuple</code>, 所以用 <code>for index, value</code> 来拆解。</p>

<h4>集合的推导(comprehension)</h4><br/>
<p>Python 也无法在 <code>for ... in</code> 语句中应用 <code>if..else</code> 条件进行元素过滤，这就要用到推导了。Comprehension 可以同时完成集合的 <code>filter</code> 和 <code>map</code> 操作，如下</p>

<pre class="lang:default decode:true">x = [1, 5, 3]<br/>
y = [val * 2 for val in x]   # x 中每个元素乘以 2 得到新的列表 [2, 10, 6]<br/>
z = [val * 2 for val in x if val &gt; 2]  # x 中大于 2 的元素诚以 2 得到新的列表 [10, 6]</pre>

<p>它的基本语法是</p>

<blockquote><br/>
<p>new_list = [expression for variable in old_list if expression]<br /><br/>
new_dict = {key_expression: value_expression for variable in list if expression}<br /><br/>
new_tuple = (expression for variable in old_tuple if expression)  # 其中 old_tuple 也可以是 list</p>

</blockquote>

<p>在 expression 部分加入条件</p>

<pre class="lang:default decode:true">x = [1, 2, 3, 4]<br/>
&gt;&gt;&gt; x = [1, 2, 3, 4]<br/>
&gt;&gt;&gt; y = [True if val % 2 == 0 else False for val in x]<br/>
&gt;&gt;&gt; y<br/>
[False, True, False, True]</pre>

<p>Python 中的 <code>value1 if condition else value2</code> 语法我比较喜欢。</p>

<p>Comprehension 语法同样适用于 <code>tuple</code>, 例如下面的代码</p>

<pre class="lang:default decode:true">&gt;&gt;&gt; a = (1, 3, 5)<br/>
&gt;&gt;&gt; b = (val + 2 for val in a)<br/>
&gt;&gt;&gt; list(b)<br/>
[3, 5, 7]</pre>

<h4>对字典的推导</h4><br/>
<p>基于前面的推导语法，我们可以应用到 <code>dict</code> 上</p>

<pre class="lang:default decode:true ">&gt;&gt;&gt; x = {"a": 1, "b": 5, "c": 3}<br/>
&gt;&gt;&gt; y = {key: value + 2 for key, value in x.items()}<br/>
&gt;&gt;&gt; y<br/>
{'a': 3, 'b': 7, 'c': 5}<br/>
&gt;&gt;&gt; z = {key + "0": value + 2 for key, value in x.items() if value &gt; 2}<br/>
&gt;&gt;&gt; z<br/>
{'b0': 7, 'c0': 5}</pre>

<h4>推导中可以有多个 for</h4><br/>
<pre class="lang:default decode:true ">&gt;&gt;&gt; a = [1, 3, 5]<br/>
&gt;&gt;&gt; b = [2, 4, 6]<br/>
&gt;&gt;&gt; x = [v1 * v2 for v1 in a for v2 in b]<br/>
&gt;&gt;&gt; x<br/>
[2, 4, 6, 6, 12, 18, 10, 20, 30]</pre>

<p>上面得到一个 a 与 b 的笛卡尔乘积</p>

<h3>Filter/Map/Reduce 操作</h3><br/>
<p>现在来到本文立意的初衷，就是为了了解 Python 的 filter/map/reduce 操作。其中 <code>filter</code> 和 <code>map</code> 是可直接使用的两个函数，<code>reduce</code> 是来自于 <code>functools</code> 模块，需用 <code>from functools import reduce</code> 引入。看到 <code>functools</code> 模块名，它里边还有不少好料。</p>

<h4>Filter</h4><br/>
<p>对集合的过滤接受一个返回布尔值的 Predicate 函数，或者用内联 lambda 表达式的方式</p>

<pre class="lang:default decode:true">&gt;&gt;&gt; x = [1, 3, 2, 5]<br/>
&gt;&gt;&gt; def greater_then_2(val):<br/>
	return val &gt; 2<br/>
<br/>
&gt;&gt;&gt; y = filter(greater_then_2, x)<br/>
&gt;&gt;&gt; y<br/>
&lt;filter object at 0x1071f8048&gt;<br/>
&gt;&gt;&gt; list(y)<br/>
[3, 5]</pre>

<p>注意 <code>filter</code> 之后不是直接返回的 <code>list</code>, 而是一个 <code>filter</code> 类型，要用 <code>list(y)</code> 转换回 <code>list</code> 类型。</p>

<p>或者用内联 lambda 的方式</p>

<pre class="lang:default decode:true">&gt;&gt;&gt; x = [1, 3, 2, 5]<br/>
&gt;&gt;&gt; y = filter(lambda a: a &gt; 2, x)<br/>
&gt;&gt;&gt; list(y)<br/>
[3, 5]<br/>
&gt;&gt;&gt; z = filter(lambda a: a &gt; 2, filter(lambda a: a &gt; 2, x))<br/>
&gt;&gt;&gt; list(z)<br/>
[3, 5]</pre>

<p><code>filter</code> 之后返回的虽然不是一个 <code>list</code>, 但是它能被用于下一轮的 <code>filter</code>. 可是又不能直接 <code>for .. in</code> 遍历 <code>filter</code> 类型。</p>

<pre class="lang:default decode:true ">for val in y:<br/>
    print(y)</pre>

<p>输出是</p>

<blockquote><br/>
<p>&lt;filter object at 0x100e11160&gt;<br /><br/>
&lt;filter object at 0x100e11160&gt;</p>

</blockquote>

<h4>Map</h4><br/>
<p>有了 Filter 作铺垫之后，Map 就好理解了，只需把返回 True 或 False 的过滤函数改成转换函数。</p>

<pre class="lang:default decode:true ">&gt;&gt;&gt; x = [1, 3, 2, 5]<br/>
&gt;&gt;&gt; def plus_1(val):<br/>
	return val + 1<br/>
<br/>
&gt;&gt;&gt; y = map(plus_1, x)<br/>
&gt;&gt;&gt; y<br/>
&lt;map object at 0x1074b9160&gt;<br/>
&gt;&gt;&gt; list(y)<br/>
[2, 4, 3, 6]</pre>

<p>也是需用 <code>list(y)</code> 再转换回 list。也可以在 map 中用 lamba 表达式</p>

<pre class="lang:default decode:true ">y = map(lambda a: a + 1, x)</pre>

<h4>Reduce</h4><br/>
<p><code>reduce</code> 通常才是真正执行计算的过程，前面 <code>filter</code> 和 <code>map</code> 多是准备, 整理输入数据的。由集合收缩为一个值就是 <code>reduce</code> 操作，当然也可以收缩为一个集合类型值。</p>

<p>比如说 1 加到 100 的操作就可以采用  <code>reduce</code> 操作，reduce 时可以从一个自定义的初始值开始，也可从集合中的第一个元素开始。</p>

<pre class="lang:default decode:true ">&gt;&gt;&gt; from functools import reduce<br/>
&gt;&gt;&gt; numbers = range(1, 101)  # 下面直接对 range 进行 reduce 操作<br/>
&gt;&gt;&gt; def add(m, x):     # m 代表每次累加后的结果，x 是当前遍历到的元素<br/>
	return m + x<br/>
<br/>
&gt;&gt;&gt; <br/>
&gt;&gt;&gt; y = reduce(add, numbers)<br/>
&gt;&gt;&gt; y<br/>
5050</pre>

<p>Python 的 <code>reduce</code> 操作默认从集合的第一个元素开始，因此对空列表是不能 <code>reduce</code> 的，取不到第一个元素</p>

<pre class="lang:default decode:true">&gt;&gt;&gt; y = reduce(add, [])<br/>
Traceback (most recent call last):<br/>
  File "&lt;pyshell#48&gt;", line 1, in &lt;module&gt;<br/>
    y = reduce(add, [])<br/>
TypeError: reduce() of empty sequence with no initial value</pre>

<p><code>reduce</code> 也可以由第三个参数来提供初始值，如</p>

<pre class="lang:default decode:true ">&gt;&gt;&gt; y = reduce(add, [], 100)<br/>
&gt;&gt;&gt; y<br/>
100</pre>

<p><code>reduce</code> 方法的原型是</p>

<blockquote><br/>
<p>reduce(...)<br /><br/>
reduce(function, sequence[, initial]) -&gt; value</p>

</blockquote>

<p>下面两个 <code>reduce</code> 用法是等效的</p>

<pre class="lang:default decode:true">reduce(function, sequence)<br/>
reduce(function, sequence[1:], sequence[0]</pre>

<p>简单的  <code>reduce</code> 函数写成 lambda 表达式就行了。</p>

<p>链接：</p>

<ol>

	<li><a href="http://book.pythontips.com/en/latest/map_filter.html">Map, Filter and Reduce</a></li>

	<li><a href="https://python-3-patterns-idioms-test.readthedocs.io/en/latest/Comprehensions.html">Comprehensions</a></li>

</ol>
