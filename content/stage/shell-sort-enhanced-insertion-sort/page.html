---
title: 希尔(Shell) 排序 -  增强版插入排序算法
url: /shell-sort-enhanced-insertion-sort/
date: 2020-05-04T03:27:29-05:00
featured: false
draft: true
type: post
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/https://yanbin.blog/wp-content/uploads/2020/04/algorithm-icon.png"
categories:
  - Algorithm
tags: 
  - Sort
  - Python
comment: true
codeMaxLines: 50
# additional
wpPostId: 10174 
wpStatus: publish
views: 866
lastmod: 2020-05-19T11:20:51-05:00
---

<p>前面讲过的几种排序多是以排序逻辑来命名的，例如冒泡，选择和插入排序，以及其他如归并排序，当然还有觉得自己足够牛 X 快速排序命名。而本文要学习的排序算法叫做希尔排序是以其设计者 Donlad Shell 命令的排序算法，该算法在 1959 年公布，能以作者来命名的算法应该是很不错的，令设计者引以为傲的。最初写出冒泡和选择排序的就没以作者来命名，可能不好意说，更可能是公共思维。</p>

<p>那么什么是希尔排序呢？它实际上是插入排序算法的增强版本，又称递减增量排序算法。它对待排序列表进行间隔式分段插入处理，从而总体上减少了元素的移动次数而达到性能的大大提升。那么理解希尔排序之前一定要先了解插入排序。那么为什么说希尔排序既是递减又是增量呢？<!--more--></p>

<h3>算法分析与理解</h3><br/>
<p>下面我们就来看希尔排序的基本思路，同时理解其中的递减，增量，插入这几个概念。希尔排序对列表按间隔跳跃分组，对每个分组采用插入排序，完后递减间隔数再分组插入排序，直到间隔数为 1 时即进行一个全列表插入排序。</p>

<p>看下面的演示图，间隔增量初始为 3，而后递减到 1，实际排序中初始增量是有讲究的，如果初始为 1 就是一个标标准准的插入排序。</p>

<p><a href="https://yanbin.blog/wp-content/uploads/2020/05/shellsort.png"><img class="aligncenter wp-image-10212" src="https://yanbin.blog/wp-content/uploads/2020/05/shellsort-800x528.png" alt="" width="715" height="472" /></a>从上图我们可以看到为什么叫做递减增量排序。为什么不是采用连续分组而是按增量的跳跃分组，因为跳跃的分组才能使得整个列表在排序过程中趋于有序，而连续元素分组的内部排序毫无意义。</p>

<h3>参考代码实现</h3><br/>
<p>好了，有插入排序代码的基础加上以上的算法理解，我们可以尝试书写自己的实现</p>

<pre class="lang:default decode:true">def shell_sort(items):<br/>
    length = len(items)<br/>
    gap = 3          # gap 可以择为 len(items) // 2<br/>
    while gap &gt; 0:   # 递减增量<br/>
        for group_start in range(0, gap):   # 按增量跳跃分组<br/>
<br/>
            for index in range(group_start + gap, length, gap):     # 对每一个分组是一个标准的插入排序<br/>
                position = index<br/>
                current_value = items[index]<br/>
                while position &gt; group_start and items[position - gap] &gt; current_value:<br/>
                    items[position] = items[position - gap]<br/>
                    position -= gap<br/>
                items[position] = current_value<br/>
<br/>
        gap -= 1<br/>
<br/>
<br/>
items = [54, 26, 93, 31, 77, 17, 44, 55]<br/>
shell_sort(items)<br/>
print(items)</pre>

<p>查看排序过程(或<a href="http://pythontutor.com/visualize.html#code=def%20shell_sort%28items%29%3A%0A%20%20%20%20length%20%3D%20len%28items%29%0A%20%20%20%20gap%20%3D%203%0A%20%20%20%20while%20gap%20%3E%200%3A%0A%20%20%20%20%20%20%20%20for%20group_start%20in%20range%280,%20gap%29%3A%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20for%20index%20in%20range%28group_start%20%2B%20gap,%20length,%20gap%29%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20position%20%3D%20index%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20current_value%20%3D%20items%5Bindex%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20while%20position%20%3E%20group_start%20and%20items%5Bposition%20-%20gap%5D%20%3E%20current_value%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20items%5Bposition%5D%20%3D%20items%5Bposition%20-%20gap%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20position%20-%3D%20gap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20items%5Bposition%5D%20%3D%20current_value%0A%0A%20%20%20%20%20%20%20%20gap%20-%3D%201%0A%0A%0Aitems%20%3D%20%5B54,%2026,%2093,%2031,%2077,%2017,%2044,%2055%5D%0Ashell_sort%28items%29%0Aprint%28items%29&amp;cumulative=false&amp;curInstr=2&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">点击链接在新窗口中查看</a>)</p>

<p><iframe width="920" height="600" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=def%20shell_sort%28items%29%3A%0A%20%20%20%20length%20%3D%20len%28items%29%0A%20%20%20%20gap%20%3D%203%0A%20%20%20%20while%20gap%20%3E%200%3A%0A%20%20%20%20%20%20%20%20for%20group_start%20in%20range%280,%20gap%29%3A%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20for%20index%20in%20range%28group_start%20%2B%20gap,%20length,%20gap%29%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20position%20%3D%20index%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20current_value%20%3D%20items%5Bindex%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20while%20position%20%3E%20group_start%20and%20items%5Bposition%20-%20gap%5D%20%3E%20current_value%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20items%5Bposition%5D%20%3D%20items%5Bposition%20-%20gap%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20position%20-%3D%20gap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20items%5Bposition%5D%20%3D%20current_value%0A%0A%20%20%20%20%20%20%20%20gap%20-%3D%201%0A%0A%0Aitems%20%3D%20%5B54,%2026,%2093,%2031,%2077,%2017,%2044,%2055%5D%0Ashell_sort%28items%29%0Aprint%28items%29&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=2&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false"><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span> </iframe></p>

<p>再看看书上是怎么写的，好像没什么分别。就是前面代码直接使用了 3 作为初始间隔，对于列表长度为 3 或更短的，好像有点不妥，怎么分，分不了，但也不犯错，最终就是一次标准插入排序。</p>

<h3>希尔排序的时间复杂度</h3><br/>
<p>从循环上看，希尔排序的时间复杂度也是 O(n<sup>2</sup>), 如果在间隔(步长)选择上掌握好，最坏情况下达到 O(n<sup>3/2</sup>), 直至 O(n log<sup>2</sup> n) 的复杂度，对，就是快速排序的速度。</p>

<h3>间隔(步长) 的选择</h3><br/>
<p>Donald Shell 最初建议步长为 n/2, 已知最好的步长序列是由 Sedgewick 提出的(1, 5, 19, 41, 109, ...), 以下是摘自维基百科 <a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a> 词条中的</p>

<blockquote><br/>
<p>已知的最好步長序列是由Sedgewick提出的(1, 5, 19, 41, 109,...)，該序列的項來自 <span class="mwe-math-element"><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/03753d2e4d51a4cd55c8f97307b18239c9cc06eb" alt="9\times 4^{i}-9\times 2^{i}+1" aria-hidden="true" /></span>和  <span class="mwe-math-element"><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fe5f1f8c431469bd3e1bd655ed134f30fb9f63d7" alt="2^{{i+2}}\times (2^{{i+2}}-3)+1" aria-hidden="true" /> </span>這兩個算式<a class="external text" href="http://faculty.simpson.edu/" rel="nofollow">/lydia.sinapova/www/cmsc250/LN250_Weiss/L12-ShellSort.htm#increments</a>。這項研究也表明“比較在希爾排序中是最主要的操作，而不是交換。”用這樣步長序列的希爾排序比<a title="插入排序" href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a>要快，甚至在小數組中比<a title="快速排序" href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a>和<a title="堆排序" href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a>還快，但是在涉及大量數據時希爾排序還是比快速排序慢。</p>

<p>另一個在大數組中表現優異的步長序列是（<a class="mw-redirect" title="斐波那契數列" href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B8%E5%88%97">斐波那契數列</a>除去0和1將剩餘的數以<a class="mw-redirect" title="黃金分割比" href="https://zh.wikipedia.org/wiki/%E9%BB%83%E9%87%91%E5%88%86%E5%89%B2%E6%AF%94">黃金分割比</a>的兩倍的<a title="冪" href="https://zh.wikipedia.org/wiki/%E5%86%AA">冪</a>進行運算得到的數列）：(1, 9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244, 217378076, 1031612713,…)<sup id="cite_ref-2" class="reference"><a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#cite_note-2">[2]</a></sup></p>

</blockquote>

<h3>与插入排序的速度对比</h3><br/>
<p>既然说希尔排序是插入排序的增强版，那么增强了多少了呢？下面进行一组对比测试，其中希尔排序的步长是 41</p>

<p>比较测试代码如下：</p>

<pre class="lang:default decode:true ">def insertion_sort(alist):<br/>
    for index in range(1, len(alist)):<br/>
        current_value = alist[index]<br/>
        position = index<br/>
<br/>
        while position &gt; 0 and alist[position - 1] &gt; current_value:<br/>
            alist[position] = alist[position - 1]<br/>
            position = position - 1<br/>
<br/>
        alist[position] = current_value<br/>
<br/>
<br/>
def shell_sort(items):<br/>
    length = len(items)<br/>
    # gap = length // 2<br/>
    gap = 41<br/>
    while gap &gt; 0:<br/>
        for group_start in range(0, gap):<br/>
<br/>
            for index in range(group_start + gap, length, gap):<br/>
                position = index<br/>
                current_value = items[index]<br/>
                while position &gt; group_start and items[position - gap] &gt; current_value:<br/>
                    items[position] = items[position - gap]<br/>
                    position -= gap<br/>
                items[position] = current_value<br/>
<br/>
        gap -= 1<br/>
<br/>
<br/>
from timeit import Timer<br/>
import random<br/>
<br/>
t1 = Timer('insertion_sort(alist1)', 'from __main__ import insertion_sort', globals=globals())<br/>
t2 = Timer('shell_sort(alist2)', 'from __main__ import shell_sort', globals=globals())<br/>
<br/>
length = 100000<br/>
times = 1<br/>
alist = list(range(length))<br/>
alist1 = list.copy(alist)<br/>
alist2 = list.copy(alist)<br/>
print(t1.timeit(number=times), t2.timeit(number=times))<br/>
<br/>
alist = random.sample(list(range(length)), length)<br/>
alist1 = list.copy(alist)<br/>
alist2 = list.copy(alist)<br/>
print(t1.timeit(number=times), t2.timeit(number=times))<br/>
</pre>

<p>从以下列表中看到希尔排序对无序列表排序的速度优于纯粹的插入排序。</p>

<table style="border-collapse: collapse; width: 100%; height: 168px;">

<tbody>

<tr style="height: 24px;">

<td style="width: 33.3333%; height: 24px;"> <em>排序耗时(秒)</em></td>

<td style="width: 33.3333%; height: 24px;"> 插入排序</td>

<td style="width: 33.3333%; height: 24px;"> 希尔排序</td>

</tr>

<tr style="height: 24px;">

<td style="width: 33.3333%; height: 24px;"> 1 K 有序列表</td>

<td style="width: 33.3333%; height: 24px;"> 0.000249725</td>

<td style="width: 33.3333%; height: 24px;"> 00.006600888</td>

</tr>

<tr style="height: 24px;">

<td style="width: 33.3333%; height: 24px;"><strong> 1 K 无序列表</strong></td>

<td style="width: 33.3333%; height: 24px;"><strong> 0.053902998</strong></td>

<td style="width: 33.3333%; height: 24px;"><strong> 0.009157253</strong></td>

</tr>

<tr style="height: 24px;">

<td style="width: 33.3333%; height: 24px;"> 10 K 有序列表</td>

<td style="width: 33.3333%; height: 24px;"> 0.001805490</td>

<td style="width: 33.3333%; height: 24px;"> 0.075122025</td>

</tr>

<tr style="height: 24px;">

<td style="width: 33.3333%; height: 24px;"><strong> 10 K 无序列表</strong></td>

<td style="width: 33.3333%; height: 24px;"><strong> 5.513631449</strong></td>

<td style="width: 33.3333%; height: 24px;"><strong> 0.22346067</strong></td>

</tr>

<tr style="height: 24px;">

<td style="width: 33.3333%; height: 24px;"> 100 K 有序列表</td>

<td style="width: 33.3333%; height: 24px;"> 0.023105048</td>

<td style="width: 33.3333%; height: 24px;"> 0.809362354</td>

</tr>

<tr style="height: 24px;">

<td style="width: 33.3333%; height: 24px;"><strong> 100 K 无序列表</strong></td>

<td style="width: 33.3333%; height: 24px;"><strong> 564.843062358</strong></td>

<td style="width: 33.3333%; height: 24px;"><strong> 14.482590992</strong></td>

</tr>

</tbody>

</table>

<p><!-- wp:paragraph --><!-- /wp:paragraph --></p>

<p><a href="https://yanbin.blog/wp-content/uploads/2020/05/select_shell_sort_compare-1.png"><img class="aligncenter wp-image-10238" src="https://yanbin.blog/wp-content/uploads/2020/05/select_shell_sort_compare-1-800x341.png" alt="" width="904" height="385" /></a></p>

<p>实际测试中希尔排序的步长对排序速度影响很大，如果用  n/2 作为步长，速度并不快，在我的测试中如果以 n/2 为步长，希尔排序时间比插入还慢。</p>
