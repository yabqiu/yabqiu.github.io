---
title: Quartz Job Scheduling Framework［翻译］第八章. 使用 Quartz 插件 (第五部分)
url: /quartz-job-scheduling-framework-8-5/
date: 2008-07-22T08:45:00-05:00
featured: false
draft: true
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/https://yanbin.blog/wp-content/uploads/2007/10/quartz-logo.jpeg"
categories:
  - Quartz
tags: 
  - Quartz
  - 翻译
comment: true
codeMaxLines: 50
# additional
wpPostId: 363 
wpStatus: publish
views: 609
lastmod: 2020-03-22T12:16:46-05:00
---

<strong>五. Quartz 工具插件</strong></p>
<br/>
Quartz 框架包括几个你能用于你的应用中的几个插件。本节简单描述它们和它们的用途。<br/><br/>
<strong>·<span style="color: #800080;">JobInitializationPlugin</span></strong><br/><br/>
我们已经多次谈到过这个插件。它从一个 XML 文件中加载 Job 和 Trigger 信息(默认文件名是 <span style="color: #800080;">quartz_jobs.xml</span>) 。你可以通过在 <span style="color: #800080;">quartz.properties</span> 文件中为这个插件设定 <span style="color: #800080;">filename</span> 参数来配置文件名。假如你不需要数据库来存储你的 Job 或者是需要能快速测试特定 Job 的话，这个插件非常有帮助。<!--more--><br/><br/>
<strong>·<span style="color: #800080;">JobInitializationPluginMulitple</span></strong><br/><br/>
显然，由其相似的名字，<span style="color: #800080;">JobInitializationPluginMultiple</span> 类似于 <span style="color: #800080;">JobInitializationPlugin</span>。不同点在于它支持从多个 XML 文件加载而非只是一个。它也类似于代码 8.2 中的 <span style="color: #800080;">JobLoaderPlugin</span>，只是代码 8.2 的插件查找一个目录，而不是一系列的文件。<br/><br/>
指定给 <span style="color: #800080;">JobInitializationPluginMultiple</span> 的文件是以逗分进行分隔，配置在 <span style="color: #800080;">quartz.properties</span> 文件中的。这个插件的一个最好的特征就是能定期的扫描是否有修改，当它们有改变时能重新加载 Job 信息。它是通过实现 <span style="color: #800080;">org.quartz.jobs.FileScanListener</span> 来加入这一行为的。扫描间隔(定义为秒) 可以在属性文件中指定。<br/><br/>
<strong>·<span style="color: #800080;">LogginJobHistoryPlugin</span><br />
</strong><br />
<span style="color: #800080;">org.quartz.plugins.history.LogginJobHistoryPlugin</span> 是用来记录 Job 历史的，应用的是 commons-logging 框架。这包括 Job 的执行还有任何 Job 被否决的日志。这个插件允许配置日志消息，但已提供了默认的消息格式。格式可以指定 Job 的哪些字段会包括在消息中。你能为下列事件提供分离的消息格式：<br/><br/>
    ·<span style="color: #800080;">jobFailedMessage</span> 在 Job 执行失败时记录<br/><br/>
    ·<span style="color: #800080;">jobSuccessMessage</span> 在 Job 完成执行时记录<br/><br/>
    ·<span style="color: #800080;">jobToBeFiredMessage</span> 在 Job 即将执行时记录<br/><br/>
    ·<span style="color: #800080;">jobWasVetoedMessage</span> 在 Job 要被否决时记录<br/><br/>
例如，当你想要覆盖掉 Job 即将时的默认消息，并且你所关心，想在日志消息中看到的是 Job 的名称和执行时间，你可以加入以下行到 <span style="color: #800080;">quartz.properties</span> 文件：<br/><br/>
<span style="color: #800080;">org.quartz.plugin.jobHistory.class=org.quartz.plugins. history.LoggingJobHistoryPlugin</span><br/><br/>
<span style="color: #800080;">org.quartz.plugin.jobHistory.jobToBeFiredMessage=Job {0} is about to be fired at: {2, date, HH:mm:ss MM/dd/yyyy}</span><br/><br/>
你可以在日志消息在包含多个有关 Job 的数据元素。表 8.1 列出了这些元素和它们的数据类型。<br/><br/>
<table border="0">
<caption><strong>表 8.1. 能用于 Job 的消息格式中的元素<br />
</strong></caption>
<tbody>
<tr>
<td width="60"><strong>元素</strong></td>
<td width="150"><strong>数据类型</strong></td>
<td><strong>描述</strong></td>
</tr>
<tr>
<td>0</td>
<td>String</td>
<td>Job 的名称</td>
</tr>
<tr>
<td>1</td>
<td>String</td>
<td>Job 组的名称</td>
</tr>
<tr>
<td>2</td>
<td>Date</td>
<td>当前日期</td>
</tr>
<tr>
<td>3</td>
<td>String</td>
<td>Trigger 的名称</td>
</tr>
<tr>
<td>4</td>
<td>String</td>
<td>Trigger 组的名称</td>
</tr>
<tr>
<td>5</td>
<td>Date</td>
<td>调度的触发时间 </td>
</tr>
<tr>
<td>6</td>
<td>Date</td>
<td>调度的下一触发时间</td>
</tr>
<tr>
<td>7</td>
<td>Integer</td>
<td><span style="color: #800080;">JobExecutionContext</span> 的触发次数</td>
</tr>
</tbody>
</table>
<br/>
每个事件能分开来配置在 <span style="color: #800080;">quartz.properties</span> 文件中。使用这个插件唯一负面是，假如你有许多的 Job，日志文件很快就被撑大，几乎就是过度的信息了。<br/><br/>
<strong>·<span style="color: #800080;">LoggingTriggerHistoryPlugin</span></strong><br/><br/>
这个插件相当于 Job 的历史插件，只是它用于 Trigger 的历史信息罢了。你可以为如下 Trigger 事件提供日志消息格式：<br/><br/>
    ·<span style="color: #800080;">triggerCompleteMessage</span> 在 Trigger 完成了所有的触发再也不被触发时记录<br/><br/>
    ·<span style="color: #800080;">triggerFireMessage</span> 在 Trigger 触发时记录<br/><br/>
    ·<span style="color: #800080;">triggerMisfiredMessage</span> 在错过触发之后记录<br/><br/>
就像是 <span style="color: #800080;">LoggingJobHistoryPlugin</span>，你可以在属性文件中覆盖掉默认的消息格式。<br/><br/>
你可以在日志消息中包括有关 Trigger 的几个数据元素。表 8.2 列出了这些无素及数据类型。表 8.2 列出了能用于 Trigger 历史日志消息的元素。<br/><br/>
<table border="0">
<caption><strong>表 8.2. 能用于 Trigger 消息格式的元素</strong></caption>
<tbody>
<tr>
<td width="60"><strong>元素</strong></td>
<td width="150"><strong>数据类型</strong></td>
<td><strong>描述</strong></td>
</tr>
<tr>
<td>0</td>
<td>String</td>
<td>Trigger 的名称</td>
</tr>
<tr>
<td>1</td>
<td>String</td>
<td>Trigger 组的名称</td>
</tr>
<tr>
<td>2</td>
<td>Date</td>
<td>调度的触发时间</td>
</tr>
<tr>
<td>3</td>
<td>Date</td>
<td>Trigger 下一次触发时间</td>
</tr>
<tr>
<td>4</td>
<td>Date</td>
<td>Trigger 实际触发时间</td>
</tr>
<tr>
<td>5</td>
<td>String</td>
<td>Job 的名称 </td>
</tr>
<tr>
<td>6</td>
<td>String</td>
<td>Job 组的名称</td>
</tr>
<tr>
<td>7</td>
<td>Integer</td>
<td><span style="color: #800080;">JobExecutionContext</span> 的触发次数</td>
</tr>
</tbody>
</table>
<br/>
像是 <span style="color: #800080;">LoggingJobHistoryPlugin</span> 一样，这个插件也能记录大量的 ，特别是几个 Trigger 要经常触发。<br/><br/>
<strong>·<span style="color: #800080;">ShutdownHookPlugin</span><br />
</strong><br />
这个插件捕获 JVM 的关闭事件并强制关闭 Scheduler。你或许会说，“我为何需要在 JVM 已经在关闭时告诉 Scheduler 关闭自己呢？” 原因主要是让 Scheduler 能执行一个“干净”的关闭。<br/><br/>
当这个插件的 <span style="color: #800080;">initialize()</span> 方法被调用时，它会加入一个新的 <span style="color: #800080;">java.lang.Thread</span> 到 JVM 中。在 JVM 获取到关闭事件后，这由两个事件之一所导致：<br/><br/>
    ·当最后一个非守护线程退出或调用了 <span style="color: #800080;">System.exit()</span> 方法时的程序正常退出。<br/><br/>
    ·JVM 响应用户输入后被终止，如用户按下了 <span style="color: #800080;">Ctrl+C</span>，或是系统范围的事件，像用户注销或系统关闭。<br/><br/>
当 JVM 获取到关闭通知后，它对关闭线程执行一次回调并给这个线程以运行的机会。对 <span style="color: #800080;">ShutdownHookPlugin</span> 来说，<span style="color: #800080;">run()</span> 方法就会调用 Scheduler，并告诉它作出关闭操作。默认时，会传递一个布尔值 true 来调用 Scheduler 的 <span style="color: #800080;">shutdown()</span> 方法，这就等于告诉 Scheduler 执行一个“干净”的关闭。 这意味着 Scheduler 将要等待所有正在执行着的 Trigger 结束后才停止。<br/><br/>
你可以告诉这个插件不去执行一个“干净”的关闭，那就要在 <span style="color: #800080;">quartz.properties</span> 文件中把这作为插件的参数。<br/><br/>
[译者 Unmi 注：最后一句原文写得也有些含混不清，其实就是说要调用 Scheduler 的 <span style="color: #800080;">shutdown()</span> 方法时传递 false 参数的话，就要在 <span style="color: #800080;">quartz.properties</span> 中配置 <span style="color: #800080;">ShutdownHookPlugin</span> 的属性 <span style="color: #800080;">cleanShutdown</span> 为 false]
