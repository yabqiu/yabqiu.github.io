---
title: Java 9 - 快速创建不可变集合
url: /java-9-quick-create-immutable-collections/
date: 2018-06-06T00:22:57-05:00
featured: false
draft: true
type: post
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/https://unmi.cc/wp-content/uploads/2018/05/java9-logo.png"
categories:
  - Java/JEE
tags: 
  - Java 9
comment: true
codeMaxLines: 50
# additional
wpPostId: 8789 
wpStatus: publish
views: 1053
lastmod: 2018-06-06T00:36:56-05:00
---

<p>平台之所以谓之平台，以其能建立一个生态，并与之外围达成共赢。霸道点的平台也会反噬外围生态，像微软集成浏览器，媒体播放器。还有即将的 iOS 12 要把应用商店多是收费的 AR 皮尺放到它自己系统中来，走别人的路，让别人无路可走。从此众泰皮尺部的唯一的生产工具就会是人手一部能安装 iOS 12 iPhone 了。</p>

<p>JDK 也不例外，Java 8 之前日期库的话 <a href="http://www.joda.org/joda-time/">Joda-Time</a> 是首要之选，Java 8 集成后应该是鲜有人问津。以往说到集合操作库，有两个选择，其一为 <a href="https://commons.apache.org/proper/commons-collections/">Apache Commons Collections</a>，二为 Google 的 <a href="https://github.com/google/guava/wiki">Guava</a>，当然前者与后者竞争中也早已败下阵来，况且前者还受到 Java 8 的夹击。而本文要说的可以说是 Java 9 把 Guava 中创建不可变集合的方式据为已用了，直截了当的说，凡是 Java 9 后有创建不可变集合的需求，只要用三大接口 <code>List</code>， <code>Set</code>，<code>Map</code> 中的 <code>of(...)</code> 方法就对了。</p>

<p>Java 9 之前，当我们需要集合相关的操作，两个选择：</p>

<ol>

	<li>Apache Commons Collections 的几个类 <a href="https://commons.apache.org/proper/commons-collections/apidocs/org/apache/commons/collections4/ListUtils.html">ListUtils</a>, <a href="https://commons.apache.org/proper/commons-collections/apidocs/org/apache/commons/collections4/SetUtils.html">SetUtils</a>, <a href="https://commons.apache.org/proper/commons-collections/apidocs/org/apache/commons/collections4/MapUtils.html">MapUtils</a>, 和 <a href="https://commons.apache.org/proper/commons-collections/apidocs/org/apache/commons/collections4/CollectionUtils.html">CollectionsUtils</a>。比如它们提供的以下几些个工具方法<br/>
<br/>
<blockquote>ListUtils.unmodifiableList&lt;List&lt;? extends E&gt; list)   //创建不可变 List<br /><br/>
SetUtils.emptySet()  //不可变的空  Set<br /><br/>
SetUtils.unmodifiableSet(Set&lt;? extends E&gt; set)  //创建不可变 Set<br /><br/>
MapUtils.unmodifiableMap(Map&lt;? extends K, ? extends V&gt; map)  //创建不可变 Map<br /><br/>
CollectionUtils.unmodifiableCollection(Collection&lt;? extends C&gt; collection)  //创建不可变集合</blockquote>

</li>

	<li>Guava 的几个类 <a href="https://google.github.io/guava/releases/23.0/api/docs/com/google/common/collect/ImmutableList.html">ImmutableList</a>, <a href="https://google.github.io/guava/releases/23.0/api/docs/com/google/common/collect/ImmutableSet.html">ImmutableSet</a>, 和 <a href="https://google.github.io/guava/releases/23.0/api/docs/com/google/common/collect/ImmutableMap.html">ImmutableMap</a>。而它们创建不可变集合的方式就是通过各自的 <code>of(...)</code> 方法，以 <code>ImmutableList</code> 为例(其余两个类也类似)，它有<br/>
<br/>
<blockquote>of(): ImmutableList&lt;E&gt;<br /><br/>
of(E element): ImmutableList&lt;E&gt;<br /><br/>
of(E e1, E e2): ImmutableList&lt;E&gt;<br /><br/>
of(E e1, E e2, E e3): ImmutableList&lt;E&gt;<br /><br/>
......<br /><br/>
of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E... others): ImmutableList&lt;E&gt;</blockquote>

</li>

</ol>

<p><!--more--></p>

<p>而我们今天要说的 Java 9 在接口 List, Set, Map 上增加的方法就是偷师于 Guava 的以上三个类，也是提供的一堆的 <code>of(...)</code> 方法来创建对应的不可变集合，不过还是略有增强。</p>

<p>既然是读的 《Java 9 Revealed》这本书的内容，也看下 Java 9 之前 JDK API <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html">Collections</a> 可以怎么创建不可变集合，相关方法：</p>

<blockquote><br/>
<p>emptyList(): List&lt;T&gt;<br /><br/>
emptySet(): Set&lt;T&gt;<br /><br/>
emptyMap(): Map&lt;K, V&gt;</p>

<p>singletonList&lt;T o): List&lt;T&gt;<br /><br/>
singleton(T o): Set&lt;T&gt;<br /><br/>
singletonMap(K key, V value): Map&lt;K, V)</p>

<p>unmodifiableList(List&lt;? extends T&gt; list): List&lt;T&gt;<br /><br/>
unmodifiableSet(Set&lt;? extends T&gt; s): Set&lt;T&gt;<br /><br/>
unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m): Map&lt;K, V)</p>

</blockquote>

<p>上面最后三个方法可以看到要创建不可变的 List, Set, 或 Map，需要对一个现有的集合进行包装，这种操作就有些不那么纯洁了，因为对原始集合的修改会影响到所谓的不可变集合。以 unmodifiableList(List&lt;? extends T&gt; list) 为例：</p>

<pre class="lang:default decode:true ">List&lt;String&gt; list = new ArrayList&lt;&gt;();<br/>
list.add("a");<br/>
List&lt;String&gt; immutableList = Collections.unmodifiableList(list);<br/>
//immutableList.add("hello"); //虽然不能这样做<br/>
list.add("b"); //但修改原始集合让人质疑 immutableList 的不可变性<br/>
System.out.println(immutableList);  //[a, b]</pre>

<p>也就是 unmodifiableXxx(...) 产生的不可变集合实际上是有缺陷的。</p>

<p>而书中未提 <code>Arrays.asList(T... a)</code> 方法是由于它创建的是一个可变的 <code>ArrayList&lt;T&gt;</code> 实例，不在此讨论之列。</p>

<p>下面快速过一下 Java 9 的 List，Set，Map 的 <code>of(...)</code> 静态方法。先说一下那些 <code>of(...)</code> 及得到的结果的共同特点</p>

<ul><br/>
	<li>每个接口都提供了有限参数和不定参数的 <code>of(...)</code> 方法，有限参数的 <code>of(...)</code> 方法是为了性能考虑(如避免了参数装箱为数组)</li>

	<li>不同的 <code>of(...)</code> 方法返回的内部实例类型也是不确定的，可以查看每一个 <code>of(...)</code> 方法的返回类型</li>

	<li><code>of(...)</code> 返回的实例都是可序列化的，所以只要保证其中的每一个元素(Map 则包括  key 和  value )是可序列化的，那么集体本身就可被序列化</li>

	<li>所有的 <code>of(...)</code> 方法返回的都是真正的不可变集合，尝试对它们的任何修改都会抛出 UnsupportedOperationException 异常</li>

	<li>元素或元素的组成部分(Map 的 key 和 value) 都不允许 null 值的出现，否则抛出 NullPointerException 异常</li>

</ul><br/>
<h3>List.of(...) 创建不可变的 List</h3><br/>
<p>接口 <a href="https://docs.oracle.com/javase/9/docs/api/java/util/List.html">List</a> 的静态 of(...) 方法有</p>

<ul><br/>
	<li>static &lt;E&gt; List&lt;E&gt; of()   创建空列表，返回 ImmutableCollections.List0.instance()</li>

	<li>static &lt;E&gt; List&lt;E&gt; of(E e1)    返回 new ImmutableCollections.List1&lt;&gt;(e1)</li>

	<li>static &lt;E&gt; List&lt;E&gt; of(E e1, E e2) 返回 new ImmutalbeCollection.List2&lt;&gt;(e1, e2)</li>

	<li>......</li>

	<li>static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E 10)</li>

	<li>static &lt;E&gt; List&lt;E&gt; of(E... elements)</li>

</ul><br/>
<p> 注意：不允许包含 null 元素，否则抛出 NullPointerException 异常</p>

<h3>Set.of(...) 创建不可变的 Set</h3><br/>
<ul><br/>
	<li>static &lt;E&gt; Set&lt;E&gt; of()   创建空 set</li>

	<li>static &lt;E&gt; Set&lt;E&gt; of(E e1) </li>

	<li>static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2)</li>

	<li>......</li>

	<li>static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E 10)</li>

	<li>static &lt;E&gt; Set&lt;E&gt; of(E... elements)</li>

</ul><br/>
<p>注意：不允许包含 null 元素，否则抛出 NullPointerException 异常。并且不能有重复元素(调用方法时保证)，否则抛出 IllegalArgumentException 异常。不像  HashSet 会帮我们去重。</p>

<h3>Map.of(...) 创建不可变的  Map</h3><br/>
<ul><br/>
	<li>static &lt;K, V&gt; Map&lt;K, V&gt; of()  创建空 Map</li>

	<li>static &lt;K, V&gt; Map&lt;K, V&gt; of(K k1, V v1)</li>

	<li>static &lt;K, V&gt; Map&lt;K, V&gt; of(K k1, V v1, K k2, V v2)</li>

	<li>......</li>

	<li>static &lt;K, V&gt; Map&lt;K, V&gt; of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9,K k10, V v10)</li>

	<li>static &lt;K, V&gt; Map&lt;K, V&gt; ofEntries(Map.Entry&lt;? extends K, ? extends V&gt;... entries) </li>

</ul><br/>
<p>注间：<code>of(...)</code> 方法与  Guava 的 ImmutableMap 的用法是一样的，并且也是 key, value 都不允许有 null 值，否则抛出 NullPointerException 异常。<code>of(...)</code> 方法的参数对偶出现，key 和 value 交替。对于不定元素个数无法用 <code>of(...)</code> 方法是因为 Java 只支持最后一个元素的可变，所以只能把 key/value 封装起来，引入上面的最后一个方法</p>

<blockquote><br/>
<p>static &lt;K, V&gt; Map&lt;K, V&gt; ofEntries(Map.Entry&lt;? extends K, ? extends V&gt;... entries)</p>

</blockquote>

<p>再静态引入 <code>Map.entry</code> 方法后，我们使用 <code>ofEntries(...)</code> 方法的样式就是</p>

<pre class="lang:default decode:true">import static java.util.Map.entry;<br/>
<br/>
Map&lt;Integer, String&gt; numberToWord = Map.ofEntries(<br/>
    entry(1, "One"), entry(2, "Two"), entry(3, "Three"));</pre>

<h3>后话</h3><br/>
<p>Java 9 引入上述方法来创建不可变集合能够更有效使用内存，因为在集合的创建时元素的个数是确定的，不需要进行内部存储的动态伸展。</p>

<p>Java 9 使用 List，Set 和 Map 的 <code>of(...)</code> 方法来创建不可变已经是很大的进步了，当然不能与动态语言或 Scala 相比，看</p>

<p>Groovy 创建不可变  List 是</p>

<blockquote><br/>
<pre class="lang:default decode:true">def list = ['Groovy', 'Java', 'Scala'].asImmutable()<br/>
def map = [key1: 'value1', key2: 'value2'].asImmutable()</pre>

</blockquote>

<p>Scala 借助于伴生类和 Apply 方法就更简洁了</p>

<blockquote><br/>
<pre class="lang:default decode:true">val list = List("Groovy", "Java", "Scala")<br/>
val set = Set("A", "B", "C")<br/>
val map = Map("key1" -&gt; "value1", "key2" -&gt; "value2")</pre>

</blockquote>

<p>其实 JDK 是否包含流行的第三方组件库也是 Java 社区人民的呼声，不能怨 JDK 或 Oracle 的，总之方便的还是开发者。</p>
