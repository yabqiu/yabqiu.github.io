---
title: Java 普通线程池与 ForkJoinPool 的效果对比
url: /common-threadpool-vs-forkjoinpool/
date: 2020-04-08T00:14:36-05:00
featured: false
draft: true
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/https://yanbin.blog/wp-content/uploads/2018/06/java-logo.png"
categories:
  - Java/JEE
tags: 
  - multithread
comment: true
codeMaxLines: 50
# additional
wpPostId: 9556 
wpStatus: publish
views: 6276
lastmod: 2020-04-08T10:05:54-05:00
---

Java 多线程编程常用的一个接口是 <code>ExecutorService</code>, 其实就一个线程池的接口，一般由两种方式创建线程池，一为 Executors 的工厂方法，二则创建 ForkJoinPool 实例，当然也有直接使用 ThreadPoolExecutor 的。</p>
<br/>
关于什么时候用 <code>ForkJoinPool</code> 或普通的线程池(如 Executors.newFixedThreadPool(2) 或 new ThreadPoolExecutor(...)) 不过多的述说。如果要运用到 ForkJoinTask 的话就要用 ForkJoinPool, 它是 Java7 新引入的线程池类型。<br/><br/>
关于 Java7 的 fork-join 框架可参考很多年前的一篇 <a href="https://yanbin.blog/java-fork-join-framework-memo/">Java 的 fork-join 框架实例备忘</a>。ForkJoinPool 的一个典型特征是能够进行 <a href="https://en.wikipedia.org/wiki/Work_stealing">Work stealing</a>。它也是 Akka actor 效率高效的一个有力保证。<br/><br/>
本文只能某一种情形下在选择普通线程池与 ForkJoinPool 的区别，直接说吧，普通线程更容易造成死锁，而 ForkJoinPool 却能应对相同的状况。<!--more--><br/><br/>
以下面代码为例，testThreadPool(..) 可接收不同的 ExecutorService 类型，我们将做两个测试<br/><br/>
<pre class="lang:java decode:true">private static void testThreadPool(ExecutorService threadPool) {
    Future[] outerTasks = IntStream.rangeClosed(1, 2).mapToObj(i -&gt;
        threadPool.submit(() -&gt; {
            System.out.println(Thread.currentThread().getName() + ", level1 task " + i);<br/><br/>
            Future&lt;?&gt; innerTask = threadPool.submit(() -&gt;
                System.out.println(Thread.currentThread().getName() + ", level2 task" + i));<br/><br/>
            try {
                innerTask.get();
            } catch (Exception e) {
                e.printStackTrace();
            }
        })).toArray(Future[]::new);<br/><br/>
    System.out.println("waiting...");
    try {
        for (Future&lt;?&gt; outerTask : outerTasks) {
            outerTask.get();
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    System.out.println("done");
}</pre>
<br/>
<h3>普通线程池测试</h3><br/><br/>
调用代码如下<br/><br/>
<blockquote>
testThreadPool(Executors.newFixedThreadPool(2);
</blockquote>
<br/>
那么我们永远等不到执行结果，不能到达 "done" 那一行，控制台的输出停在<br/><br/>
<blockquote>
waiting...<br />
pool-1-thread-2, level1 task 2<br />
pool-1-thread-1, level1 task 1
</blockquote>
<br/>
因为线程池占满了，永远得不到空闲的线程来执行 "level2 task"。线程状态可以看到线程池中的两个线程都是 "WAITING (parking)" 状态。简单用下图分析一下为什么产生死锁状态<br/><br/>
<a href="https://yanbin.blog/wp-content/uploads/2020/04/common-threadpool-wait-each-other.png"><img class="aligncenter wp-image-10086" src="https://yanbin.blog/wp-content/uploads/2020/04/common-threadpool-wait-each-other-800x370.png" alt="" width="627" height="290" /></a><br/><br/>
<ol>
    <li>首先提交的两个任务把线程池中的两个线程都占满了，而它们又分别提交了子任务，并等待子任务完成才退出</li>
    <li>子任务在工作队列中等待线程池中释放出空闲线程来执行，这是不可能的，所以两边互相等待，死锁了</li>
</ol>
<br/>
如果加一个断点在 <code>innerTask.get()</code> 处，可以看到下面的效果<br/><br/>
<a href="https://yanbin.blog/wp-content/uploads/2020/04/common-threadpool-innerTask.get_line.png"><img class="aligncenter wp-image-10087 size-large" src="https://yanbin.blog/wp-content/uploads/2020/04/common-threadpool-innerTask.get_line-800x172.png" alt="" width="800" height="172" /></a><br/><br/>
一个普通线程池只有一个工作队列<br/><br/>
那么换成 <code>new ForkJoinPool(2)</code> 是一样的情况吗？下面就来测试<br/><br/>
<h3>测试 ForkJoinPool</h3><br/><br/>
调用代码如下<br/><br/>
<blockquote>
testThreadPool(new ForkJoinPool(2));
</blockquote>
<br/>
或者<br/><br/>
<blockquote>
testThreadPool(Executors.newWorkStealingPool(2));
</blockquote>
<br/>
上面两种方式得到的都是 ForkJoinPool，另外用 ForkJoinPool.commonPool() 也是，只不过它的线程池大小由机器的 CPU 内核决定的。<br/><br/>
执行后的效果是每次都能把所有任务执行完，输出类似如下：<br/><br/>
<blockquote>
waiting...<br />
ForkJoinPool-1-worker-0, level1 task 2<br />
ForkJoinPool-1-worker-1, level1 task 1<br />
ForkJoinPool-1-worker-2, level2 task2<br />
ForkJoinPool-1-worker-2, level2 task1<br />
done
</blockquote>
<br/>
是不是瞬间感觉到 ForkJoinPool 比普通线程池强大啊，也许这也是为什么 Java8 Stream 的 <code>parallelStream()</code> 或者 <code>CompletableFuture.runAsync()</code> 类似的方法未指定线程池时使用的默认线程池就是 <code>ForkJoinPool#commonPool()</code>，因为它不会死锁。<br/><br/>
ForkJoinPool  与普通线程池的主要区别前面提到过的，它实现了工作窃取算法。明显的内部区别是<br/><br/>
<ol>
    <li>普通线程池所有线程共享一个工作队列，有空闲线程时工作队列中的任务才能得到执行</li>
    <li>ForkJoinPool 中的每个线程有自己独立的工作队列，每个工作线程运行中产生新的任务，放在队尾</li>
    <li>某个工作线程会尝试窃取别个工作线程队列中的任务，从队列头部窃取</li>
    <li>遇到 join() 时，如前面的 future.get()，如果 join 的任务尚未完成，则可先处理其他任务</li>
</ol>
<br/>
这就是 ForkJoinPool 不会像普通线程池那样被死锁的秘诀。<br/><br/>
我们断点调试观察一下内部状态，自然，最好的理解还是阅读源代码。下面依次截了三个图，它们来自同一次运行的前后<br/><br/>
<a href="https://yanbin.blog/wp-content/uploads/2020/04/forkjoinpool-waiting.png"><img class="aligncenter size-large wp-image-10091" src="https://yanbin.blog/wp-content/uploads/2020/04/forkjoinpool-waiting-800x156.png" alt="" width="800" height="156" /></a><br/><br/>
<p style="text-align: center;">断点停在 "waiting" 行时的 ForkJoinPool 线程池内容状态</p>
<br/>
工作队列的数量为 3，正在运行的任务数为 2<br/><br/>
<a href="https://yanbin.blog/wp-content/uploads/2020/04/forkjoinpool-2nd-outtertask-get.png"><img class="aligncenter size-large wp-image-10092" src="https://yanbin.blog/wp-content/uploads/2020/04/forkjoinpool-2nd-outtertask-get-800x211.png" alt="" width="800" height="211" /></a><br/><br/>
<p style="text-align: center;">断点停在第二次 outertask.get() 行时</p>
<br/>
工作队列的数量变成了 5，threadPool 的 size 为 3，看到 steals 窃取了任务数为 4<br/><br/>
<a href="https://yanbin.blog/wp-content/uploads/2020/04/forkjoinpool-done.png"><img class="aligncenter size-large wp-image-10093" src="https://yanbin.blog/wp-content/uploads/2020/04/forkjoinpool-done-800x211.png" alt="" width="800" height="211" /></a><br/><br/>
<p style="text-align: center;">断点停在 "done" 行时</p>
<br/>
任务全部完成，工作队列的数量变成了4<br/><br/>
本文对 Java 普通线程池与 ForkJoinPool 的一个简单对比旨在提供了一种避免任务相互等待的可能性，特别是在任务中又提交子任务然后等待子任务时的情况。也能从感性上对 ForkJoinPool 一点浅显的认识。
