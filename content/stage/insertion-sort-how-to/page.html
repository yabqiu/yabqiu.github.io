---
title: 插入排序算法解析
url: /insertion-sort-how-to/
date: 2020-04-27T02:46:27-05:00
featured: false
draft: false
type: post
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/https://yanbin.blog/wp-content/uploads/2020/04/algorithm-icon.png"
categories:
  - Algorithm
tags: 
  - Sort
  - Python
  - Algorithm
comment: true
codeMaxLines: 50
# additional
wpPostId: 10192 
wpStatus: publish
views: 630
lastmod: 2020-05-05T19:45:17-05:00
---

前面说过最原始的复杂度为 O(n<sup>2</sup>) 的冒泡和选择排序，也跳跃到了复杂度为  O(n log n) 的快速排序，现在又再看一个复杂度同样为 O(n<sup>2</sup>) 的插入排序。从排序名称结合代码我们理解了为什么叫做冒泡或是选择，快速排序自认高名，那么何以这又谓之插入排序呢？是怎么插入，从左边往右边插，还是从右边往左边插，这得搞清它的排序原理：</p>
<br/>
它在列表较低的一端维护一个有序的子列表(从最左端一个元素开始)，并逐个将每个新元素(高端的)"插入"这个子列表。插入的时候遍历低端列表，找准位置插入便是，插入点后的元素需后移，当所有高端的元素插入完成了，整个列表就变得有序了。<br/><br/>
整个排序操作示意图如下：<!--more--><br/><br/>
<a href="https://yanbin.blog/wp-content/uploads/2020/04/insertionsort.png"><img class="aligncenter wp-image-10193 size-full" src="https://yanbin.blog/wp-content/uploads/2020/04/insertionsort.png" alt="" width="484" height="458" /></a>好了，到此为止排序过程应该很清楚了，先不用看下面的代码，可以自己尝试写一段再进行对比。<br/><br/>
我试了一段，如下：<br/><br/>
<pre class="lang:default decode:true">items = [54, 26, 93, 17, 77, 31, 44, 55, 20]<br/><br/>
for i in range(1, len(items)):
    for j in range(i):
        if items[i] &lt; items[j]:
            items[i], items[j] = items[j], items[i]<br/><br/>

print(items) # [17, 20, 26, 31, 44, 54, 55, 77, 93]</pre>
<br/>
排序后结果是对的，但中间结果有些跳跃，可从下面看到每一步的变化(或<a href="http://pythontutor.com/visualize.html#code=items%20%3D%20%5B54,%2026,%2093,%2017,%2077,%2031,%2044,%2055,%2020%5D%0A%20%20%20%20%0Afor%20i%20in%20range%281,%20len%28items%29%29%3A%0A%20%20%20%20for%20j%20in%20range%28i%29%3A%0A%20%20%20%20%20%20%20%20if%20items%5Bi%5D%20%3C%20items%5Bj%5D%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20items%5Bi%5D,%20items%5Bj%5D%20%3D%20items%5Bj%5D,%20items%5Bi%5D%0A%20%20%20%20%0A%20%20%20%20%0Aprint%28items%29&amp;cumulative=false&amp;curInstr=1&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false" target="_blank" rel="noopener noreferrer">点击链接在窗口中查看</a>)<br/><br/>
<iframe width="925" height="430" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=items%20%3D%20%5B54,%2026,%2093,%2017,%2077,%2031,%2044,%2055,%2020%5D%0A%0Afor%20i%20in%20range%281,%20len%28items%29%29%3A%0A%20%20%20%20for%20j%20in%20range%28i%29%3A%0A%20%20%20%20%20%20%20%20if%20items%5Bi%5D%20%3C%20items%5Bj%5D%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20items%5Bi%5D,%20items%5Bj%5D%20%3D%20items%5Bj%5D,%20items%5Bi%5D%0A%0A%0Aprint%28items%29&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=1&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false"><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span> </iframe><br/><br/>
执行中的大循环演化过程是对的<br/><br/>
<blockquote>
<ol>
    <li>[54, 26, 93, 17, 77, 31, 44, 55, 20]</li>
    <li>[<span style="color: #ff0000;">26</span>, 54, 93, 17, 77, 31, 44, 55, 20]</li>
    <li>[26, 54, <span style="color: #ff0000;">93</span>, 17, 77, 31, 44, 55, 20]</li>
    <li>[<span style="color: #ff0000;">17</span>, 26, 54, 93, 77, 31, 44, 55, 20]</li>
    <li>[17, 26, 54, <span style="color: #ff0000;">77</span>, 93, 31, 44, 55, 20]</li>
    <li>[17, 26, <span style="color: #ff0000;">31</span>, 54, 77, 93, 44, 55, 20]</li>
    <li>[17, 26, 31, <span style="color: #ff0000;">44</span>, 54, 77, 93, 55, 20]</li>
    <li>[17, 26, 31, 44, 54, <span style="color: #ff0000;">55</span>, 77, 93, 20]</li>
    <li>[17, <span style="color: #ff0000;">20</span>, 26, 31, 44, 54, 55, 77, 93]</li>
</ol>
</blockquote>
<br/>
如果要看每一步循环后的结果的话会有下面的中间状态：<br/><br/>
<blockquote>
[26, 54, 93, 17, 77, 31, 44, 55, 20]<br />
[<span style="color: #ff0000;">17</span>, 54, 93, <span style="color: #ff0000;">26</span>, 77, 31, 44, 55, 20]<br />
[17, 26, 93, 54, <span style="color: #ff0000;">77</span>, 31, 44, 55, 20]
</blockquote>
<br/>
插入 17 后，原本排好的 26 又跑到了 93 后面，插入 77 后 26 再一次回到了正确的位置上。也就是说插入结果后，插入点后方的元素并非整体后移，而且循环次数也较多。<br/><br/>
正确的插入排序代码应该是这样子的：<br/><br/>
<pre class="lang:default decode:true">def insertion_sort(alist):
    for index in range(1, len(alist)):
        currentvalue = alist[index]
        position = index
        
        while position &gt; 0 and alist[position-1] &gt; currentvalue:
            alist[position] = alist[position -1]
            position = position -1
            
        
        alist[position] = currentvalue
        <br/><br/>
items = [54, 26, 93, 17, 77, 31, 44, 55, 20]
insertion_sort(items)</pre>
<br/>
上面的插入排序代码插入时是在子列表中从后往前找，比当前元素大的后移，找到比当前元素小时，在该元素后插入当前元素。插入时也可以从左往右找位置，找到比当前元素小的时，在该位置前插入当前元素，剩下的子列表元素后移。交换操作的时间大约是移操作的 3 位，因为后都只需进行一次赋值。看下面的执行过程<br/><br/>
<iframe width="950" height="550" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=def%20insertion_sort%28alist%29%3A%0A%20%20%20%20for%20index%20in%20range%281,%20len%28alist%29%29%3A%0A%20%20%20%20%20%20%20%20currentvalue%20%3D%20alist%5Bindex%5D%0A%20%20%20%20%20%20%20%20position%20%3D%20index%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20while%20position%20%3E%200%20and%20alist%5Bposition-1%5D%20%3E%20currentvalue%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20alist%5Bposition%5D%20%3D%20alist%5Bposition%20-1%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20position%20%3D%20position%20-1%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20alist%5Bposition%5D%20%3D%20currentvalue%0A%20%20%20%20%20%20%20%20%0A%0Aitems%20%3D%20%5B54,%2026,%2093,%2017,%2077,%2031,%2044,%2055,%2020%5D%0Ainsertion_sort%28items%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=2&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false"><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span> </iframe><br/><br/>
或点击<a href="http://pythontutor.com/visualize.html#code=def%20insertion_sort%28alist%29%3A%0A%20%20%20%20for%20index%20in%20range%281,%20len%28alist%29%29%3A%0A%20%20%20%20%20%20%20%20currentvalue%20%3D%20alist%5Bindex%5D%0A%20%20%20%20%20%20%20%20position%20%3D%20index%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20while%20position%20%3E%200%20and%20alist%5Bposition-1%5D%20%3E%20currentvalue%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20alist%5Bposition%5D%20%3D%20alist%5Bposition%20-1%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20position%20%3D%20position%20-1%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20alist%5Bposition%5D%20%3D%20currentvalue%0A%20%20%20%20%20%20%20%20%0A%0Aitems%20%3D%20%5B54,%2026,%2093,%2017,%2077,%2031,%2044,%2055,%2020%5D%0Ainsertion_sort%28items%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20&amp;cumulative=false&amp;curInstr=2&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false" target="_blank" rel="noopener noreferrer">链接在新窗口中查看</a>。<br/><br/>
既然它的时间复杂度也是 O(n<sup>2</sup>)，那么它在某些方面有什么好处没？稳定，比冒泡，选择要快，对比一下分别对十万有序和无序列表的排序时间。就不与快速排序比较了，本身就是不公平的。<br/><br/>
比较代码：<br/><br/>
<pre class="lang:default decode:true ">def bubble_sort(items):
    exchanges = True
    for i in range(len(items)):
        if not exchanges:
            return
        exchanges = False
        for j in range(len(items) - i - 1):
            if items[j] &gt; items[j + 1]:
                exchanges = True
                items[j], items[j + 1] = items[j + 1], items[j]<br/><br/>
def selection_sort(items):
    length = len(items)
    for i in range(length):
        for j in range(i + 1, length):
            if items[i] &gt; items[j]:
                items[i], items[j] = items[j], items[i]<br/><br/>

def insertion_sort(items):
    for index in range(1, len(items)):
        current_value = items[index]
        position = index<br/><br/>
        while position &gt; 0 and items[position - 1] &gt; current_value:
            items[position] = items[position - 1]
            position = position - 1<br/><br/>
        items[position] = current_value<br/><br/>

from timeit import Timer
import random<br/><br/>
t1 = Timer('bubble_sort(alist1)', 'from __main__ import bubble_sort', globals=globals())
t2 = Timer('selection_sort(alist2)', 'from __main__ import selection_sort', globals=globals())
t3 = Timer('insertion_sort(alist3)', 'from __main__ import insertion_sort', globals=globals())<br/><br/>
length = 10000<br/><br/>
times = 1
alist = list(range(length))
alist1 = list.copy(alist)
alist2 = list.copy(alist)
alist3 = list.copy(alist)
print(t1.timeit(number=times), t2.timeit(number=times), t3.timeit(number=times))<br/><br/>
alist = random.sample(list(range(length)), length)
alist1 = list.copy(alist)
alist2 = list.copy(alist)
alist3 = list.copy(alist)
print(t1.timeit(number=times), t2.timeit(number=times), t3.timeit(number=times))</pre>
<br/>
排序有序/无序长度的列表的耗时<br/><br/>
<table style="border-collapse: collapse; width: 100%; height: 97px;">
<tbody>
<tr style="height: 24px;">
<td style="width: 12.6481%; height: 25px;">排序耗时(秒)</td>
<td style="width: 13.4864%; height: 25px;">有序列表(1千)</td>
<td style="width: 12.5415%; height: 25px;">有序列表(1万)</td>
<td style="width: 14.7045%; height: 25px;">有序列表(10万）</td>
<td style="width: 13.7118%; height: 25px;">无序列表(1千)</td>
<td style="width: 13.4085%; height: 25px;">无序列表(1万)</td>
<td style="width: 13.6754%; height: 25px;">无序列表(10万)</td>
</tr>
<tr style="height: 24px;">
<td style="width: 12.6481%; height: 24px;">冒泡排序</td>
<td style="width: 13.4864%; height: 24px;">0.000115519</td>
<td style="width: 12.5415%; height: 24px;">0.000962132</td>
<td style="width: 14.7045%; height: 24px;">0.010000855</td>
<td style="width: 13.7118%; height: 24px;">0.084467821</td>
<td style="width: 13.4085%; height: 24px;">9.189967045</td>
<td style="width: 13.6754%; height: 24px;">930.12178294</td>
</tr>
<tr style="height: 24px;">
<td style="width: 12.6481%; height: 24px;">选择排序</td>
<td style="width: 13.4864%; height: 24px;">0.039573398</td>
<td style="width: 12.5415%; height: 24px;">3.538418601</td>
<td style="width: 14.7045%; height: 24px;">346.357997123</td>
<td style="width: 13.7118%; height: 24px;">0.053535146</td>
<td style="width: 13.4085%; height: 24px;">6.09890444</td>
<td style="width: 13.6754%; height: 24px;">617.163237883</td>
</tr>
<tr style="height: 24px;">
<td style="width: 12.6481%; height: 24px;">插入排序</td>
<td style="width: 13.4864%; height: 24px;">0.000135626</td>
<td style="width: 12.5415%; height: 24px;">0.00145926</td>
<td style="width: 14.7045%; height: 24px;">0.017356704</td>
<td style="width: 13.7118%; height: 24px;">0.044791698</td>
<td style="width: 13.4085%; height: 24px;">5.156643332</td>
<td style="width: 13.6754%; height: 24px;">519.60119013</td>
</tr>
</tbody>
</table>
<br/>
<a href="https://yanbin.blog/wp-content/uploads/2020/04/bubble_insert_select_compare-1.png"><img class="aligncenter wp-image-10240" src="https://yanbin.blog/wp-content/uploads/2020/04/bubble_insert_select_compare-1-800x274.png" alt="" width="900" height="308" /></a><br/><br/>
插入排序也是对有序列表友好的，免去了移动元素的消耗。插入排序比选择要快的很大一方面是由于交换比逐个移动列表元素要快，但估计对于链接的排序又是另一回事了。更有序时，选择排序反而慢了，对于无序列表，冒泡效率低下，这三种排序方式相比而言，插入排序稍有些优势。对于同样是 O(n<sup>2</sup>) 复杂度的排序方式，减少元素的交换或移动的次数，或变交换为移动元素也能对效率有所提升。<br/><br/>
接下来会有一种对插入排序的增强版本，Shell 排序，对列表跳跃方式分段进行插入排序，最后一次完整插入排序，目的也是减少了元素的移动次数而得以优化。
