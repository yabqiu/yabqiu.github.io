---
title: 细数 DB2 数据库的 Identity 字段
url: /talk-db2-database-identity-column/
date: 2022-10-03T12:06:06-05:00
featured: false
draft: true
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/https://yanbin.blog/wp-content/uploads/2022/10/db2_logo.png"
categories:
  - Database
tags: 
  - database
  - DB2
comment: true
codeMaxLines: 50
# additional
wpPostId: 12788 
wpStatus: publish
views: 664
lastmod: 2022-10-06T12:09:27-05:00
---

每种数据都有自己独特的自增列的声明方式，如 Oracle 的 Sequence, SQL Server 的 Identity, MySQL 的 auto_increment, PostgreSQL 的 Sequence 或 Serial。和 PostgreSQL 类似，DB2 也提供两种自增列的声明方式，它们是 Sequence 和 Identity。而本文主要着墨于 DB2 的 Identity 字段，并讲述它与 Sequence 的某种联系，以及它对数据表的导入的影响。<br/><br/>
<h3>DB2 的 Sequence</h3><br/><br/>
在 DB2 中声明一个 Sequence 与表的 Identity 字段的参数差不多，我们可以看作 Identity 是一个内联的 Sequence。先来看如何创建一个序列<!--more--><br/><br/>
<pre class="lang:default decode:true">CREATE SEQUENCE ORDER_SEQ
  START WITH 1
  INCREMENT BY 1
  NO MAXVALUE
  NO CYCLE
  CACHE 24;</pre>
<br/>
使用的话，比如 insert, update 记录时用它的 <code>NEXT VALUE FOR ORDER_SEQ</code> 值，我们也可以查询到它的下一个值<br/><br/>
<pre class="lang:default decode:true ">SELECT NEXT VALUE FOR ORDER_SEQ FROM SYSIBM.SYSDUMMY</pre>
<br/>
NEXT VALUE 也会让相应序列往下走一值，这和 Oracle 序列的使用方式是一样的。<br/><br/>
声明一个序列的参数这里就不细说了，通过不同的参数可以实现升序或降序的，如果指定了 MAXVALUE，NO CYCLE 的话会出现序列耗尽的情况，而 CYCLE 的话会重复使用序列值, CACHE 是在高并发时预先产生序列值。<br/><br/>
我们随时可以通过下面的查询获得序列的配置<br/><br/>
<pre class="lang:default decode:true">SELECT * from sysibm.SYSSEQUENCES WHERE SEQNAME='&lt;SEQ_NAME&gt;'</pre>
<br/>
比如我们以最简单的方式创建一个序列<br/><br/>
<pre class="lang:default decode:true ">CREATE SEQUENCE ORDER_SEQ</pre>
<br/>
然后用上面的语句查查询得到该序列的参数为<br/><br/>
<pre class="lang:default decode:true">Name           |Value                     |
---------------+--------------------------+
LASTASSIGNEDVAL|                          |
SEQID          |20                        |
SEQNAME        |ORDER_SEQ                 |
INCREMENT      |1                         |
START          |1                         |
MAXVALUE       |2147483647                |
MINVALUE       |1                         |
CYCLE          |N                         |
CACHE          |20                        |
ORDER          |N                         |
ORIGIN         |U                         |
SEQTYPE        |S                         |</pre>
<br/>
IBM 官方的相关文档 <a href="https://www.ibm.com/docs/en/db2/11.5?topic=statements-create-sequence">CREATE SEQUENCE statement</a><br/><br/>
<h3>Identity 字段</h3><br/><br/>
大约是觉得在插入或更新记录时每次用 <code>next value for order_seq</code> 太麻烦，DB2 也可以直接声明一个带有 IDENTITY 关键字的自增字段，这样在插入记录时自动产生序列值。声明 IDENTITY 字段的格式为<br/><br/>
<pre class="lang:default decode:true ">column_name data_type
    GENERATED {ALWAYS|BY DEFAULT} AS IDENTITY
    [( identity_option )]</pre>
<br/>
这里的 identity_option 和创建 SEQUENCE 时的选项基本一致。<br/><br/>
现在来创建一个带有 IDENTITY 列的表<br/><br/>
<pre class="lang:default decode:true">CREATE TABLE ORDER(
    ID INTEGER NOT NULL GENERATED ALWAYS AS IDENTITY (
        START WITH 1
        NO MAXVALUE,
        CACHE 11
    ) PRIMARY KEY,
   
    NAME VARCHAR(64)
)</pre>
<br/>
插入记录时不用指定 <code>ID</code> 字段<br/><br/>
<pre class="lang:default decode:true ">INSERT INTO ORDER(NAME) VALUES('apples')
INSERT INTO ORDER(NAME) VALUES('beef')</pre>
<br/>
查看表中的记录<br/><br/>
<pre class="lang:default decode:true ">SELECT * FROM ORDE<br/><br/>
ID|NAME  |
--+------+
 1|apples|
 2|beef  |</pre>
<br/>
自动产生了 <code>ID</code> 值 1, 2, ...<br/><br/>
由于我们指定了 <code>GENERATED ALWASY</code>, 所以不能手工指定 <code>ID</code> 值，如果试图执行<br/><br/>
<pre class="lang:default decode:true">INSERT INTO ORDER(ID, NAME) VALUES(3, 'nuts')</pre>
<br/>
会得到错误<br/><br/>
<blockquote>
SQL Error [428C9]: A value cannot be specified for column "ID" which is defined as GENERATED ALWAYS.. SQLCODE=-798, SQLSTATE=428C9, DRIVER=4.26.14
</blockquote>
<br/>
如果改为 <code>GENERATED BY DEFAULT</code>, 则插入记录时可使用指定的 <code>ID</code> 值，未指定时则自动生成。但 <code>GENERATED BY DEFAULT</code> 可能造成主键或唯一值冲突，比如我们把前面的创建表 <code>ORDER</code> 的语句改为<br/><br/>
<pre class="lang:default decode:true">DROP TABLE ORDER;<br/><br/>
CREATE TABLE ORDER(
    ID INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY (
        START WITH 1
        NO MAXVALUE,
        CACHE 11
    ) PRIMARY KEY,
   
    NAME VARCHAR(64)
)</pre>
<br/>
接下来我们将要做的测试就是先插入一个指定 ID 为 3 的记录，然后插入后续的记录时用自动的 ID，那么它会从 3 开始，还是仍然从 1 开始呢？如果从 1 开始的话，碰到 3 时怎么办，由于 <code>ID</code> 是个主键，它会跳过 3 还是发生主键冲突呢？<br/><br/>
在测试之前先了解一个函数 <code>IDENTITY_VAL_LOCAL()</code>, 它会得到当前连接会话中上一次插入到  IDENTITY 列上的值，通常下一个值就是它 + 1 的值。依次运行下面的语句，每条语句后显示执行完后表中的记录，以及 IDENTITY_VAL_LOCAL() 值<br/><br/>
<pre class="lang:default decode:true">INSERT INTO ORDER(ID, NAME) VALUES(3, 'order0'); -- id:3; IDENTITY_VAL_LOCAL(): 3
INSERT INTO ORDER(NAME) VALUES('order1');  -- id:3,1; IDENTITY_VAL_LOCAL(): 1 
INSERT INTO ORDER(NAME) VALUES('order2');  -- id:3,1,2; IDENTITY_VAL_LOCAL(): 2
INSERT INTO ORDER(NAME) VALUES('order3');  -- id:3,1,2; IDENTITY_VAL_LOCAL(): 3, 插入失败
INSERT INTO ORDER(NAME) VALUES('order4');  -- id:3,1,2;4, IDENTITY_VAL_LOCAL(): 4</pre>
<br/>
从测试的结果来看，当 IDENTITY 为 <code>GENERATED BY DEFAULT</code> 时，指定了该列的值就用它，没有指定的仍然从原来的位置开始按部就班的产生 ID，而不管当前表中是否存在该 ID 值，所以在插入 <code>order3</code> 时试图使用 <code>ID:3</code>  时产生主键冲突，错误信息是<br/><br/>
<blockquote>
<p class="p1"><span class="s1">SQL Error [23505]: One or more values in the INSERT statement, UPDATE statement, or foreign key update caused by a DELETE statement are not valid because the primary key, unique constraint or unique index identified by "1" constrains table "USER1.ORDER" from having duplicate values for the index key.. SQLCODE=-803, SQLSTATE=23505, DRIVER=4.26.14</span></p>
</blockquote>
<br/>
但是不是很要紧，在插入下一条记录时不会再坚持用 <code>ID:3</code>, 而是跳到了 <code>ID:4</code>。所以一个保险的操作是捕获这里的 <code>unique constraint</code> 异常，不断重试就能找到下一个可用的 ID<br/><br/>
<h3>IDENTITY 与 SEQUENCE 的关系</h3><br/><br/>
延续上一个问题，当设置 <code>GENERATED BY DEFAULT</code> 为什么会产生主键(唯一键)冲突，而冲突完之后就相安无事了呢？这就是本文要从 Sequence 说起，而且 Sequence 和 Identity 的选项又那么相近的原因，说到底，表的 Identity 列本质上就是对应一个 Sequence。<br/><br/>
注意到前面我们创建表 ORDER  时的 ID 列 Identity 的 CACHE 是 11, 我们根据这个特征到系统表 <code>sysibm.SYSSEQUENCES</code> 看能不能找到相应的 Sequence<br/><br/>
<pre class="lang:default decode:true">SELECT * from sysibm.SYSSEQUENCES WHERE CACHE = 11<br/><br/>
Name           |Value                     |
---------------+--------------------------+
LASTASSIGNEDVAL|11                        |
SEQID          |27                        |
SEQSCHEMA      |USER1                     |
SEQNAME        |SQL220930185534460        |
INCREMENT      |1                         |
START          |1                         |
MAXVALUE       |2147483647                |
MINVALUE       |1                         |
CYCLE          |N                         |
CACHE          |11                        |
ORDER          |N                         |
ORIGIN         |S                         |
SEQTYPE        |I                         |
DATATYPEID     |24                        |</pre>
<br/>
有了，就是 <code>SQL220930185534460</code> 序列，它是用创建时的时间截来命名的。掌握了 Identity 与  Sequence 的关系后，就能很好的帮助我们理解 DB2 在插入 Identity 列的行为了，比如<br/><br/>
<pre class="lang:default decode:true">INSERT INTO ORDER(NAME) VALUES('order5');</pre>
<br/>
就相当于是下面的操作<br/><br/>
<pre class="lang:default decode:true ">INSERT INTO ORDER(ID, NAME) VALUES(NEXT VALUE FOR SQL220930185534460, 'order5');</pre>
<br/>
<blockquote>
注：作为 Identity 列背后的匿名 Sequence, DB2 不会让我们直接用它的 NEXT VALUE FOR 它的<br />
SQL Error [428FB]: Sequence "USER1.SQL220930185534460" cannot be used as specified.. SQLCODE=-20142, SQLSTATE=428FB, DRIVER=4.26.14
</blockquote>
<br/>
所以不管上面的插入语句成功与否，对应的序列总是要往下走一位，直到不再有重复 ID 为止<br/><br/>
至于 Identity 的 <code>GENERATED ALWAYS</code> 和 <code>GENERATED BY DEFAULT</code>，只是用来限制插入记录时是否能提供自己的 ID 值，如果自己提供了 ID 值的话，将不会调用 <code>NEXT VALUE FOR SQL220930185534460</code> 产生序列值，所以序列仍保持在原来的位置上，后续插入记录时就可能会产生重复 ID。<br/><br/>
<h3>调整 IDENTITY</h3><br/><br/>
当我们的 Identity  列设置为 <code>GENERATED BY DEFAULT</code> 时，插入记录时自己提供了自己的 ID 值，如何避免重复键冲突呢？比如说创建的 Identity 列从 1 开始，先手工插入了一批 ID 从 1 到 100 的记录，将来再添加记录未提供 ID 时将又会从 1 开始生成 ID, 势必产生重复的 ID。要是该字段设置成了主键或唯一键，插入将会失败，所以我们有一种比较粗鲁的办法就是，不断的尝试，直到找到可接受的 ID 为止。大概的思路如下<br/><br/>
<pre class="lang:default decode:true">def add(name):
    try:
        cursor.execute('insert into order(name) values(%s)', name)
    except UniqueConstraintException:
        add(name)</pre>
<br/>
更简单的方法就是修改表，设置序列的下一个起始值为大于当前表中的最大 ID 值。我们做如下的操作<br/><br/>
<pre class="lang:default mark:4-6 decode:true ">INSERT INTO ORDER(ID, NAME) VALUES(100, 'order5');       -- 插入记录 ID: 100
SELECT IDENTITY_VAL_LOCAL() AS id FROM SYSIBM.SYSDUMMY1  -- 100<br/><br/>
ALTER TABLE ORDER         
  ALTER COLUMN ID         
  RESTART WITH 101;<br/><br/>
SELECT IDENTITY_VAL_LOCAL() AS id FROM SYSIBM.SYSDUMMY1  -- 100
INSERT INTO ORDER(NAME) VALUES('order6');       -- 插入记录 ID: 101
SELECT IDENTITY_VAL_LOCAL() AS id FROM SYSIBM.SYSDUMMY1  -- 101
</pre>
<br/>
当修改表的 ID 列 <code>RESTART WITH 101</code> 时，下次不提供 ID 值插入记录时 ID 就是 101, 后面就是 102, 103, ...<br/><br/>
再来看一下 <code>RESTART WITH 101</code> 后序列本身的选项值是否有变<br/><br/>
<pre class="lang:default decode:true">SELECT * from sysibm.SYSSEQUENCES WHERE CACHE = 11;<br/><br/>
Name           |Value                     |
---------------+--------------------------+
LASTASSIGNEDVAL|111                       |
SEQID          |27                        |
SEQSCHEMA      |USER1                     |
SEQNAME        |SQL220930185534460        |
INCREMENT      |1                         |
START          |1                         |
MAXVALUE       |2147483647                |</pre>
<br/>
还是老样子，<code>START</code> 仍然为 1, 我们并不需要修改 <code>START</code> 的值。<br/><br/>
或者同时修改为 <code>GENERATED ALWAYS</code><br/><br/>
<pre class="lang:default decode:true">ALTER TABLE ORDER         
  ALTER COLUMN ID         
  SET GENERATED ALWAYS RESTART WITH 10</pre>
<br/>
我们也可以删除 Identity<br/><br/>
<pre class="lang:default decode:true">ALTER TABLE ORDER
  ALTER COLUMN ID
  DROP IDENTITY;</pre>
<br/>
删除后还想再加回来<br/><br/>
<pre class="lang:default decode:true "> ALTER TABLE ORDER
    ALTER COLUMN ID
     SET GENERATED ALWAYS AS IDENTITY
       (START WITH 500 
       INCREMENT BY 1 
       NOCYCLE)</pre>
<br/>
<h3>导入表数据与 Identity 列</h3><br/><br/>
作为一个非主流数据库，DB2 是本人迄今碰到的最难管理，维护，导出，导入的数据库。DB2 提供的数据库迁移工具很多，但都无法直接满足我从 Windows 平台下 DB2 导出数据到 Linux 平台下 DB2 的需求。导出，导入数据主要有以下三种方式<br/><br/>
<h4>db2 backup/restore</h4><br/><br/>
db2 backup/restore 可以进行完整数据库的备份和恢复，但不能进行跨平台迁移数据库操作，而且进行 offline, online 的备份恢复操作需要先对数据库进行一些操作。本人尝试过 offline 的 backup/restore，需要先断开数据库的所有连接，停止数据库，启动到受限访问模式，完后重新启动到正常模式。<br/><br/>
<h4>db2move export/import</h4><br/><br/>
db2move 只导出导入表数据，schema 需要用 db2lookup 单独导出，所以导入数据库前要用 <code>db2 -tvf orders_ddl.sql</code> 应用 schema。在导入数据时会受到表外键与 Identity 的限制，有外键时需严格遵循主表从表的顺序导入, 有 Identity 列的话需修改为 GENERATED BY DEFAULT, 完后再 RESTART WITH 新值<br/><br/>
<h4>db2 export/import/load</h4><br/><br/>
它和 db2move export/import 很类似，schema 也需要用  db2lookup 单独处理。导出导入表数据，同样需修改 Identity 列为 GENERATED BY DEFAULT，最后用 RESTART WITH 修改 Identity 列。 但对有外键约束的表可强行用 load 导入数据，只是会导致表暂时不可用，最后用 db2 set integrity for ORDER immediate checked 激活表。<br/><br/>
修改 Identity 列为 GENERATED ALWAYS 或 GENERATED BY DEFAULT 的语句为<br/><br/>
<pre class="lang:default decode:true">ALTER TABLE ORDER         
  ALTER COLUMN ID         
  SET GENERATED ALWAYS;   -- SET GENERATED BY DEFAULT
</pre>
<br/>
或同时用 <code>RESTART WITH</code> 重置起始值<br/><br/>
关于 DB2 数据库的迁移，导入/导出的具体操作就不在本文的范畴了。<br/><br/>
链接：<br/><br/>
<ol>
    <li><a href="https://www.ibm.com/docs/en/db2-for-zos/12?topic=programs-identity-columns">Identity columns</a></li>
    <li><a href="https://www.ibm.com/docs/en/i/7.5?topic=language-creating-altering-identity-column">Creating and altering an identity column</a></li>
    <li><a href="https://www.ibm.com/docs/en/db2/11.5?topic=functions-identity-val-local">IDENTITY_VAL_LOCAL scalar function</a></li>
</ol>
