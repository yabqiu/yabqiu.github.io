---
title: 记录自己常用的一些 Linux Shell 脚本
url: /frequently-used-linux-shell-script/
date: 2020-03-21T18:57:41-05:00
featured: false
draft: false
type: post
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/https://unmi.cc/wp-content/uploads/2018/05/linux-logo.png"
categories:
  - Linux/Unix
tags: 
  - Shell
  - grep
  - awk
  - cut
comment: true
codeMaxLines: 50
# additional
wpPostId: 9868 
wpStatus: publish
views: 784
lastmod: 2022-03-23T15:11:45-05:00
---

常要在 Linux 下分析日志或其他类型的文件，基本用的命令也就 grep, awk, sed, cut, vim, cat, find, xargs, tail, more 或 less。本人工作平台为 Mac OS X, 而 Mac 下的 grep, sed, awk 的行为与 Linux 下的 GNU 标准的相应命令是有差别的, 所以我总是在 Mac 下安装 GNU 的 grep, sed, awk 等命令来替代系统默认的。<br/><br/>
比如安装下面的命令<br/><br/>
<blockquote>
$ brew install findutils gawk gnu-sed grep
</blockquote>
<br/>
以上会安装 GNU 的 find, awk, sed 和 grep 命令，使用时要加个前缀，如 gfind, gawk, gsed 或 ggrep，也可以设置别名或符号链接来替换掉系统的相应命令。<br/><br/>
注： <code>brew install coreutils</code> 会安装众多 Linux 下的基本命令替代品，ls, cat, cut 都在其中，使用它也是要加上前缀 <code>g</code>, 如 gls, gcut 等。<br/><br/>
以下 grep, find, grep, sed 以 GNU 的行为为准。<!--more--><br/><br/>
<h3>grep 相关的命令</h3><br/><br/>
用了这么久的 grep, 反正它是用来查找字符串的，还能用正则表达式匹配。那么它的全名是什么呢？Global Regular Expression Print (GREP)。<br/><br/>
<h4><strong>高亮显示匹配的字符串</strong></h4><br/><br/>
这个效果很重要，不然显示出了字符串还不清楚哪里匹配了，所以最好用个 alias<br/><br/>
<blockquote>
grep="grep --color=auto --exclude-dir={.bzr,CVS,.git,.hg,.svn}"
</blockquote>
<br/>
<a href="https://yanbin.blog/wp-content/uploads/2020/03/grep-color.png"><img class="aligncenter wp-image-9870" src="https://yanbin.blog/wp-content/uploads/2020/03/grep-color.png" alt="" width="192" height="87" /></a><br/><br/>
以下各种使用方式<br/><br/>
<blockquote>
$ cat planets.txt | grep -i e      # 忽略大小写匹配<br />
$ cat planets.txt | grep -e "[p|P]"  # 使用正则表达式匹配<br />
$ cat planets.txt | grep -P -e "[p|P]{1,3}"  # 使用 Perl 风格正则表达式
</blockquote>
<br/>
<strong>搜索文件</strong><br/><br/>
<blockquote>
$ grep -r --include "*.java" "print" src   # 从 src 目录中的 *.java 中递归查找 <code>print</code> 字符串
</blockquote>
<br/>
<strong><span style="font-size: 12pt;">输出捕获的分组</span></strong><br/><br/>
打印出匹配的字符串并不需总是要用 <code>awk</code> 分隔再打印，用 <code>grep -oP</code> 或 <code>egrep -o</code> 会更方便，如<br/><br/>
<blockquote>
$ echo 'employee_id=1234' | egrep -o '\d+'<br />
1234<br />
$ echo 'employee_id=1234' | grep -oP 'employee_id=\K(\d+)'                       # Mac OS X 下可用   ggrep, P 为 Perl 正则表达式, \K 是 Perl 用来实现 look-behind, 如从 "=" 开始<br />
1234<br />
$ echo 'employee_id=1234' | grep -oP '(?&lt;==)(\d+)'                                       # 另一种 lookbehind 方式， '(?&lt;==)' 中的 <code>?&lt;=</code> 指定从后它后的 <code>=</code> 号开始<br />
1234<br />
$ echo 'foo something bar' | grep -oP '(?&lt;=foo )\w+(?= bar)'                        # 用这个了理解一下 grep -P  Perl 的 look-behind 和 look-ahead<br />
something
</blockquote>
<br/>
其他几种输出分组的方式<br/><br/>
<blockquote>
$ echo 'employee_id=1234' | sed 's/^.*employee_id=\([0-9]*\).*$/\1/'<br />
1234<br />
$ echo employee_id=1234 | sed -E 's/employee_id=([0-9]+)/\1/g'                 # -E extended regex<br />
1234<br />
$ echo 'employee_id=1234' | awk -F= '{print $2}'<br />
1234<br />
$ foo='employee_id=1234'                                                                                        # 以下是 bash 的方式<br />
$ echo ${foo%%=*}<br />
employee_id<br />
$ echo ${foo#*=}<br />
1234
</blockquote>
<br/>
参考：<a href="https://stackoverflow.com/questions/18892670/can-not-extract-the-capture-group-with-neither-sed-nor-grep/18892742">Can not extract the capture group with neither sed nor grep</a><br/><br/>
<h3>控制台的内容直接送到 vim 编辑器中</h3><br/><br/>
未打开 vim, 可用管道操作 <code>xxx | vi -</code> 如：<br/><br/>
<blockquote>
$ ls -l | grep py | vi -      # 这样会打开 vim 编辑器，显示 <code>ls -l |grep py</code> 命令的输出内容
</blockquote>
<br/>
如果打开了 vim, 那么在 vim 中命令模式中输入<br/><br/>
<blockquote>
: read !ls -l | grep py     # 就会在当前 vim 编辑器中添加 <code>ls -l | grep py</code> 命令的输出内容
</blockquote>
<br/>
打开 vim 的同时打开语法高亮, 如果 ~/.vimrc 中已打开语法高亮，但 <code> | vi -</code> 没有告知文件类型，所以需要 vim 启动时加上 set syntax=json 或 set filetype=json <br/><br/>
<blockquote>
$ echo '{"age": 28}' | vi - -c 'set syn=json'      # 或者 set syntax=json, set filetype=json 或 set ft=json<br />
$ echo '{"age": 18}' | vi -
</blockquote>
<br/>
 也可以进入了 vim 后，在它的命令行下设置  :set <span style="color: #ff0000;">syn</span>tax=json 或  :set <span style="color: #ff0000;">f</span>ile<span style="color: #ff0000;">t</span>ype=json, 或简单的用 :set syn=json 或 :set ft=json。<br/><br/>
另外，假如用 vim 打开一个大文件，因为加载过多插件的因素滚动慢，可以用 <code>vi -u NONE bigfile.json</code> 来打开文件。<br/><br/>
<h3>切分字符串</h3><br/><br/>
这也用到的命令就是 cut 或 awk，cut 能力比较弱，只能用单字符切割字符串，看如下几个使用方式<br/><br/>
<blockquote>
$ echo "aa,bb,,cc:dd" | cut -d, -f1<br />
aa                                                               # -d 后指定用 <code>,</code> 号分隔，-f 输出哪个字段<br />
$ echo "aa,bb,,cc:dd" | cut -d, -f1 -f4   # 或者用 -f1,4<br />
aa,cc:dd                                                    # 输出多个字段时又会用 -d 指定的分隔符连接<br />
$ echo "aa,bb,,cc:dd" | cut -d, -f4 | cut -d: -f1<br />
cc                                                                #由于不支持模式分隔，所以要进行两次切分
</blockquote>
<br/>
另一种方法就是用 awk 命令，awk 简单是一个编程语言，它名字来源于它的三位作者的名字首字母(<strong>A</strong>ho, <strong>W</strong>einberger and <strong>K</strong>ernighan), 不是 awkward 的意思。它的功能还是很强，我们且在这里看看怎么分隔字符串<br/><br/>
<blockquote>
$ echo "aa,bb,,cc:dd" | awk -F "(,*)|:" '{print NF,$1,$2,$3,$4}'<br />
4 aa bb cc dd       # 共四个字符，且每个字段的内容，-F 中支持正则表达式                 
</blockquote>
<br/>
实际使用时应测试好它所支持的正则表达式的语法，以前好像还尝试过 awk 的正则表达式的切割功能，还以为需要用 Python 的实现类似的操作。<br/><br/>
曾经想过用 Python 的切分字符串的方式 (cut.py)<br/><br/>
<pre class="lang:default decode:true ">#!/usr/bin/env python<br/><br/>
import sys
from optparse import OptionParser
import re<br/><br/>
parser = OptionParser()
parser.add_option('-d', '--delimiter', default='\t')
parser.add_option('-f', '--fields')<br/><br/>
(options, args) = parser.parse_args()
indexes = [(int(i) - 1) for i in options.fields.split(',')]
regex = re.compile(options.delimiter)
for line in sys.stdin:
    fields = regex.split(line.rstrip())
    out = ' '.join([fields[i] for i in indexes])
    print(out)</pre>
<br/>
然后执行<br/><br/>
<blockquote>
$ echo "aa,bb,,cc:dd" | cut.py -d",+|:" -f1,2,4    # Python 的正则表达式也需多测试<br />
aa bb dd
</blockquote>
<br/>
<h3>输出匹配后的下一行</h3><br/><br/>
通常我们的需求是用  grep 查找到并输出匹配行，有时我们想输出匹配行的下一行，或下几行，比如说对 ini 文件<br/><br/>
<blockquote>
[memory]<br />
max=8G
[bandwidth]<br />
max=4G
</blockquote>
<br/>
我们想要找到含有 [memory] 的下一行的 max 值而不是别处的 max<br/><br/>
可以用  awk 命令<br/><br/>
<blockquote>
cat test.ini | awk '/\[memory\]/{getline;print}'   #\[ 为转义 [ 符号<br />
max=8G
</blockquote>
<br/>
或者用 sed 命令(sed 是什么？<strong>S</strong>tream <strong>ED</strong>itor, 流编程器，也可说是像 awk 一样另成一种编程语言<br/><br/>
<blockquote>
cat test.ini | sed -n '/[memory]/{n;p;}'   # 很像 awk 的  getline;print<br />
max=8G
</blockquote>
<br/>
<a href="https://www.gnu.org/software/sed/manual/sed.html#sed-commands-list">sed 中的命令</a>非常精简，都用单字母，如 a: append, s: substitue, n: next, p: print。如果要用来处理字符串替换的操作 sed 就是最好的编程工具。<br/><br/>
grep 本身也能完成类似的功能<br/><br/>
<blockquote>
$ cat test.ini | grep -A1 '\[memory\]'    # 往下多显示一行  -A, --after-context=NUM 从当前往下多少行，往前是 -B<br />
[memory]<br />
max=8G
</blockquote>
<br/>
前面说过 awk  本身就是个编程语言的，所以还能加入更多代码<br/><br/>
<blockquote>
$ cat test.ini | awk '/\[memory\]/{for(i=0;i&lt;4;i++)getline;print $0}'<br />
max=4G
//或者
$ cat test.ini | awk -v lines=4 '/\[memory\]/{for(i=lines;i;--i) getline; print $0}'<br />
max=4G
</blockquote>
<br/>
awk 和 sed 是可以直接读取文件的，所以前面的命令可以不用 cat test.ini 到它的管道操作，而可以<br/><br/>
<blockquote>
$ awk '/\[memory\]/{for(i=0;i&lt;4;i++)getline;print $0}' test.ini<br />
$ sed -n '/[memory]/{n;p;}' test.ini
</blockquote>
<br/>
<h3>sort 命令按某列排序</h3><br/><br/>
sort 命令可以帮我们对文本行排序，默认以整行字符串为比较单位，主要参数有<br/><br/>
<ol>
    <li>-n:  --numberic-sort, 比较数字大小而非字符串来排序</li>
    <li>-r：--reverse, 逆序排列</li>
    <li>-f： --ignore-case, 忽略大小写排序</li>
</ol>
<br/>
这儿我们了解另一种排序需求，即按文件中某一列进行排序，如果有如下文件 planets.txt, 内容为<br/><br/>
<pre class="lang:default decode:true ">Moon,3
Sun,1
Earth,2</pre>
<br/>
我们想要按第二列进行序列后输出全部内容，那么命令为<br/><br/>
<blockquote>
$ sort -t, -k2 planets.txt<br />
Sun,1<br />
Earth,2<br />
Moon,3
</blockquote>
<br/>
解析：<br/><br/>
<ol>
    <li>-t: --field-separator, 以逗号为分割符, 默认是以空格分割</li>
    <li>-k2: --key, 先取第二列为排序依据</li>
</ol>
<br/>
除此之外，sort 还有以下两个有意思的功能<br/><br/>
<ol>
    <li>-R: --random-sort, 随机打乱顺序</li>
    <li>-u: --unique, 去重功能，从此告别 sort | uniq 这样的管道操作</li>
</ol>
<br/>
看一下 -u 去重的功能，修改 planets.txt 内容如下<br/><br/>
<pre class="lang:default decode:true">Moon,3
Sun,1
Earth,2
XXX,1</pre>
<br/>
<blockquote>
$ sort -t, -k2 -u planets.txt<br />
Sun,1<br />
Earth,2<br />
Moon,3
</blockquote>
<br/>
在用 -t, -k2 时还是按照重复列来去重的。<br/><br/>
<h3>批处理利器 xargs 命令</h3><br/><br/>
提起 xargs 命令时让人不禁想起 find 这一绝配，通常是 find 找到某些符合条件的文件后用管道传递给  xargs  去批量操作，有时也会 find -exec 命令来操作。比如<br/><br/>
<blockquote>
$ find . -type f -size +800M -exec rm {} \;                         //或<br />
$ find . -type f -size +800M -exec rm {} +
</blockquote>
<br/>
除此之外也会用到 xargs 命令与 find 配合<br/><br/>
<blockquote>
$ find . | xargs -0 rm -f<br />
$ find . -type f | xargs -I {} cp {} /var/www 
</blockquote>
<br/>
上面第一个命令，找到的内容是放到 <code>rm -f</code> 后面，可以不用 <code>{}</code> 的形式;  如果不加 <code>-0</code> (数字零)参数，rm 删除太多文件时会出现 Argument list too long 的错误。第二个命令因为内容放在 <code>cp</code> 命令中间，所以要用 <code>{}</code> 点位符; 同样的，如果操作的文件太多，在 xargs  命令中也要加上  <code>-0</code> 参数。<br/><br/>
除此之外，xargs  还能把单行转成多行<br/><br/>
<blockquote>
$ cat &lt;&lt;EOF | xargs<br />
> a b c d<br />
> e f<br />
> g<br />
> EOF<br />
a b c d e f g
</blockquote>
<br/>
更多功能见文后的链接。<br/><br/>
链接：<br/><br/>
<ol>
    <li><a href="https://www.topbug.net/blog/2013/04/14/install-and-use-gnu-command-line-tools-in-mac-os-x/">Install and Use GNU Command Line Tools on macOS/OS X</a></li>
    <li><a href="https://apple.stackexchange.com/questions/69223/how-to-replace-mac-os-x-utilities-with-gnu-core-utilities">How to replace Mac OS X utilities with GNU core utilities?</a></li>
    <li><a href="https://man.linuxde.net/xargs">xargs命令</a></li>
</ol>
