---
title: Flask 和  Vue.js 开发及整合部署实例
url: /flask-vue-js-integration-dev-deploy/
date: 2020-07-01T03:58:13-05:00
featured: false
draft: true
type: post
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/https://yanbin.blog/wp-content/uploads/2020/07/flask-logo.png"
categories:
  - Vue.js
  - Flask
tags: 
  - Vue
  - Flask
comment: true
codeMaxLines: 50
# additional
wpPostId: 10309 
wpStatus: publish
views: 6127
lastmod: 2023-03-02T11:15:42-06:00
---

想做些简单的 Web 工具，首先想到的是 Flask + Vue.js, 当然可以完全用 Flask 自己的页面模板 Jinja2, 但一个网站项目不能享受到像 Vue.js, React 类似框架的灵活性真是太可惜了。于是 Flask 只专注于 API, 页面逻辑全用 Vue.js 的组合就成了我的首选，Flask 方面还能进一步选择 FlaskRESTful 框架。还需做得更漂亮的话，CSS 框架可选择 Bootstrap 或与 Vue 紧密集成的 BootstrapVue, 这是后话。<br/><br/>
本文主要参考 <a href="https://zhuanlan.zhihu.com/p/76588212">Flask和Vue.js构建全栈单页面web应用【通过Flask开发RESTful API】</a>的前部分，英文原文在这里 <a href="https://testdriven.io/blog/developing-a-single-page-app-with-flask-and-vuejs/">Developing a Single Page App with Flask and Vue.js</a>。<br/><br/>
开发过程中我们可以保持 Flask 和  Vue.js 为单独的两个项目，并启动各自的服务，比如 Flask 是 http://localhost:5000, Vue.js 项目通过 <code>npm run serve</code> 启动在 http://localhost:8080，借助于 node js 的功能，修改 Vue.js 项目的内容能够自动刷新网页。要是开发中把静态文件全放在  Flask 项目中，那么任何对静态文件的修改都必须重启 Flask  服务。虽然 Debug 模式启动的 Flask 在看到它的目录中有任何修改时也能自动重启，但对静态文件的修改重启 Flask 没这个必要性。 <br/><br/>
但部署时需进一步整合，最终只需要启动 Flask  服务，而无须两个，方便部署。如果是以 Docker 容器的方式发布，使用 docker-compose 来编排两个容器来发布也还算不错。更专业的部署方式应该是 Vue.js 的静态内容放到专门的 Web 服务器，如  Apache/Nginx 中，Flask 也通过 wsgi 与 Web 服务器集成起来。<!--more--><br/><br/>
介于原文中所用的 Vue CLI 稍稍显老，所以实践中也有些区别，先注明本文写作时所依赖的各主要组件版本<br/><br/>
<ul>
    <li>Vue v2.6.11</li>
    <li>Vue CLI v4.6.6</li>
    <li>Node v14.4.0</li>
    <li>npm v6.14.4</li>
    <li>Flask v1.1.2</li>
    <li>Python v3.7</li>
</ul><br/><br/>
<h3>创建 Flask 项目</h3><br/><br/>
创建项目目录<br/><br/>
<blockquote>
$ mkdir flask-vue-app<br />
$ cd flask-vue-app
</blockquote>
<br/>
接下来创建 Python 虚拟环境<br/><br/>
<blockquote>
$ python3.7 -m venv .venv<br />
$ source .venv/bin/activate
</blockquote>
<br/>
安装 Flask 和 Flask-CORS 扩展，前面说过，由于开发中启动了两个服务，需要跨域访问服务，所以要用到 Flask-CORS<br/><br/>
<blockquote>
(.venv) $ pip install flask-cors
</blockquote>
<br/>
Flask 本身会被自动安装，当前日期为 2020-06-30, 所安装的 flask-cors 版本为 3.0.8， Fask 为 1.1.2。也可以锁定版本来安装扩展，如  pip install flask-cors==3.0.8。现在查看下所有的第三方依赖<br/><br/>
<blockquote>
$ pip freeze<br />
click==7.1.2<br />
Flask==1.1.2<br />
Flask-Cors==3.0.8<br />
itsdangerous==1.1.0<br />
Jinja2==2.11.2<br />
MarkupSafe==1.1.1<br />
six==1.15.0<br />
Werkzeug==1.0.1
</blockquote>
<br/>
有需要的话，保存为 requirements.txt 放到版本服务器上<br/><br/>
现在在 flask-vue-app 下创建一个  backend 目录，并在其中创建文件 app.py, 文件目录结构是<br/><br/>
<pre class="lang:default decode:true ">flask-vue-app
└── backend
    └── app.py</pre>
<br/>
app.py 的内容为<br/><br/>
<pre class="lang:default decode:true">from flask import Flask, jsonify
from flask_cors import CORS<br/><br/>
DEBUG = True<br/><br/>
app = Flask(__name__)
app.config.from_object(__name__)<br/><br/>
CORS(app, resources={r'/*': {'origins': '*'}})<br/><br/>

@app.route('/api/ping', methods=['GET'])
def ping_pong():
    return jsonify('pong!')<br/><br/>

@app.route('/')
def index():
    return app.send_static_file('index.html')<br/><br/>

@app.route('/&lt;path:fallback&gt;')
def fallback(fallback):       # Vue Router 的 mode 为 'hash' 时可移除该方法
    if fallback.startswith('css/') or fallback.startswith('js/')\
            or fallback.startswith('img/') or fallback == 'favicon.ico':
        return app.send_static_file(fallback)
    else:
        return app.send_static_file('index.html')<br/><br/>

if __name__ == '__main__':
    app.run()
</pre>
<br/>
简单说明一下上面的代码<br/><br/>
<ol>
    <li>CORS(app, resources={r'/*': {'origins': '*'}}) 允许来自于 Vue 的跨域访问请求</li>
    <li>定义以 <code>/api/</code>* 开头的 Flask 的路由，由 Flask 来处理</li>
    <li><code>/</code> 请求直接发送一个静态文件 <code>/index.html</code>，由于不会用到 Flask 的模板系统，所以也就无需调用  <code>render_template()</code> 方法去渲染。</li>
    <li>后面会将到在 <code>backend</code> 目录中会建立一个到 Vue.js 项目打包后的 dist 目录的符号链接 <code>static</code>, 所以其中有 <code>index.html</code> 等</li>
    <li>@app.rout('/&lt;path:fallback&gt;') 里是个关键，凡是 Flask 未定义的路由都会落到这里来。如果访问的是 <code>static(dis)</code> 中的 css, js, img 或 favicon.ico 文件，直接送出内容，其他的请求转到 Vue 的入口 <code>index.html</code>, 最后将由 Vue 中定义的路由来处理</li>
    <li>如果 Vue 的 Router 工作在 hash 模式的话，fallback 方法可以不要，因为 <code>/#/home</code> 到 <code>/#/about</code> 的切换本身不产生 HTTP 请求，Flask 只需要 <code>/</code> 一个路由进入 Vue 入口页面</li>
</ol>
<br/>
运行 Flask<br/><br/>
<blockquote>
(.venv) $ python backend/app.py
</blockquote>
<br/>
Flask 会在 localhost:5000 中启动服务，用 curl 命令验证<br/><br/>
<blockquote>
$ curl http://localhost:5000/api/ping<br />
"pong!"
</blockquote>
<br/>
<h3><a id="create-vue-project"></a>创建 Vue 项目</h3><br/><br/>
开始转到 Vue 项目来，将使用 Vue CLI 工具来生成它，首先是安装  Vue CLI<br/><br/>
<blockquote>
$ npm install -g @vue/cli
</blockquote>
<br/>
当前日期 2020-06-30, 安装后用 vue --version 看到的版本是 @vue/cli 4.4.6。安装时欲锁定版本用命令 npm install -g @vue/cli@4.4.6<br/><br/>
正式创建项目 frontend，在 <code>flask-vue-app</code> 目录下运行<br/><br/>
<blockquote>
$ vue create frontend                  # 选择 Manually select features, 接下回答几个问题
<a href="https://yanbin.blog/wp-content/uploads/2020/07/vue-create-questions.png"><img class="aligncenter wp-image-10313" src="https://yanbin.blog/wp-content/uploads/2020/07/vue-create-questions-800x161.png" alt="" width="695" height="140" /></a>
</blockquote>
<br/>
最后 flask-vue-app 的目录结构为<br/><br/>
<pre class="lang:default decode:true ">flask-vue-app
├── backend
│   └── app.py
└── frontend
    ├── README.md
    ├── babel.config.js
    ├── package-lock.json
    ├── package.json
    ├── public
    │   ├── favicon.ico
    │   └── index.html
    └── src
        ├── App.vue
        ├── assets
        │   └── logo.png
        ├── components
        │   └── HelloWorld.vue
        ├── main.js
        ├── router
        │   └── index.js
        └── views
            ├── About.vue
            └── Home.vue</pre>
<br/>
启动 Vue 服务<br/><br/>
<blockquote>
$ cd frontend<br />
$ npm run serve
</blockquote>
<br/>
打开浏览器访问 http://localhost:8080 会有一个  "Wellcome to Your Vue.js App" 的界面。后面对 frontend 项目的修改会自动刷新网页。<br/><br/>
下面是如何在 Vue.js(8080) 中调用到 Flask(5000) 的 <code>/api/ping</code> 服务，当前在 <code>frontend</code> 目录中<br/><br/>
创建 <code>src/components/Ping.vue</code> 文件，内容为<br/><br/>
<pre class="lang:default decode:true ">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;{{ msg }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;<br/><br/>
&lt;script&gt;
export default {
  name: 'Ping',
  data() {
    return {
      msg: 'Hello!',
    };
  },
};
&lt;/script&gt;</pre>
<br/>
编辑 <code>src/router/index.js</code> 文件，高亮行为新加的内容<br/><br/>
<pre class="lang:default mark:4,22-31 decode:true">import Vue from 'vue';
import VueRouter from 'vue-router';
import Home from '../views/Home.vue';
import Ping from '../components/Ping.vue';<br/><br/>
Vue.use(VueRouter);<br/><br/>
const routes = [
  {
    path: '/',
    name: 'Home',
    component: Home,
  },
  {
    path: '/about',
    name: 'About',
    // route level code-splitting
    // this generates a separate chunk (about.[hash].js) for this route
    // which is lazy-loaded when the route is visited.
    component: () =&gt; import(/* webpackChunkName: "about" */ '../views/About.vue'),
  },
  {
    path: '/ping',   # 用来调用 Flask 的 "/api/ping" API
    name: 'Ping',
    component: Ping,
  },
  {
    path: '/ping_xyz', # 这个用来测试，非 Flask 中定义的路由，可被 Vue 进行处理
    name: 'Ping',
    component: Ping,
  },
];<br/><br/>
const router = new VueRouter({
  mode: 'history',
  base: process.env.BASE_URL,
  routes,
});<br/><br/>
export default router;
</pre>
<br/>
对 <code>src/App.vue</code> 的 &lt;template&gt; 中的导航部分删除，内容变为<br/><br/>
<pre class="lang:default decode:true ">&lt;template&gt;
  &lt;div id="app"&gt;
    &lt;router-view/&gt;
  &lt;/div&gt;
&lt;/template&gt;</pre>
<br/>
浏览器中访问 http://localhost:8080/ping, "Hello!" 显示的还是 <code>src/components/Ping.vue</code> 中 data 的内容<br/><br/>
<a href="https://yanbin.blog/wp-content/uploads/2020/07/flask-vue-app-2.png"><img class="aligncenter wp-image-10315" src="https://yanbin.blog/wp-content/uploads/2020/07/flask-vue-app-2-800x157.png" alt="" width="510" height="100" /></a><br/><br/>
现在开始将  Ping.vue 与 Flask 的 <code>/api/ping</code> API 进行连接，Vue 中要用 Ajax 来访问，先要安装 axios，命令如下<br/><br/>
<blockquote>
$ npm install axios --save
</blockquote>
<br/>
目前安装的是 axios@0.19.2, 安装后可在 <code>package.json</code> 里看到 <code>dependencies</code> 中的 "axios": "^0.19.2"<br/><br/>
编辑 <code>src/components/Ping.vue</code> 文件，修改为<br/><br/>
<pre class="lang:default mark:2,11-26 decode:true ">&lt;script&gt;
import axios from 'axios';<br/><br/>
export default {
  name: 'Ping',
  data() {
    return {
      msg: '',
    };
  },
  methods: {
    getMessage() {
      const path = 'http://localhost:5000/ping';
      axios.get(path)
        .then((res) =&gt; {
          this.msg = res.data;
        })
        .catch((error) =&gt; {
          // eslint-disable-next-line
          console.error(error);
        });
    },
  },
  created() {
    this.getMessage();
  },
};
&lt;/script&gt;</pre>
<br/>
高亮行为新加的代码, 保存后 http://localhost:8080/ping 窗口中的内容自动刷新为<br/><br/>
<a href="https://yanbin.blog/wp-content/uploads/2020/07/flask-vue-app-3.png"><img class="aligncenter wp-image-10316" src="https://yanbin.blog/wp-content/uploads/2020/07/flask-vue-app-3-800x168.png" alt="" width="510" height="107" /></a><br/><br/>
<code>pong!</code> 消息是来自于 Flask 的 <code>/api/ping</code> API 的响应。由于我们前面是以 Debug 模式启动的 Flask backend 应用, 所以在控制台也能够看到一个对 <code>/api/ping</code> 的请求<br/><br/>
<blockquote>
127.0.0.1 - - [01/Jul/2020 02:53:06] "GET /api/ping HTTP/1.1" 200 -
</blockquote>
<br/>
访问 http://localhost:8080/ping_xyz 指向了同一个 Vue 组件，所以效果上与 http://localhost:8080/ping 是一样的。<br/><br/>
<h3>Flask 与 Vue.js  整合</h3><br/><br/>
开发的时候启动两个服务很方面，但我们希望在部署后只启动一个 Flask  服务，那么可以这样做<br/><br/>
首先用 npm 对 fronend 中的静态内容打包<br/><br/>
<blockquote>
$ npm run build
</blockquote>
<br/>
将会在 frontend 下生成 dist 目录，其下内容为<br/><br/>
<blockquote>
<span style="color: #339966;">css</span>      <span style="color: #000000;">favicon.ico</span>   <span style="color: #339966;">img</span>  <span style="color: #000000;">index.html</span>   <span style="color: #339966;">js</span>
</blockquote>
<br/>
绿色为目录, 文件目录树层次是<br/><br/>
<pre class="lang:default decode:true">flask-vue-app
├── backend
│   └── app.py
├── frontend
│   ├── README.md
│   ├── babel.config.js
│   ├── dist
│   │   ├── css
│   │   │   └── app.ee9fa358.css
│   │   ├── favicon.ico
│   │   ├── img
│   │   │   └── logo.82b9c7a5.png
│   │   ├── index.html
│   │   └── js
│   │       ├── about.838e43ea.js
│   │       ├── about.838e43ea.js.map
│   │       ├── app.38688cdc.js
│   │       ├── app.38688cdc.js.map
│   │       ├── chunk-vendors.6ddee4a6.js
│   │       └── chunk-vendors.6ddee4a6.js.map
│   ├── package-lock.json
│   ├── package.json
│   ├── public
│   │   ├── favicon.ico
│   │   └── index.html
│   └── src
│       ├── App.vue
│       ├── assets
│       │   └── logo.png
│       ├── components
│       │   ├── HelloWorld.vue
│       │   └── Ping.vue
│       ├── main.js
│       ├── router
│       │   └── index.js
│       └── views
│           ├── About.vue
│           └── Home.vue
└── requirements.txt</pre>
<br/>
dist 是由 npm run build 生成的<br/><br/>
这时候只要在 backend 中创建一个符号链接<br/><br/>
<blockquote>
$ ln -s ../front/dist static
</blockquote>
<br/>
创建后在 backend 目录中的内容为<br/><br/>
<blockquote>
-rw-r--r-- 1  yanbin root 690 Jul 1 01:01 app.py<br />
lrwxr-xr-x 1 yanbin root 16 Jun 30 22:33 <span style="color: #800080;">static</span> -&gt; ../frontend/dist
</blockquote>
<br/>
因为 Flask 是以 Debug 模式启动的，对 Flask 项目 backend 的改动也可能会触发  Flask 的重新启动，需要的话手动重启  Flask (CTRL+C 退出再重启)<br/><br/>
<blockquote>
$ python backend/app.py
</blockquote>
<br/>
现在  Vue.js 那个服务可以停止了，不管是 Flask 还是 Vue.js  的路由都能够通过  http://localhost:5000 来访问了<br/><br/>
<a href="https://yanbin.blog/wp-content/uploads/2020/07/flask-vue-app-4.png"><img class="aligncenter wp-image-10323" src="https://yanbin.blog/wp-content/uploads/2020/07/flask-vue-app-4-800x177.png" alt="" width="510" height="113" /></a><br/><br/>
<p style="text-align: center;">http://localhost:5000/ping</p>
<br/>
&nbsp;<br/><br/>
<a href="https://yanbin.blog/wp-content/uploads/2020/07/flask-vue-app-5.png"><img class="aligncenter wp-image-10319" src="https://yanbin.blog/wp-content/uploads/2020/07/flask-vue-app-5-800x182.png" alt="" width="510" height="116" /></a><br/><br/>
<p style="text-align: center;">http://localhost:5000/ping_xyz</p>
<br/>
Flask + Vue 对 http://localhost:5000/ping 和  http://localhost:5000/ping_xyz 的处理过程是<br/><br/>
<ol>
    <li>对 localhost:5000 的请求发往 Flask, Flask 的  <code>@app.route('/&lt;path:fallback&gt;')</code> 进行处理</li>
    <li>不是 css/js/img 和  favicon.iso 的请求，交由 Vue.js 的入口 <code>index.html</code> 处理</li>
    <li>Vue.js 在自己的路由表中找到了 <code>/ping</code> 和 <code>/ping_xyz</code>, 进它们进行渲染</li>
    <li>如随意一个 http://localhost:5000/abc，也会转给 Vue.js 的入口 <code>index.html</code>，但 Vue.js 未定 <code>/abc</code> 路由，页面得不到渲染，一面空白</li>
</ol>
<br/>
最后，Flask 与 Vue.js 这样整合后，Vue.js 路由中访问 Flask API 要与 Flask 实际启动的 IP 端口保持一致，因为只有一个服务也就不存在跨域访问的问题，允许跨域相关的 Python 代码也就可以移除掉了。<br/><br/>
本文演示的是一个 Vue.js 多页面程序，如果是单页面程序(用 /#/abc) 导引的，在 Flask 中处理起来还稍微简单些，只要 "/" 请求交给 Vue.js 的入口 <code>index.html</code>, 其他全当是静态文件，Flask 的 API 还是最好约定为 <code>/api/*</code> 的形式。<br/><br/>
<h3>VueRouter 的 history 和 hash 模式</h3><br/><br/>
如果 VueRouter  使用 hash 模式，在服务端可以更简单的些，前面说过在 <code>app.py</code> 中的 <code>fallback()</code> 方法可以不需要了。Vue 默认的模式是 hash, 只是用 vue 命令生成的项目设置成了 <code>history</code> 模式，重新启用 <code>hash</code> 模式的方法是修改 <code>src/router/index.js</code> 文件中，把 mode 值改为 <code>hash</code> 或去掉 <code>mode</code> 行<br/><br/>
<pre class="lang:default decode:true ">const router = new VueRouter({
  // mode: 'history',   或改为 mode: 'hash', 默认为 'hash'
  base: process.env.BASE_URL,
  routes,
});
</pre>
<br/>
这时候打开 <code>http://localhost:8080</code> 会自动跳转到 <code>http://localhost:8080/#/</code>, 其他的路由也加上了 <code>#</code>, 如 <code>/#/ping</code> <br/><br/>
<a href="https://yanbin.blog/wp-content/uploads/2020/07/flask-vue-app-6.png"><img class="aligncenter wp-image-10349" src="https://yanbin.blog/wp-content/uploads/2020/07/flask-vue-app-6-800x184.png" alt="" width="510" height="117" /></a><br/><br/>
浏览时看到原来的 <code>localhost:8080/ping</code> 变成了 <code>localhost:8080/#/ping</code>, 使用 hash 的好处是每次 Vue 的路由跳转其时是一个锚点链接(anchor)，它相当于当前页的位置跳转，不会重新刷新整个页面，且本身不会产生与服务端的 HTTP 请求，所以可减少许多的因 Vue  跳转而产生的交互，虽然前也简单的跳转回 Vue 的入口文件 index.html，但怎么着也是省了不少来回。<br/><br/>
接下来将在 Vue.js 中试验 Bootstrap 和 BootstrapVue 的集成。<br/><br/>
本实例代码已推送到了 github, 仓库地址为 <a href="https://github.com/yabqiu/flask-vue-app.git">https://github.com/yabqiu/flask-vue-app.git</a>，姓没变，欢迎检阅<br/><br/>
相关链接：<br/><br/>
<ol>
    <li><a href="https://zhuanlan.zhihu.com/p/76588212">Flask和Vue.js构建全栈单页面web应用【通过Flask开发RESTful API】</a></li>
    <li><a href="https://testdriven.io/blog/developing-a-single-page-app-with-flask-and-vuejs/">Developing a Single Page App with Flask and Vue.js</a></li>
    <li><a href="https://www.kevin7.net/post_detail/vue-spa-and-flask-together">Vue SPA and Flask together</a></li>
    <li><a href="https://www.reddit.com/r/flask/comments/fdkw9a/best_practices_to_deploy_a_flask_and_vue_app/fjiidgv/">Best practices to deploy a Flask and Vue app?</a></li>
</ol>
