---
title: Scala 的 yield 例子 (for 循环和 yield 的例子)
url: /scala-yield-samples-for-loop/
date: 2012-09-28T10:07:27-05:00
featured: false
draft: false
type: post
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/http://unmi.cc/wp-content/uploads/2012/09/scala_yield.jpeg"
categories:
  - Scala
tags: 
  - Scala
  - yield
comment: true
codeMaxLines: 50
# additional
wpPostId: 4728 
wpStatus: publish
views: 33838
lastmod: 2021-06-02T23:56:47-05:00
---

我看了《Programming in Scala》一书，仍然对 Scala yield 关键字的理解不甚清楚。起初我以为 Scala yield 的与 Ruby 的 yield 是一样，Ruby 中 yield 是被传入代码块的占位符。Scala 中的 <em>yield</em> 关键字好像总是在 <em>for</em> 循环中用的. 下面一些例子可以帮助你更好的理解 yield 关键字。下面是摘自 《Programming in Scala》关于 yield 的解释:</p>
<br/>
<blockquote>
For each iteration of your <em>for</em> loop, yield generates a value which will be remembered. It's like the for loop has a buffer you can't see, and for each iteration of your for loop, another item is added to that buffer. When your for loop finishes running, it will return this collection of all the yielded values. The type of the collection that is returned is the same type that you were iterating over, so a Map yields a Map, a List yields a List, and so on.
Also, note that the initial collection is not changed; the for/yield construct creates a new collection according to the algorithm you specify.
</blockquote>
<br/>
上面那段话的意义就是，for 循环中的 yield 会把当前的元素记下来，保存在集合中，循环结束后将返回该集合。Scala 中 for 循环是有返回值的。如果被循环的是 Map，返回的就是  Map，被循环的是 List，返回的就是 List，以此类推。<!--more--><br/><br/>
基于上面的信息，来看几个例子:<br/><br/>
<pre class="lang:default decode:true">scala&gt; for (i &lt;- 1 to 5) yield i
res10: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 2, 3, 4, 5)</pre>
<br/>
前面的例子都不算什么，还只是个开始. 接下来, 对我们初始集合的每个元素做一次翻倍:<br/><br/>
<pre class="lang:default decode:true">scala&gt; for (i &lt;- 1 to 5) yield i * 2
res11: scala.collection.immutable.IndexedSeq[Int] = Vector(2, 4, 6, 8, 10)</pre>
<br/>
这里是 for/yield 循环的求模操作:<br/><br/>
<pre class="lang:default decode:true">scala&gt; for (i &lt;- 1 to 5) yield i % 2
res12: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 0, 1, 0, 1)</pre>
<br/>
<strong>Scala 数组上的 for 循环 yield 的例子</strong><br/><br/>
之前提到过 for 循环 yield 会构造并返回与给定集合相同类型的集合. 为此, 我们来看看以下用 Scala 数组上的例子. 注意把 yield(我们可以把 yield 用作一个动词) 出来的集合类型与前面的几个例子对比:<br/><br/>
<pre class="lang:default decode:true">scala&gt; val a = Array(1, 2, 3, 4, 5)
a: Array[Int] = Array(1, 2, 3, 4, 5)<br/><br/>
scala&gt; for (e &lt;- a) yield e
res5: Array[Int] = Array(1, 2, 3, 4, 5)<br/><br/>
scala&gt; for (e &lt;- a) yield e * 2
res6: Array[Int] = Array(2, 4, 6, 8, 10)<br/><br/>
scala&gt; for (e &lt;- a) yield e % 2
res7: Array[Int] = Array(1, 0, 1, 0, 1)</pre>
<br/>
正如你所见, 例子中被 yield 的是 Array[Int], 而更早的例子中返回的类型是 IndexedSeq[Int].<br/><br/>
<strong>for 循环, yield, 和守卫( guards) (for loop 'if' conditions)</strong><br/><br/>
假如你熟悉了 Scala 复杂的语法, 你就会知道可以在 for 循环结构中加上 'if' 表达式. 它们作为测试用，通常被认为是一个守卫，你可以把它们与 yield 语法联合起来用。参见：:<br/><br/>
<pre class="lang:default decode:true">scala&gt; val a = Array(1, 2, 3, 4, 5)
a: Array[Int] = Array(1, 2, 3, 4, 5)<br/><br/>
scala&gt; for (e &lt;- a if e &gt; 2) yield e
res1: Array[Int] = Array(3, 4, 5)</pre>
<br/>
如上, 加上了 "if e &gt; 2" 作为守卫条件用以限制得到了只包含了三个元素的数组.<br/><br/>
<strong>Scala for 循环和 yield 的例子 - 总结</strong><br/><br/>
如果你熟悉 Scala 的 loop 结构, 就会知道在 for 后的圆括号中还可以许更多的事情. 你可以加入 "if" 表达式，或别的语句, 比如下面的例子，可以组合多个 if 语句:<br/><br/>
<pre class="lang:default decode:true ">def scalaFiles = 
  for {
    file &lt;- filesHere
    if file.isFile
    if file.getName.endsWith(".scala")
  } yield file</pre>
<br/>
<em>yield</em> 关键字的简短总结:<br/><br/>
<ul>
    <li>针对每一次 for 循环的迭代, yield 会产生一个值，被循环记录下来 (内部实现上，像是一个缓冲区).</li>
    <li>当循环结束后, 会返回所有 yield 的值组成的集合.</li>
    <li>返回集合的类型与被遍历的集合类型是一致的.</li>
</ul><br/><br/>
希望上面的例子结诸位有所帮助. <br/><br/>
参考自：<a href="http://www.devdaily.com/scala/scala-for-loop-yield-examples-yield-tutorial" target="_blank" rel="noopener">Scala yield examples (for loop and yield examples)</a>
