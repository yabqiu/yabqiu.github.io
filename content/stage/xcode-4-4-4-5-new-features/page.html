---
title: Xcode 4.4/4.5 新特性 / LLVM 4.0 新语法
url: /xcode-4-4-4-5-new-features/
date: 2013-01-21T13:09:45-06:00
featured: false
draft: true
type: post
toc: false
# menu: main
usePageBundles: true
categories:
  - iOS
tags: 
  - xcode
  - objective-c
comment: true
codeMaxLines: 50
# additional
wpPostId: 5430 
wpStatus: publish
views: 1044
lastmod: 2021-05-19T16:17:57-05:00
---

跟着苹果干的好处就是，有什么新特性就尽快的就享用它们，这非常符常程序员们的学习心态。不像国内的某些技术领导，他们很领会某种舞台上的精髓 -- 稳定压倒一切 ，JDK 1.6 都出来了，还不少项目还牢牢固守在 JDK 1.3 上，程序员真是无言而又苦 B 啊。当然你在使用  Objective-C 时能时刻得到更新也得利于 Obj-C 完全由 Apple 主导，免了不少口水，瞧瞧 C++ 到 C++11，历时 13 年啊。</p>
<br/>
OK，言归正传，Xcode 当前版本 4.5.2，来看下自 4.4 以来它给我们带来了什么语言上的新特性。每个版本有新特性时一定要看官方的  <a href="developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/WhatsNewXcode" target="_blank" rel="noopener">What's New in Xcode</a>。这么说来 Xcode 4.4 也算是个关键性的版本更新。<br/><br/>
<span style="color: #ff0000;"><strong>@ 不光可用于创建 NSString，还简单化了 NSNumber，NSArray 和  NSDictionary 对象的创建，一一来看。</strong></span><br/><br/>
<span style="color: #0000ff;"><strong>@ 创建 NSNumber 实例</strong></span><br/><br/>
从 Xcode 4.4 起，无段  [NSNumber numberWithInt: 10] 这么写了，@10 就完事，下面是各种数值类型的 NSNumber 创建方式：<!--more--><br/><br/>
<pre class="lang:default decode:true">// char
NSNumber *theLetterZ = @'Z';   // [NSNumber numberWithChar:'Z']<br/><br/>
// Integer
NSNumber *fortyTwo = @42;      //  [NSNumber numberWithInt:42]
NSNumber *ftUnsigned = @42U;   //  [NSNumber numberWithUnsignedInt:42U]
NSNumber *ftLong = @42L;       //  [NSNumber numberWithLong:42L]
NSNumber *ftLongLong = @42LL;  //  [NSNumber numberWithLongLong:42LL]<br/><br/>
// Float
NSNumber *piFloat = @3.141592F;//  [NSNumber numberWithFloat:3.141592F]
NSNumber *piDouble = @3.141592;//  [NSNumber numberWithDouble:3.141592]<br/><br/>
// Boolean
NSNumber *yesNumber = @YES;    //  [NSNumber numberWithBool:YES]
NSNumber *noNumber = @NO;      //  [NSNumber numberWithBool:NO]</pre>
<br/>
<span style="color: #0000ff;">@ 创建 NSArray</span><br/><br/>
现在有了增强的 @ 后一行代码就行了：<br/><br/>
<pre class="">NSArray *items = @[ @"item1", @YES, @12 ];</pre>
<br/>
 看看 Xcode 4.4 之前你不得不这样：<br/><br/>
<pre class="lang:default decode:true">NSArray *items = [NSArray arrayWithObjects:@"item1",
                  [NSNumber numberWithBool:YES],
                  [NSNumber numberWithInt:12], nil];</pre>
<br/>
<span style="color: #0000ff;">@ 创建 NSDictionary</span><br/><br/>
现在用  @ 创建 NSDictionary 的方式简单明了：<br/><br/>
<pre class="lang:default decode:true">NSDictionary *options = @{
    @"backup": @YES,
    @"daysToKeepBackup": @7,
    @"flags": @"foo"
};</pre>
<br/>
而 Xcode 4.4 之前是这样，你可能都会搞不清对应关系，还有那个 nil 尾巴也让人莫名奇妙：<br/><br/>
<pre class="lang:default decode:true">NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys:
                         [NSNumber numberWithBool:YES], @"backup",
                         [NSNumber numberWithInt:7],    @"daysToKeepBackup",
                         @"foo",                        @"flags", nil];
</pre>
<br/>
使用 [] 下标对 NSArray 和  NSDictionary 中元素的存取<br/><br/>
<pre class="lang:default decode:true">items[0];
options[@"backup"];
items[0] = @23;    //如果 items 是一个 NSMutableArray
options[@"backup"] = @NO;   //如果 options 是一个 NSMutableDictionary</pre>
<br/>
想想我们原来需要替换掉 NSMutableArray 和 NSMutableDictionary 中的某个元素必须像下面这么做：<br/><br/>
<pre class="">[items replaceObjectAtIndex:i withObject:newObj]
[options setObject: newObj forKey: key]</pre>
<br/>
上面新的 NSArray 和  NSDictionary 的访问方式原本就应该是这样第一直觉的。回顾下曾经我们是怎么做的：<br/><br/>
<pre class="brush:objc">[items objectAtIndex: 0];
[options objectForKey: @"backup"];</pre>
<br/>
上面那些用法就是 Modern Objective-C，想在老项目中跃跃欲试了吧。Xcode 4.4 为我们提供了迁移工具，Edit -&gt; Refactor -&gt; Convert to Modern Objective-C Syntax，Xcode 帮我们找到项目中所有上面的老语法，代之以新的语法，还有预览：<br/><br/>
<p style="text-align: center;"><a href="/wp-content/uploads/2013/01/modern_objc_1.png"><img class="aligncenter wp-image-5434" src="/wp-content/uploads/2013/01/modern_objc_1.png" alt="modern_objc_1" /></a></p>
<br/>
你只要点击 OK 按钮就行了，不过不知你注意到没有，转换时并没有认为 @synthesize 语句是可省略的，即使是写成 @synthesize foo; 也不认识。关于 @synthesize 我们接下来还会稍加说明。<br/><br/>
<strong><span style="color: #0000ff;">@(expression) 盒子表达式，Boxed Expression</span></strong><br/><br/>
Boxed Expression 有人译作嵌套表达式，嵌套应该是  Nested，Boxed Expression 叫做盒子表达式，盒装表达式，或是装箱表达式感觉更妥一点，像 Java 的  Auto Boxing 翻译是自动装箱。Anyway，反正就是括号中的数值计算后再交给 @ 转成  NSNumber。<br/><br/>
<pre>NSNumber *total = @(0.2f - 1.9f); //[NSNumber numberWithFloat:0.2f - 1.9f]
NSNumber *piOT = @(M_PI / 2);     //[NSNumber numberWithDouble:(M_PI / 2)]</pre>
<br/>
<span style="color: #0000ff;"><strong>可省略的  @synthesize 语句</strong></span><br/><br/>
用过 Obj-C 时间长了，你是不是总觉得那个 @synthesize 是如此的多余，有 @property 不就明了了吗? 反正我以前就是这么认为的，我们的心思，Apple 懂的，Xcode 4.4 后 @synthesize 可省略了。比如 foo 属性没有写 @synthesize 语句，那么它默认就是：<br/><br/>
<pre class="brush:objc">@synthesize foo = _foo;</pre>
<br/>
Xcode 的 Modern Objective-C 转换工具不认为你自己写的 @synthesize 存在多余的可能性，大概它认为你会指定特别的内部变量名，或是动用了 @dynamic。<br/><br/>
只要写了synthesis，无论有没有跟实例变量名，都将生成实例变量 ，如写成 @synthesize foo；那么实例变量名就是foo<br/><br/>
 dynamic优先级高于synthesis，对于写了@dynamic的实现，所有的对应的synthesis都将不生效<br/><br/>
<strong><span style="color: #0000ff;">用 block 遍历 NSArray 或  NSDictionary</span></strong><br/><br/>
像 NSArray 的 enumerateObjectsUsingBlock 等三个方法，和 NSDictionary 的 enumerateKeysAndObjectsUsingBlock 等两个方法。别说三两个都用等等等，看图吧：<br/><br/>
<p style="text-align: center;"><a href="http://unmi.cc/wp-content/uploads/2013/01/modern_objc_3.png"><img class="aligncenter wp-image-5441" src="http://unmi.cc/wp-content/uploads/2013/01/modern_objc_3.png" alt="modern_objc_3" /></a></p>
<br/>
<p style="text-align: center;"><a href="http://unmi.cc/wp-content/uploads/2013/01/modern_objc_2.png"><img class="aligncenter wp-image-5440" src="http://unmi.cc/wp-content/uploads/2013/01/modern_objc_2.png" alt="modern_objc_2" /></a></p>
<br/>
除面以外，你也可以实现自己类的索引，下标方法，如自己对象的  testObject[1], 或 testObject["@key"]，关键就是按需从中实现自己用得都会的方法：<br/><br/>
- (id)objectAtIndexedSubscript: (NSUInteger)index;<br />
 - (void)setObject: (id)obj atIndexedSubscript: (NSUInteger)index;<br />
- (id)objectForKeyedSubscript: (id &lt;NSCopying&gt;)key;<br />
  - (void)setObject: (id)anObject forKeyedSubscript: (id &lt;NSCopying&gt;)aKey;<br/><br/>
详情见：<a title="Objective-C 实现自己的 Subscripting Methods 下标方法" href="http://unmi.cc/objective-c-implement-subscripting-methods">Objective-C 实现自己的 Subscripting Methods 下标方法</a><br/><br/>
参考: 1. <a href="developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/WhatsNewXcode" target="_blank" rel="noopener">What's New in Xcode<br />
</a>          2. <a href="http://blog.csdn.net/don211/article/details/8210807" target="_blank" rel="noopener">Xcode 4.4/4.5 的新特性 | LLVM 4.0 的新语法</a><br />
          3. <a href="http://blog.csdn.net/genios/article/details/7821133" target="_blank" rel="noopener">xcode 4.5 new feature __ ios6 新特性</a><br />
          4. <a href="http://blog.sina.com.cn/s/blog_5a6efa330101d15t.html" target="_blank" rel="noopener">Xcode 4.5 的新特性 | LLVM 4.0 的新语法</a>
