---
title: 自定义 Spring Web Controller 方法的参数
url: /customize-spring-web-controller-method-parameter/
date: 2022-07-07T15:14:09-05:00
featured: false
draft: false
type: post
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/spring-logo.png"
categories:
  - PlayFramework
tags: 
comment: true
codeMaxLines: 50
# additional
wpPostId: 12469 
wpStatus: publish
views: 367
lastmod: 2022-07-07T15:14:09-05:00
---

在 Spring Web Controller 方法中的参数可用 org.springframework.web.bind.annotation 下的各种注解来说明参数值从哪儿获得，比如我们熟知的 @PathVariable, @RequestParam, @RequestHeader, @RequestBody, 还有较少使用的 @ReqeustAttribute, @SessionAttribute, @RequestPart, @MatrixVariable, @ModelAttribute, @AuthenticationPrincipal, @CurrentSecurityContext 等。其实在它们背后工作的是相应的 HandlerMethodArgumentResolver 的子孙们，当然还有 HttpMessageConverter 的各个实现类还默默的对输入数据进入类型转换。</p>
<br/>
为进一步深入了解 Spring Web 如何获得用户输入，我们先尝试一下不常用的注解，然后实现一个自己的注解参数 @ProductId, 它来从 queryString 或 requestHeader 中获得 productId。写作本文的起因是在上一篇 <a href="https://yanbin.blog/springboot-security-jwt-token-how-to-abcs/">理解 Spring Boot Security + JWT Token 的简单应用</a> 里, JwtTokenFilter 住 SecurityContextFilter 放一个 Authentication 实例, 在 Controller 方法中便能用 @AuthenticationPrincipal 自动注入 authentication.getPrincipal() 的值。<!--more--><br/><br/>
JwtTokenFilter: SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken("foo", "bar"))<br/><br/>
Controller 方法: public String hello(@AuthenticationPrincipal String user)    ---- 这样就能获得 JwtTokenFilter 设置的 principal "foo"<br/><br/>
<h3>@RequestBody 处理输入</h3>
我们知道在 Controller 方法中用 hello(@RequestBody String body) 可收到请求的整个 body 字符串，这儿我们尝试用 @RequestBody 直接获取一个 JavaBean<br/>
{{< highlight java >}}
@RestController
public class HelloController{
    record User(String username, String password){}

    @PostMapping("/hello")
    public String hello(@RequestBody User user) {
        return user.toString();
    }
}
{{</ highlight >}}
<br/>
为节约代码使用了 JDK 16 的 record 类型，现在我们来请求一下 POST http://localhost:8080/hello<br/>
<blockquote>
$ curl -X POST -H "Content-type: application/json" http://localhost:8080/hello -d '{"username": "yanbin", "password": "123"}'<br />
User[username=yanbin, password=123]
</blockquote>

目前 @RequestBody 好像只支持 application/json Content-type, 尝试用其他 Content-Type 得到 415: Unsupported Media Type 错误。如果我们注册自己的 HttpMessageConverter，就能实现解析类似<br/><br/>
<ol>
    <li>Content-type: application/xml  -&gt; &lt;user&gt;&lt;username&gt;yanbin&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;/user&gt;</li>
    <li>Content-type: application/x-www-form-urlencoded -&gt; username=yanbin&amp;password=123</li>
    <li>等等</li>
</ol>
<br/>
不过那些应该交给 @ModelAttribute 处理<br/><br/>
@ModelAttribute 注解参数<br/><br/>
把上面的 @RequestBody 改为 @ModelAttribute<br/>
{{< highlight java >}}
@PostMapping("/hello")
public String hello(@ModelAttribute User user) {
    return user.toString();
}
{{</ highlight >}}
<br/>
测试<br/>
<blockquote>
$ curl -X POST -H "Content-type: application/x-www-form-urlencoded" http://localhost:8080/hello -d 'username=yanbin&amp;password=123'<br />
User[username=yanbin, password=123]
</blockquote>

试图用 Content-type: application/json 也不能获得 username 和 password 的值，不报错，但输出的是 User[username=null,password=null]<br/><br/>
显然 @ModelAttribute 也支持 GET 请求的 queryString, 把上面的 @PostMapping("/hello") 改成 @GetMapping("/hello"), 再试<br/>
<blockquote>
$ curl http://localhost:8080/hello\?username\=yanbin\&amp;password\=123<br />
User[username=yanbin, password=123]
</blockquote>

注：<code>\</code> 为 shell 下的转义，实际请求为 http://localhost:8080/hello?username=yanbin&amp;password=123<br/><br/>
<h3>@MatricVariable 处理 Map 输入</h3>
@MatricVariable 是用于从 a=1;b=2;c=3 这种分号分隔的字符串中提取值的，作以下几个测试<br/>
{{< highlight java >}}
@GetMapping("/hello/{*}")
public String hello(@MatrixVariable Map<String, String> user) {
    return user.toString();
}
{{</ highlight >}}
<br/>
为避免 shell 下对 <code>&amp;</code>, <code>=</code>, <code>;</code> 等字符自动转译而影响阅读，只显示实际请求的 URL 及响应<br/>
<blockquote>
http://localhost:8080/hello/;username=yanbin;password=123<br />
{username=yanbin, password=123}
http://localhost:8080/hello/username=yanbin;password=123                                       -- 没有前导分号将丢失第一个值<br />
{password=123}
</blockquote>

不想要前导分号，还要收集到第一个值，这样定义 API<br/>
{{< highlight java >}}
@GetMapping("/hello/{id:.*}")
public String hello(@PathVariable String id, @MatrixVariable Map<String, String> user) {
    return id +";" + user.toString();
}
{{</ highlight >}}
<br/>
测试<br/>
<blockquote>
http://localhost:8080/hello/100;username=yanbin;password=123<br />
100;{username=yanbin, password=123}
http://localhost:8080/hello/100;username=yanbin;password=123<br />
username=yanbin;{password=123}
</blockquote>

{{< highlight java >}}
@GetMapping("/hello/{userId}")
public String hello(@PathVariable String userId, @MatrixVariable String first, @MatrixVariable String last) {
    return "userId: %s, first: %s, last: %s".formatted(userId, first, last);
}
{{</ highlight >}}
<br/>
测试<br/>
<blockquote>
http://localhost:8080/hello/100;first=scott;last=tiger<br />
userId: 100, first: scott, last: tiger
</blockquote>

同样需要注意 @MatrixVariable 的值是从第一个分号后开始算起，其实是第一个分号前的整个值赋给了 userId, 所<br/>
<blockquote>
http://localhost:8080/hello/x=y;first=scott;last=tiger<br />
userId: x=y, first:scott, last:tiger
</blockquote>

@MatrixVariable 只能从 GET 请求的路径上拆解值，不能从 Form 或 Post Body 中拆解 a=1;b=2 中的值。<br/><br/>
另外，在使用 @MatrixVariable 时如果看到错误<br/>
<blockquote>
org.springframework.security.web.firewall.RequestRejectedException: The request was rejected because the URL contained a potentially malicious String ";"
</blockquote>

那是因为启用了  Spring Security, 它禁上在 URL 中带分号，转义的分号也不行，我们可以通过声明一个 Bean 来重新允许 URL 中带分号<br/>
{{< highlight java >}}
@Bean
public HttpFirewall getHttpFirewall() {
    StrictHttpFirewall strictHttpFirewall = new StrictHttpFirewall();
    strictHttpFirewall.setAllowSemicolon(true);
    return strictHttpFirewall;
}
{{</ highlight >}}
<br/>
<h3>自定义的 @ProductId 参数</h3>
预习完基本的 Spring Controller 参数注解后，我们来实现一个自己的 @ProductId 参数注解，它所要达成的功能是，在 Controller 方法中加上<br/>
{{< highlight java >}}
@GetMapping("/hello")
public String hello(@ProductId String productId) {
    return "productId: " + productId;
}
{{</ highlight >}}
<br/>
productId 会自动从 queryString 或 header 中获得值，相当于每次调用如下方法<br/>
{{< highlight java >}}
private String getProductId(HttpServletRequest request) {
    String productId =  request.getParameter("productId");
    return productId != null ? productId : request.getHeader("x-product-id");
}
{{</ highlight >}}
<br/>
需要自己获得 productId 的  controller 方法很多，所以每次调用  getProductId(request) 就不现实了。这时候我们要实现自己的 <code>HandlerMethodArgumentResolver</code>，我们不妨看下 Spring Web 已有的实现类有哪些<br/><br/>
{{< bundle-image src="HandlerMethodArgumentResolver-800x796.png" width="790px" >}}
要实现 @ProductId 在 Controller 方法中自动注入值，很简单，实现一个  ProductIdMethodArgumentResolver，同时通过 WebMvcConfigurer 注册 Spring MVC 中去<br/><br/>
{{< highlight java >}}
@Configuration
public class ProductIdMethodArgumentResolver implements HandlerMethodArgumentResolver, WebMvcConfigurer {

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
       return parameter.getParameterAnnotation(ProductId.class) != null;
    }

    @Override
    public Object resolveArgument(@Nonnull MethodParameter parameter, ModelAndViewContainer mavContainer,
                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory) {
        return getProductId(Objects.requireNonNull(webRequest.getNativeRequest(HttpServletRequest.class)));
    }

    private String getProductId(HttpServletRequest request) {
        String productId =  request.getParameter("productId");
        return productId != null ? productId : request.getHeader("x-product-id");
    }

    @Override
    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {
        resolvers.add(this);
    }
}
{{</ highlight >}}
<br/>
早先的 Spring 或 Java 版本我们需通过继承 WebMvcConfigurerAdapter 的类来注册 MethodArgumentResolver, 由于 Java 8 支持接口的 default 方法，所以这个 *Adapter 就显得多余，不再被推荐使用。<br/><br/>
现在测试<br/>
<blockquote>
$ curl http://localhost:8080/hello?productId=newbie<br />
productId: newbie
$ curl -H "x-product-id:xyz" http://localhost:8080/hello<br />
productId: xyz
$ curl -H "x-product-id:xyz" http://localhost:8080/hello?productId=newbie<br />
productId: newbie
</blockquote>

首先从 queryString 中通过 <code>productId</code> 获得，没有话从 header 中取得, key 是 <code>x-product-id</code>。<br/><br/>
在 HandlerMethodArgumentResolver 中的 resolveArgument 方法中，我们有 MethodParameter, ModelAndViewContainer, NativeWebRequest, 和 WebDataBinderFactory 参数，所以能够实现更复杂的数据绑定，或者使用现有或自定义的 HttpMessageConverter 把请求数据转换成需要的数据对象。
