---
title: Dockerfile 中命令的两种书写方式的区别
url: /dockerfile-difference-between-shell-exec-forms/
date: 2018-03-31T02:17:03-05:00
featured: false
draft: false
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/docker-logo.png"
categories:
  - Docker
tags: 
  - Dockerfile
comment: true
codeMaxLines: 50
# additional
wpPostId: 8612 
wpStatus: publish
views: 5857
lastmod: 2023-12-18T00:42:01-06:00
---

最早的初衷是要研究一下运行 Docker 容器时如何向其传递参数，却冷不防掉入了另一个深渊，不得不关心起 Dockerfile 中命令(包括 RUN, CMD 和 ENTRYPOINT) 的两种不同写法上的区别。<br/><br/>
所以呢，先要稍稍了解一下 Dockerfile 中 RUN, CMD, ENTRYPOINT 这三个指令<br/><br/>
<ol>
    <li>RUN 执行命令并创建新的镜像层，常用于安装软件包。可以多个，为避免创建过多的镜像层，我们尽量把命令合在一起，用分号或 &amp;&amp;。它与容器运行期无关。</li>
    <li>CMD 设置容器启动后默认执行的命令及其参数，但 CMD 能够在启动容器时被覆盖。多个 CMD 只有最后一个是有效的</li>
    <li>ENTRYPOINT 配置容器启动时运行的命令。多个  ENTRYPOINT 也是只有最后一个有效</li>
</ol>
<br/>
关于以上三个命令的区别，这儿有篇文章讲得很清楚 <a href="https://www.ibm.com/developerworks/community/blogs/132cfa78-44b0-4376-85d0-d3096cd30d3f/entry/RUN_vs_CMD_vs_ENTRYPOINT_%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%AC_Docker_%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF_17?lang=en">RUN vs CMD vs ENTRYPOINT - 每天5分钟玩转 Docker 容器技术（17）</a>，此处也照搬了些文字。<br/><br/>
RUN, CMD 和  ENTRYPOINT 都支持两种写法，即 exec 和 shell 格式，见 <a href="https://docs.docker.com/engine/reference/builder/#entrypoint">Dockerfile reference #ENTRYPOINT</a> 对这两种方式的解释。RUN 只影响如何构建镜像，所以镜像中不保留 RUN 命令。CMD 和 ENTRYPOINT 都可以在运行容器时执行命令，这里不讲述它们间的区别，而要说的是它们所支持的 exec 和  shell 两种格式的写法。此篇以 ENTRYPOINT 为例说明两种格式的区别，CMD 类似。<!--more--><br/><br/>
<h3>exec 格式</h3>
<blockquote>
ENTRYPOINT ["executable", "param1", "param2"]
</blockquote>

必须清楚了解命令 "executable" 的每一个参数，一个萝卜一个坑，不能随便乱拆与合并。例如执行 jar 文件的命令<br/>
<blockquote>
java -Xmx256M -jar /app.jar
</blockquote>

写成 exec 格式就是<br/>
<blockquote>
ENTRYPOINT ["java", "-Xmx256M", "-jar", "/app.jar"]
</blockquote>

而不能写成<br/>
<blockquote>
ENTRYPOINT ["java", "-Xmx256M", "-jar /app.jar"]
</blockquote>

否则 <code>docker run</code> 运行它时出错<br/>
<blockquote>
Unrecognized option: -jar /app.jar<br />
Error: Could not create the Java Virtual Machine.<br />
Error: A fatal exception has occurred. Program will exit.
</blockquote>

"-jar" 和 "/app.jar" 分别是两个参数。<br/><br/>
<code>exec 格式是一种数组形式</code>，该格式的 ENTRYPOINT 能接收 CMD 或 <code>dock run &lt;image&gt;</code> 后的参数作为附加参数，相当于是往这个数组中附加元素。例如 Dockerfile 中写成<br/>
<blockquote>
ENTRYPOINT ["echo", "Hello"]
</blockquote>

假设置构建出的镜像名(repository) 是 test(以下都以 test 作为镜像名称), 那么执行下面 docker 命令<br/>
<blockquote>
$ docker run test World and China
</blockquote>

输出是<br/>
<blockquote>
Hello World and China
</blockquote>

使用 exec 格式的  ENTRYPOINT 与 CMD 同在时还能接收 CMD 送过来的参数，如 Dockerfile<br/>
<blockquote>
ENTRYPOINT ["echo", "Hello"]<br />
CMD ["World"]
</blockquote>

执行 docker run 命令<br/>
<blockquote>
$ docker run test
</blockquote>

输出<br/>
<blockquote>
Hello World
</blockquote>

另外，如果执行如下  docker 命令<br/>
<blockquote>
docker run test China Haha
</blockquote>

输出就是<br/>
<blockquote>
Hello China Haha
</blockquote>

原因是 CMD 在运行容器时由 <code>docker run &lt;image&gt;</code> 后的命令覆盖的了，所以 <code>World</code> 不见了。<br/><br/>
注：exec 格式的 ENTRYPOINT 或 CMD 就是它们实际在 docker 镜像中的样子，可用 <code>docker inspect &lt;image&gt;</code> 查看。<br/><br/>
<h3>shell 格式</h3>
<blockquote>
ENTRYPOINT command param1 param2
</blockquote>

官方也虽然定义了这么一种格式，其实它的确没什么特别之处。格式上其实就是平时怎么写完整命令 ENTRYPOINT 后就怎么写，没有中括号让你划分一个个参数，这是便利之处。同样的例子<br/>
<blockquote>
ENTRYPOINT java -Xmx256M -jar /app.jar
</blockquote>

为什么说 shell 格式没什么特别之处呢？因为只要对构建出的镜像用 <code>docker inspect &lt;image&gt;</code> 看下就知道怎么一回事<br/>
<blockquote>
$ docker inspect test
</blockquote>

观察到该 test 镜像的 ENTRYPOINT 实际上是<br/>
<blockquote>
"Entrypoint": [<br />
    "/bin/sh",<br />
    "-c",<br />
    "java -Xmx256M -jar /app.jar"<br />
],
</blockquote>

因此也就是所谓 ENTRYPOINT 后那个完整 shell 命令最终是作为 "/bin/sh" 的第二个参数。同样的 CMD 的 shell 格式<br/>
<blockquote>
CMD echo hello
</blockquote>

inspect 看到该镜像中实际的 CMD 是<br/>
<blockquote>
"Cmd": [<br />
    "/bin/sh",<br />
    "-c",<br />
    "echo hello"<br />
],
</blockquote>

CMD 后完整命令也是作为 "/bin/sh" 的第二个参数。<br/><br/>
有了这个 shell 到 exec 格式的映射关系之后，我们就不难理解为什么 shell 格式的 ENTRYPOINT 不能接收 CMD 或 <code>docker run</code> 传过来的参数。因为参数将作为 "/bin/sh" 的参数而非 shell 的参数，举例说明:<br/><br/>
对于 shell 格式<br/>
<blockquote>
ENTRYPOINT java -Xmx256M -jar /app.jar
</blockquote>

从 CMD 或 <code>docker run</code> 而来的参数( 比如 Hello World) 最终将会组成下面完整的 ENTRYPOINT<br/>
<blockquote>
ENTRYPOINT ["/bin/sh", "-c", "java -Xmx256M -jar /app.jar", "Hello", "World"]
</blockquote>

"Hello", "World" 并不是 java 命令的参数，而 "/bin/sh" 也会忽略掉它们。<br/><br/>
<h3>为何 shell 格式可用变量而 exec 格式不一定行</h3>
最后一个问题，当我们使用 shell 格式时，总是可以使用内联的环境变量。例如在启动 java 程序时希望通过  JAVA_OPTS 来控制 JVM 参数，所以 ENTRYPOINT 这么写<br/>
<blockquote>
ENTRYPOINT java $JAVA_OPTS -jar /app.jar
</blockquote>

启动该镜像时用 -e 指定过小的堆内存大小报错<br/>
<blockquote>
$ docker run -e JAVA_OPTS="-Xms2G" test<br />
Error occurred during initialization of VM<br />
Too small initial heap
</blockquote>

出错信息告诉了我们 $JAVA_OPTS 被替换成了 "-Xms2G"。<br/><br/>
假如我们换成 exec 格式的写法<br/>
<blockquote>
ENTRYPOINT ["java", "$JAVA_OPTS", "-jar", "/app.jar"]
</blockquote>

用上面同样的 <code>docker run</code> 命令<br/>
<blockquote>
$ docker run -e JAVA_OPTS="-Xms2G" test<br />
Error: Could not find or load main class $JAVA_OPTS
</blockquote>

从出错消息可以看出 exec 格式中的 "$JAVA_OPTS" 根本无法通过环境变量进行替换，原因是变量替换操作实际是由 "/bin/sh" 能完成的，shell 格式总是由 "/bin/sh -c" 启动的。如果 exec 格式的 ENTRYPOINT 也希望能解析变量，就得依样写成<br/>
<blockquote>
ENTRYPOINT ["/bin/sh", "-c", "java $JAVA_OPTS -jar /app.jar"]
</blockquote>

<h3>其他各自特点(缺点)</h3>
exec 格式要求一个坑一个参数，所以像上面见到的那样无法在中间动态插入参数，比如不能在中间某一个位置上写上 "-Xmx5G -Xms2G", 这分明是两个参数，只能在后面附加参数<br/><br/>
shell 格式由于命令总是由 "/bin/sh -e" 启动的子进程，它不是 PID 1 超级进程，从而无法收到 Unix 的信号，自然不能收到从 <code>docker stop &lt;container&gt;</code> 发来的  <code>SIGTERM</code> 信号。<br/><br/>
简述一下 <code>docker stop &lt;container&gt;</code> 工作原理，它向容器中的 PID 为 1 进程发送 SIGTERM 信号，并给予 10 秒钟(可用参数 --time) 清理，超时才 -9 强杀，这样可以比较优雅的关闭容器。"/bin/sh -e" 是一个 PID 1 进程，它收到了 SIGTERM 却不会转发给它的子命令，这样就造成了 "/bin/sh -e" 收到 SIGTERM 未作响应被强杀，同时把它的子进程毫无征兆的干掉了。像在  Java 中用 <code>Runtime.addShutdownHook() </code>是捕获不到该信号的。<br/><br/>
<h3>增强型 shell 格式</h3>
这里补充一种 ENTRYPOINT 的声明格式，它实质是 shell 格式，为而把它单独列出来关键就在于 shell 的 <code>exec</code> 命令。此 <code>exec</code> 非前面  exec 格式中的 exec, 而是一个结结实实的 shell 命令。<br/>
<blockquote>
ENTRYPOINT exec command param1 param2 ...
</blockquote>

比如：<br/>
<blockquote>
ENTRYPOINT exec java $JAVA_OPTS -jar /app.jar
</blockquote>

它仍然是 shell 格式，所以 inspect  镜像后看到的 ENTRYPOINT 是<br/>
<blockquote>
ENTRYPOINT ["/bin/sh", "-c" "exec java $JAVA_OPTS -jar /app.jar"]
</blockquote>

然而加了 <code>exec</code> 的绝妙之处在于：<br/><br/>
shell 的内建命令 exec 将并不启动新的shell，而是用要被执行命令替换当前的 shell 进程，并且将老进程的环境清理掉，exec  后的命令不再是 shell 的子进程序，而且 exec 命令后的其它命令将不再执行。从执行效果上可以看到  exec 会把当前的 shell 关闭掉，直接启动它后面的命令。<br/><br/>
虽然它与之后的命令(如上 <code>exec java $JAVA_OPTS -jar /app.jar</code>）还是作为 "/bin/sh" 的第二个参数，但 <code>exec</code> 来了个金蝉脱壳，让这里的 <code>java</code> 进程得已作为一个 PID 1 的超级进程，进行使得这个 java 进程可以收到 SIGTERM 信号。或者理解 <code>exec</code> 为 "/bin/sh" 的子进程，但是借助于 <code>exec</code> 让它后面的进程启动在最顶端。<br/><br/>
另外，由于通过 "/bin/sh" 的搭桥，命令中的变量(如 $JAVA_OPTS) 也会被正确解析，因此 <code>ENTRYPOINT exec command param1 param2 ...</code> 是被推荐的格式。<br/><br/>
注意：exec 只会启动后面的第一个命令，<code>exec ls; top</code> 或 <code>exec ls &amp;&amp; top</code> 只会执行 <code>ls</code> 命令。<br/><br/>
<hr /><br/>
2023-12-18, 再次对比 java ... 与  exec java ... 的区别，发现又没有区别了<br/><br/>
Dockerfile ENTRYPOINT:<br/>
<blockquote>
ENTRYPOINT java $JAVA_OPTS -jar /app.jar "$0" "$@"
</blockquote>

{{< highlight sh >}}
sh-4.2# ps -ef
UID PID PPID C STIME TTY TIME CMD
root         1     0  0 00:01 ?        00:00:00 /dev/init -- /bin/sh -c java $JAVA_OPTS -jar /app.jar "$0" "$@"
root         7     1  5 00:01 ?        00:00:38 java -Xms2g -Xmx2g /app.jar /bin/sh
{{</ highlight >}}
<br/>
Dockerfile ENTRYPOINT:<br/><br/>
<blockquote>
ENTRYPOINT exec java $JAVA_OPTS -jar /app.jar "$0" "$@"
</blockquote>
<br/>
{{< highlight sh >}}
sh-4.2# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 00:26 ?        00:00:00 /dev/init -- /bin/sh -c exec java $JAVA_OPTS -jar /app.jar "$0" "$@"
root         7     1 99 00:26 ?        00:00:46 java -Xms2g -Xmx2g -jar /app.jar /bin/sh
{{</ highlight >}}
<br/>
<blockquote>
ENTRYPOINT ["java", "-Xms2g", "-Xmx2g",  "-jar", "/app.jar", "$0", "$@"]
</blockquote>
<br/>
{{< highlight sh >}}
sh-4.2# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 00:36 ?        00:00:00 /dev/init -- java -Xms2g -Xmx2g -jar /app.jar $0 $@
root         7     1 31 00:36 ?        00:00:40 java -Xms2g -Xmx2g -jar /app.jar $0 $@
{{</ highlight >}}
<br/>
链接：<br/><br/>
<ol>
    <li><a href="https://www.ibm.com/developerworks/community/blogs/132cfa78-44b0-4376-85d0-d3096cd30d3f/entry/RUN_vs_CMD_vs_ENTRYPOINT_%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%AC_Docker_%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF_17?lang=en">RUN vs CMD vs ENTRYPOINT - 每天5分钟玩转 Docker 容器技术（17）</a></li>
    <li><a href="https://docs.docker.com/engine/reference/builder/#entrypoint">Dockerfile reference #ENTRYPOINT</a></li>
    <li><a href="https://xiaozhou.net/stop-docker-container-gracefully-2016-09-08.html">优雅的终止docker容器</a></li>
    <li><a href="https://docs.docker.com/engine/reference/builder/#shell-form-entrypoint-example">Shell form ENTRYPOINT example</a></li>
</ol>
