---
title: 《100 Java Mistakes and How to Avoid Them》笔记 1
url: /100-java-mistakes-and-how-to-avoid-them-notes-1/
date: 2023-09-17T23:46:46-05:00
featured: false
draft: false
toc: false
codeMaxLines: 100
# menu: main
usePageBundles: true
thumbnail: "../images/logos/java-logo.png"
categories:
  - Java/JEE
  - ReadingNotes
tags:
  - Notes
comment: true
# additional
wpPostId: 13268
wpStatus: publish
views: 522
lastmod: 2023-09-28T10:45:35-05:00
---

这几日在阅读 Manning 出版社的 《100 Java Mistakes and How to Avoid Them》, 其中列举的确实是一些容易带入到代码中的错误，不少还是通过代码 Review 或单元测试很难发现的问题。也有些看似很弱智，却可能是隐匿许久的定时炸弹，只等某一特定条件出现时即爆。</p>
<br/>
阅读的同时简单的作了笔记及少许联想，所以内容有些杂乱无条理。最前面介绍了一些静态代码分析工具，也有两个动态分析工具。本书目前还是 Manning 的 MEAP 体验版，未正式发售。一共讲了 100 个常见错误如何避免(例如，怎么用最新 Java(Java 9 -- Java 21) 语法, API 来改进)，以及用静态分析工具，单元测试及早发现。<br/><br/>
这是读完了 1/4 数量的记录，笔记开始<!--more--><br/><br/>
<hr /><br/>
<div data-pm-slice="0 0 []" data-en-clipboard="true">几个好用的静态代码分析的 IntelliJ IDEA 插件</div>
<br/>
<ol>
    <li>
<div>SonarLint: <a href="https://www.sonarsource.com/products/sonarlint/" rev="en_rl_none">https://www.sonarsource.com/products/sonarlint</a>, 还能与 SonarQube 集成</div>
</li>
    <li>
<div>Error Prone: <a href="https://errorprone.info" rev="en_rl_none">https://errorprone.info</a>, Google 开发的 Java 编译插件, 所以还能与 Maven 或 Gradle 等集成</div>
</li>
    <li>
<div>PVS-Studio: <a href="https://www.viva64.com/en/pvs-studio/" rev="en_rl_none">https://www.viva64.com/en/pvs-studio</a>, 付费项目</div>
</li>
    <li>
<div>PMD: <a href="https://pmd.github.io" rev="en_rl_none">https://pmd.github.io</a></div>
</li>
    <li>
<div>SpotBugs: <a href="https://spotbugs.github.io" rev="en_rl_none">https://spotbugs.github.io</a>, 静态分析 Java 字节码</div>
</li>
    <li>
<div>Coverity: <a href="https://www.synopsys.com/software-integrity/security-testing/static-analysis-sast.html" rev="en_rl_none">https://www.synopsys.com/software-integrity/security-testing/static-analysis-sast.html</a>, Synopsis 出品</div>
</li>
    <li>
<div>Klocwork: <a href="https://www.perforce.com/products/klocwork" rev="en_rl_none">https://www.perforce.com/products/klocwork</a>, 热加载不重启调试的工具 JRebel 就是他们家的</div>
</li>
    <li>
<div>CodeQA:  <a href="https://codeql.github.com" rev="en_rl_none">https://codeql.github.com</a>, 如果项目存储在 GitHub 上，可用该工具分析</div>
</li>
</ol><br/>
<div>IntelliJ 还有一个类似于 SonarQube 的静态代码分析平台 <a href="https://www.jetbrains.com/qodana/" rev="en_rl_none">Qodana</a>, IntelliJ IDEA 有相应的插件</div>
<br/>
<br/>
<div>有很多种包提供了支持静态检查的 Annotation, 像 @Nullable, @NotThreadSafe 之类的。如</div>
<br/>
<ol>
    <li>
<div>Error Prone: com.google.errorprone.annotations</div>
</li>
    <li>
<div>Checker: org.checkerframework</div>
</li>
    <li>
<div>JetBrains: org.jetbrains.annotations 和 org.intellij.lang.annotations</div>
</li>
    <li>
<div>Android: androidx.annotation</div>
</li>
    <li>
<div>JDT: org.eclipse.jdt.annotation</div>
</li>
    <li>
<div>JCIP(book: Java Concurrency In Practise): net.jcip</div>
</li>
    <li>
<div>JSR 305: javax.annotation 最终未没采用</div>
</li>
    <li>
<div>FindBugs/SpotBugs: edu.umd.cs.findbugs.annotations, 它沿袭了一些 JSR 305 的注解</div>
</li>
</ol><br/>
<div>每套 Annotation 都提供了 Maven 的使用插件</div>
<br/>
<div>Lombok 代码生成用的 Annotation Processor 会根据注解生成相应的检测代码，比如给方法参数加上</div>
<br/>
<div>foo(@NonNull String name), 在生成的字节码中就会插入参数检测代码</div>
{{< highlight java >}}
if (monthYear == null) {
    throw new NullPointerException("monthYear is marked non-null but is null");
}
{{< /highlight >}}
<br/>
<div>除了 TDD 测试，还有一种 Property-Based Testing 作为补充，Java 实现 <a href="https://jqwik.net/" rev="en_rl_none">jqwik</a> 框架。TDD 容易为了满足单元测试而写实现代码, PBT 能更全面的进行随机测试，但目前本人还未能检验到 PBT 的好处。</div>
<br/>
<div>Mutation coverage  - mutation testing system for Java: <a href="https://pitest.org/" rev="en_rl_none">Pitest</a>. 实现代码的改动能杀死越多的单元测试用例就越好。</div>
<br/>
<div>静态代码分析不够的话，还有动态分析的工具. 如</div>
<br/>
<ol>
    <li>
<div>NASA 开源的 <a href="https://github.com/javapathfinder" rev="en_rl_none">Java Pathfinder</a>, 它可用来检测数据竞争，未处理的异常，可能的失败断言，它配置起来很复杂</div>
</li>
    <li>
<div><a href="https://github.com/devexperts/dlcheck" rev="en_rl_none">Dl-Check</a>，它使用 Java agent, 主要用来发现潜在线程死锁，使用很简单，比如配置一个 maven 插件就行</div>
</li>
</ol><br/>
<div>代码中加入断言也是很好的办法，它能让问题尽量暴露，及时修复</div>
<div>
{{< highlight java >}}
assert condition;
assert condition: explanation;
{{< /highlight >}}
</div>
<div>Java 默认执行是禁用了的，需加 -ea 虚拟机参数启用，在非产品环境可以启用它，或可为某些类/包启用，参数为 -da。Spring 框架提供了更丰富的 assert 方法，它们不受 -ea 虚拟机参数控制了，而总是在那儿。</div>
<br/>
<div>超越了小学数学中乘除比加减法优先级更高的认知就用括号改变优先级，如混合了移位，逻辑运算等的表达式，即使你清除也会让其他程序员迷惑</div>
<br/>
<div>避免手写 hashCode() 方法，用 Java IDE 或其他库成熟的方法来生成 hashCode() 方法</div>
<br/>
<div>String.format() 或 Java 15 开始的 "string".formatted(): 现代 JVM 的字符串格式化方法会比显式的字符串合并( str1 + str2) 慢</div>
<br/>
<div>Java 9 后有一个 Objects.requireNonNullElse(value, "unknown") 方法，比 Optional.ofNullable(value).orElse("unknown") 便捷</div>
<br/>
<div>Java 中的字符串可与数字相加(连接)，这容易产生问题</div>
<br/>
<div>String entryName = "Entry#" + index + 1;  // 可能获得的 entryName 是 "Entry#31"</div>
<br/>
<div>而 Python 中是不允许字符串与数字相连</div>
{{< highlight python >}}
>>> "a" + 1
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: can only concatenate str (not "int") to str
{{< /highlight >}}
<br/>
<div>写成多行的用加号连接字符串时，如果加号在首尾重复时，正好碰到 byte, char, short, long, int 整型时，被认为是 <code>++</code> 操作</div>
{{< highlight java >}}
jshell> "User not found: " +
...> + '"' + "Tiger" + '"';
$1 ==> "User not found: 34Tiger\""
{{< /highlight >}}
<br/>
<div><code>x+=1</code> -&gt; <code>x = x+1</code> ,    <code>x =+1</code> =&gt; <code>x = (+1)</code>,  这里的加号 + 其实是个正的符号，减号也一样要注意</div>
{{< highlight java >}}
>jshell> x=1
x ==> 1
jshell> x += 1
$6 ==> 2
jshell> x =+1
x ==> 1
{{< /highlight >}}
<div>三元操作符在进行数值装箱时的问题</div>
{{< highlight java >}}
Double valueOrZero(boolean condition, Double value) {
    return condition ? value: 0.0;
}
{{< /highlight >}}
<br/>
<div>三元操作符(Ternary) 在决定类型时比较复杂，这里的 <code>condition ? value: 0.0</code> 不受方法返回值 Double 类型的影响</div>
<br/>
<div>三元操作符中 then 条件(冒号: 前的值) 中是 Boxed 类型，而 else 条件(冒号: 后的值) 中基本类型的话，基本类型赢，所以上面的代码相当于</div>
<br/>
{{< highlight java >}}
Double valueOrZero(boolean condition, Double value) {
    return Double.valueOf(
        condition ? value.doubleValue() : 0.0);
}
{{</ highlight >}}
<br/>
<div>所以我们会看到下面的调用错误</div>
{{< highlight java >}}
jshell> Double valueOrZero(boolean condition, Double value) {
   ...>     return condition ? value : 0.0;
   ...> }
|  modified method valueOrZero(boolean,Double)
jshell> valueOrZero(true, null)
|  Exception java.lang.NullPointerException: Cannot invoke "java.lang.Double.doubleValue()" because "<parameter2>" is null
|        at valueOrZero (#12:2)
|        at (#13:1)
jshell> valueOrZero(false, null)
$14 ==> 0.0
{{< /highlight >}}
<br/>
<div>condition 为 false 时不出错，因为三元操作符也是个短路操作。</div>
<br/>
<div>如果避免不必要拆装符，可用  if/else 替代三元操作. 不同分支中避免返回不同的类型，尤其是分支中有 基本类型</div>
<br/>
<div>更好的理解三元操作符如何确定类型转换，可以用 <code>javap -c</code>  反编译看字节码，比如上面的 valueOrZero 方法反编译出来是</div>
{{< highlight java >}}
java.lang.Double valueOrZero(boolean, java.lang.Double);
    Code:
       0: iload_1
       1: ifeq          11
       4: aload_2
       5: invokevirtual #7                  // Method java/lang/Double.doubleValue:()D
       8: goto          12
      11: dconst_0
      12: invokestatic  #13                 // Method java/lang/Double.valueOf:(D)Ljava/lang/Double;
      15: areturn
}
{{</ highlight >}}
<br/>
<div>再来一个更复杂的(null 值碰上基本类型的情况)</div>
{{< highlight java >}}
Integer mapValue(int input) {
    return input > 20 ? 2 :
      input > 10 ? 1 :
      null;
  }
{{</ highlight >}}
<br/>
<div>javap -c 后是</div>
{{< highlight java >}}
java.lang.Integer mapValue(int);
    Code:
       0: iload_1
       1: bipush        20
       3: if_icmple     10
       6: iconst_2
       7: goto          27
      10: iload_1
      11: bipush        10
      13: if_icmple     23
      16: iconst_1
      17: invokestatic  #17                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
      20: goto          24
      23: aconst_null
      24: invokevirtual #22                 // Method java/lang/Integer.intValue:()I
      27: invokestatic  #17                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
      30: areturn
{{</ highlight >}}
<br/>
<div>所以它的等效代码是(从字节码还原出下面的代码需要仔细的阅读理解上面的字节码)</div>
{{< highlight java >}}
return Integer.valueOf(input > 20 ? 2:
    (input > 10 ? Integer.valueOf(1) : null).intValue());
{{</ highlight >}}
<br/>
<div>使用某些反编译工具，如 IntelliJ IDEA 打开 class 文件看不出字节码的不同，仍然能还原为</div>
{{< highlight java >}}
return input > 20 ? 2: input > 10 ? 1 : null;
{{</ highlight >}}

<div>任何时候都要警惕 Integer, Double, Boolean 等拆箱时产生的 NullPointerException</div>
<br/>
<div>尽量使用短路操作 <code>&amp;&amp;</code> 或 <code>||</code>, 小心把它们误写成了非短路的 <code>&amp;</code> 和 <code>|</code> 操作</div>
{{< highlight java >}}
check1() || check2() || check3()     // 不要写成了 check1() | check2() || check3()
{{</ highlight >}}
<br/>
<div>尽可能避免使用非短路操作 <code>&amp;</code> 和 <code>|</code>.</div>
<br/>
<div>避免把有副作用的操作直接放在条件中，不管是</div>
{{< highlight java >}}
if(updateA() && updateB())){ ... }
{{</ highlight >}}
<br/>
<div>还是</div>
{{< highlight java >}}
if(updateA() & updateB()){ .... }
{{</ highlight >}}
<br/>
<div>都会让人感到迷惑，会不会执行 updateB() 变得不确定</div>
<br/>
<div>逻辑运行 <code>!(a || b)</code> 相当于 <code>!a &amp;&amp; !b</code> , 所以对于已有 <code>||</code> 操作，如</div>
{{< highlight java >}}
if(line.startsWith("#") || line.startsWith("//")) {...}
{{</ highlight >}}
<br/>
<div>反过来的话可以在整体的前面加上 <code>!</code> , 而写成</div>
{{< highlight java >}}
if(!(line.startsWith("#") || line.startsWith("//")) {...}
{{</ highlight >}}
<br/>
<div>这时候可能感觉括号多余而写成了</div>
{{< highlight java >}}
if( !line.startsWith("#") || !line.startsWith("//")) {...}  // 这是不对的
{{</ highlight >}}

<div>而要把 || 转成  &amp;&amp;，所以正确的写法是</div>
{{< highlight java >}}
if( !line.startsWith("#") && !line.startWith("//")) {...} // 正确写法
{{</ highlight >}}
<div>相应的 <code>!( a &amp;&amp; b)</code> 相当于 <code>!a || !b</code></div>
<br/>
<div data-codeblock="true" data-line-wrapping="false">
<div data-plaintext="true">非(P 且 Q)=(非 P)或(非 Q)</div>
<div data-plaintext="true">非(P 或 Q)=(非 P)且(非 Q)</div>
</div>
<br/>
<div>Java 1.5 起，函数的最后一个参数可以是变参，变参函数的传参也是很容易出错的地方，如代码</div>
{{< highlight java >}}
void printAll(Object... data) {
    for (Object d: data) {
        System.out.println(d);
    }
}
{{</ highlight >}}
<br/>
<div>变参函数会把传入的参数转成数组，未传的话，就是个空数组，也能显式的传入一个数组</div>
<br/>
<div>下面两种方式调用等效</div>
<div data-codeblock="true" data-line-wrapping="false">
<div data-plaintext="true">
<pre class="lang:default decode:true">printAll("Hello", "World");
printAll(new Object[] {"Hello", "World"}); </pre>
</div>
</div>
<br/>
<div>上面传入 <code>Object[]</code> 的时候是内联的方式传参的，如果是先在某处声明了，过后再传入的</div>
{{< highlight java >}}
Object[] obj = new Object[]{"Hello", "World"};
....... // 中间一段其他代码
printAll(obj);
{{</ highlight >}}
<br/>
<div>这会让人有些迷惑，不过结果和前面的 <code>printAll(new Object[]{"Hello", "World"})</code> 是一样的</div>
<br/>
<div>对象类型的根类型是 Object, 我们再改变引用类型</div>
{{< highlight java >}}
Object obj = new Object[]{"Hello", "World"};
printAll(obj);
{{</ highlight >}}

<div>这时候就错乱了，输出结果是</div>
{{< highlight java >}}
[Ljava.lang.Object;@548ad73b
{{</ highlight >}}
<div>把 <code>new Object[]{"Hello", "World"}</code> 整体作为一个参数传给了 printAll() 方法，调用上相当于</div>
{{< highlight java >}}
printAll(new Object[]{new Object[]{"Hello", "World"}});
{{</ highlight >}}
<br/>
<div>所以变参函数只认声明类型，对于 printAll(Object... data)</div>
<br/>
<div>实参与形参的关系</div>
<br/>
<div>Object obj; 则 data 为 [obj]</div>
<br/>
<div>Object obj; 则 data 为 obj</div>
<br/>
<div>更让人奇怪的是</div>
<br/>
<div>printAll(null), 则 data 为 null, 而不是 [null]</div>
<br/>
<div>为了避免 null 直接作为 data 传入的情况，我们须明确它的声明类型</div>
{{< highlight java >}}
printAll((Object)null);    // data 为 [null]
printAll((Object[])null);  // data 为 null
{{</ highlight >}}
<br/>
<div>我们应在调用变参函数时避免传入 null</div>
<br/>
<div>变参函数的参数只适用于逐个传入或数组(数组会被打散)，如果传入的是一个集合，则该集合只会被当作数组的第一个元素(即 data = [collection]), 所以对数组重构为集合时要特别小心它是否是一个变参函数的参数。</div>
<br/>
<div>变参函数调用上，像 Scala, Python 等语言做的好些，它要求传入列表时需显式的用 <code>*</code> 打散，如 foo(*["Hello", "World"])</div>
<br/>
<div>如果换成引用为 String[] 的字符串数组会怎么样呢？</div>
{{< highlight java >}}
String[] obj = new String[]{"Hello", "World"};
printAll(obj);
{{</ highlight >}}
<br/>
<div>执行的效果上与 Object[] 是一样的，也就是 <code>printAll("Hello", "World");</code> 的效果，但会出现警告</div>
{{< highlight java >}}
Test.java:4: warning: non-varargs call of varargs method with inexact argument type for last parameter;
    printAll(obj);
             ^
  cast to Object for a varargs call
  cast to Object[] for a non-varargs call and to suppress this warning
1 warning
Hello
World
{{</ highlight >}}
<br/>
<div>变参与基本类型，如</div>
{{< highlight java >}}
Arrays.asList(new int[]{1,2,3});        // 输出 [[I@2d127a61]
Arrays.asList(new Integer[]{1,2,3});    // 输出 [1, 2, 3]
{{</ highlight >}}
<br/>
<div>因为 Arrays.asList(T... a) 声明，泛型 T 的上界为 Object, int[] 是一个 Object, 而其中的 int 不是 Object，不会被自动装箱</div>
<br/>
<div>Java 8 的 List 有一个 replaceAll 函数</div>
{{< highlight java >}}
default void replaceAll(UnaryOperator<E> operator) {
    Objects.requireNonNull(operator);
    final ListIterator<E> li = this.listIterator();
    while (li.hasNext()) {
        li.set(operator.apply(li.next()));
    }
}
{{</ highlight >}}
<br/>
<div>可以</div>
{{< highlight java >}}
list.replaceAll(String::trim);
{{</ highlight >}}
<br/>
<div>不要忽略了无副作用函数的返回值，可尝试注解 @CheckReturnValue, @CanIgnoreReturnValue, @Contract(pure = true).</div>
<br/>
<div>避免使用老的用 true/false 代替异常来标识操作成功与失败的 API, 如旧的 <a href="http://java.io.File">java.io.File</a> 的 delete, mkdir, rename 等操作，相应的使用新的 java.nio.file.Files 中的 API, 如 Files.createDirectories(Paths.get(path))<b>, </b>Java 11 的 readNBytes() 或替代 <a href="http://InputStream.read">InputStream.read</a>() 方法</div>
<br/>
<div>使用方法引用可以帮我们省略参数的传递，但一定要清楚它的实际参数，即明确它是重载方法中哪一个方法的引用。其实即使是用 Lambda 也可能会调用了错误的方法，如 JdbcTemplate.query() 方法，可以返回 Object, 也可以返回 List&lt;T&gt;。特别留意 Map.computeIfAbsent() 和 Arrays.setAll() 中用方法引用的情况。</div>
<br/>
<div>list.sort(null) 时实际按自然顺序排序，相当于 list.sort(Comparator::naturalOrder)</div>
<br/>
<div>因为 if/else 的大括号后无需分号，所以避免把多个 if/else 块交织在一起，写成</div>
{{< highlight java >}}
Data data;
if (condition1) {
    data = getData1();
} else if( condition2) {
    data = getData2();
} if (condition3) {                // 这样写没有语法错误，但会造成上面的 data 赋值被忽略，这里的 if 与上面的 if/else 不成一块，在新的一行里写就容易看出问题来
    data = getData3();
} else if (condition4) {
  data = getData4();
} else {
  data = getDefaultData();
}
process(data);
{{</ highlight >}}
<div>如果声明 data 为 final <code>final Data data</code>, 上面的代码就不能通过编译，因为 data 会被赋值多次</div>
<br/>
<div>Condition dominance 的问题，即前一条件使得后面的条件代码永远无法执行到，如</div>
{{< highlight java >}}
if (obj instanceof Number) {
    ....
}
if (object instanceof BigInteger) {
    ...... // 总是被 obj instanceof Number 阻挡住了
}
{{</ highlight >}}
<br/>
<div>Java 21 的 switch pattern 可以解决 instanceof 的检测，如果</div>
{{< highlight java >}}
return switch(obj) {
    case Number number -> BigInteger.valueOf(number.longValue()); // 这里会有编译错误，this case label is dominated by a preceding case label
    case BigInteger bigInteger -> bigInteger
    case null, default -> BigInteger.ZERO
};
{{</ highlight >}}
<br/>
<div>但是对下面的问题</div>
{{< highlight java >}}
if (age >= 6 ) return CHILD;
if (age >= 18) return FULL;
{{</ highlight >}}
<br/>
<div>前面条件包含后面条件的情况就要仔细了，或者用封闭区间来避免，如</div>
{{< highlight java >}}
if (age >=6 && age <=17 ) return CHILD;
if (age >= 18) return FULL
throw new IllegalArgumentException("Wrong age: " + age);   // 测试中未考虑的情况会抛出异常，然后回来补充更多的区间
{{</ highlight >}}
<br/>
<div>Java 的 switch 操作是和 c/c++ 一样 fall through 的方式, case 只提供入口，未没 break 将进入下一个 case; Java 14 及之后的 switch 表达式克服了这一缺点</div>
{{< highlight java >}}
switch(button) {
    case YES -> actOnYes();
    case No -> actOnNo();
    case CANCEl -> actOnCancel();
}
{{</ highlight >}}
<br/>
<div><code>-&gt;</code> 用法的 switch 相当于每个 case 后都会自动加上 <code>break</code>.</div>
<br/>
<div>如果在 switch/case 中赋值，那么声明变量为 final, 在 fall through 的情况编译会出错，因为 final 类型变量不能被多次赋值。</div>
{{< highlight java >}}
final Boolean answer;
switch(ch) {
  case 'T':
  case 't':
    answer = true;
  case 'F':
  case 'f':
    anser = false;  // complilation error: answer is reassigned
    break;
  default:
    anser = null;
}
{{</ highlight >}}
<br/>
<div>如果升级到了 Java 14, 最好总是使用 <code>-&gt;</code> 的 switch 语法. 现代 IDE 能自动完成到 <code>switch -&gt;</code> 的转换</div>
{{< highlight java >}}
final Boolean anser = switch(ch) {
    case 'T', 't' -> true;
    case 'F', 'f' -> false;
    default -> null;
};
{{</ highlight >}}
<br/>
<div>简单的多</div>
<br/>
<div><code>for (int i=lo; i&lt;=hi; i++)</code>, 如 hi 是 Integer.MAX_VALUE 或更大的值(Long), 则 i&lt;=hi 将永远是 true, i++ 溢出后变成负数</div>
<br/>
<div>静态字段初始化顺序的问题</div>
{{< highlight java >}}
class MyHandler {
    public static final MyHandler INSTANCE = new MyHandler();                // 1
    private static final Logger logger = Logger.getLogger(MyHandler.class);  // 2
    private MyHandler() {
        try {
           ...
        } catch (Exception ex) {
            logger.error("initialization error", ex);  // 这里会出现 NullPointerException
        }
    }
}
{{</ highlight >}}
<br/>
<div>上面会出现 NullPointerExcpetion, 因为初始化 INSTANCE 时 logger 还未初始化，行 1, 2 调个顺序就行了</div>
<br/>
<div>字段初始化要保持简单</div>
<br/>
<div>不完全初始化，父类构造函数中调用被子类覆盖的方法时，在子类方法中使用了子类实例变量时可能有 NullPointerException 异常</div>
{{< highlight java >}}
abstract class ParentClass {
    private int id = generatedId();
    abstract int generatedId();
}
class SubClass extends ParentClass {
    Random random = new Random();
    @Override
    int generatedId() {
        return random.nextInt();
    }
}
new SubClass();   // NullPointerException, random is null
{{</ highlight >}}
<br/>
<div>因为实例的初始化顺序是 父实例 -&gt; 子实例， 实例变量实际会在构造函数中初始化的，构造父实例的时候，子实例的构造函数还未调用，所以 random 仍然是 null</div>
<br/>
<div>父类的构造函数在调用可被子类覆盖方法时要留心，如果能声明为不可覆盖就安全了，如静态，或私有，或 final 方法</div>
<br/>
<div>两个相互引用的类，在初始化类和实例时要注意它们初始化顺序，也会产生私有成员未完成初始化的情况</div>
<br/>
<div>如果两个类在初始化时有静态变量的相互引用，由于虚拟机要保证类只能被初始化一次，所以在多线程环境中可能会产生死锁。</div>
{{< highlight java >}}
class A {
   public static final A INSTANCE = new B();
}
class B extends A{
}
{{</ highlight >}}
<br/>
<div>两个线程同时在使用 new A() 和 new B() 时，为保证虚拟机只初始化 A 和 B 一次，虚拟机会进行上锁，然后就可能互锁。</div>
<br/>
<div>类在初始化时最好不要去访问它的子类</div>
<br/>
<div>枚举类型是在类初始化的时候预先创建好相对应的常量，所以在枚举类中有互相引用也会触发私有私有成员未完全初始化的情况。</div>
<br/>
<div>在枚举类的构造函数中不能调用 <code>values()</code> 方法或 <code>switch</code> 作用在当前枚举类型，枚举实际的初始化过程是</div>
<div>
{{< highlight java >}}
enum DayOfWeek {
    SUN, MON, TUE, WED, THU, FRI, SAT;
{{</ highlight >}}
<br/>
<div>实际会预先创建好对应的常量，如</div>
<div>
{{< highlight java >}}
// 0 是 original, 枚举中的其他构造参数会放到 int original 参数之前
public static final DayOfWeek SUN = new DayOfWeek(0);
{{</ highlight >}}
</div>
<br/>
<div>要求子类覆盖方法中第一行要用 <code>super.onKeyDown(event)</code> 调用父类相同方法的设计是很差劲的设计，更应该用抽象方法。</div>
<br/>
<div>静态变量在非静态上下文中(如实例方法) 修改时要注意它会产生线程不安全的问题。即使是 final static 的变量，如果它的内部状态是可变的(如集合)，也是线程不安全的。</div>
<br/>
<div>再次重申 SimpleDateFormat 不是线程安全的，调用 format() 方法会修改内部状态，应该用线程安全的 DateTimeFormatter 类</div>
<br/>
<code>new ArrayList&lt;&gt;(existingList.size())</code>, 预先指定 List 的大小很多时候是没有帮助的，因为在往其中添加元素时接近(不是到达) List 容量时就会扩容。
