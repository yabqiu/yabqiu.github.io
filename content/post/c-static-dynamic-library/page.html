---
title: C 语言静态库与动态库的生成和使用
url: /c-static-dynamic-library/
date: 2024-05-31T11:42:51-05:00
featured: false
draft: false
toc: false
# menu: main
usePageBundles: true
categories:
  - C++/VB
tags: 
  - dynamic
  - Shared Library
  - static
comment: true
codeMaxLines: 50
# additional
wpPostId: 13644 
wpStatus: publish
views: 117
lastmod: 2024-06-01T22:14:47-05:00
---

在 YouTube 上找到一个视频 <a href="https://www.youtube.com/watch?v=k_ccI1Hff60">动态链接库静态链接库的生成和使用</a>，它把用 GCC 生成静态库和动态库，以及如何使用他们说的很明白，有条件的可以直接看那个视频。本文就是一个观后的实操和笔记，加添了更多如何查看动态库，静态库，目标文件，执行文件的过程。</p>
<br/>
为什么要了解静态库和动态库呢？这有助于我们理解多模块的 C/C++ 代码是如何联合工作的。我们多数时候使用的 IDE, 一个 Build 帮我们做了太多的事情，反而使我们眼前一抹黑，这背后有怎么把一个个源文件编译成目标文件(*.o) 文件，或生成静态库/动态库，又如何连接静态库/动态库生成可执行文件，等等。<br/><br/>
试验中使用的平台是 Linux, 如果没有 Linux 可通过 Docker 容器得到一个，如<br/>
<blockquote>
$ docker run -it -v $(pwd):/work -w /work rust:1.78-buster bash
</blockquote>

为什么使用 rust:1.78 镜像，其实也没什么特别的，因为当前在学习 Rust, 而正好该镜像中有 GCC 编译器。启动该容器后，为编辑需要，最好安装一个 vim，在容器中运行<!--more--><br/>
<blockquote>
apt update<br />
apt install -y vim
</blockquote>

若不用 Linux 也行，在 Windows， Mac OS X 也行，编译工具或有不同，我们可以在全平台下使用 GCC。并且清楚不同平台静态库和动态库文件的扩展名是不同的<br/><br/>
<ol>
    <li>Windows: 静态库 *.lib, 动态库 *.dll</li>
    <li>Linux: 静态库 *.a, 动态库 *.so</li>
    <li>Mac OS X: 静态库 *.a, 动态库 *.dylib; *.framework 可能是静态库，也可能是动态库</li>
</ol>
<br/>
以及在不同平台执行文件时如何定位动态库文件有所差异。<br/><br/>
下面是在 Linux 下的演示，我们将要创建一个动态库 libadd.so 和静态库  libsub.a, 编译生成执行文件 main 时要连接这两个静态库和动态库，最后执行时只需依赖于动态库 libadd.so。<br/><br/>
<h3>创建动态库</h3>
add.c<br/>
{{< highlight c >}}
int add(int a, int b) {
    return a + b;
}
{{</ highlight >}}
<br/>
执行命令<br/>
<blockquote>
$ gcc -fPIC -shared -o libadd.so add.c
</blockquote>

生成了 libadd.so 动态库文件<br/><br/>
<h3>创建静态库</h3>
sub.c<br/>
{{< highlight c >}}
int sub(int a, int b) {
    return a - b;
}
{{</ highlight >}}
<br/>
<blockquote>
$ gcc -c sub.c    # 先生成  sub.o 目标文件<br />
$ ar rcs libsub.a sub.o
</blockquote>

生成了 libsub.a 静态文件<br/><br/>
对于生成的目标文件 *.o, 静态库 *.a 和动态库 *.so，我们都可以用 <code>objdump</code>, <code>readelf</code>, 和 <code>nm</code> 来查看某些类型，如<br/>
<blockquote>
objdump -S libsub.a                               # 反编译出汇编代码<br />
objdump -T libadd.so                            # 列出导出的函数<br />
readelf -s --dyn-syms libadd.so           # 查看符号信息<br />
nm -D libadd.so                                      # 查看导出的函数
</blockquote>

Windows 下用 <code>dumpbin /EXPORTS add.dll</code> 查看动态库导出的函数，Mac OS X 下尝试用 Linux 下相同的命令。objdum, readelf, 和 nm 具体的用法请用 <code>--help</code> 参数查看它们的帮助。 <br/><br/>
<h3>使用静态库和动态库</h3>
main.c<br/>
{{< highlight c >}}
#include "stdio.h"

int add(int a, int b);
int sub(int a, int b);

int main() {
    int m = add(5, 2);
    int n = sub(5, 2);

    printf("%1$d+%2$d=%d, %1$d-%2$d=%d\n", 5, 2, m, n);
    return 0;
}
{{</ highlight >}}
<br/>
main 函数前的 <code>add</code>, <code>sub</code> 是符号声明，可让 <code>main.c</code> 代码通过编译生成目标文件，在连接的过程中才去其他目标文件或静态库/动态库文件中找到相应的符号，完成连接<br/>
<blockquote>
$ gcc -o main main.c -L. -lsub -ladd
</blockquote>

生成了 main 可执行文件. 这一步也可以拆成两步来操作<br/>
<blockquote>
$ gcc -c main.c               # 生成了 main.o 目标文件<br />
$ gcc -o main main.o -L. -lsub -ladd     # 连接生成 main 执行文件
</blockquote>

不用 <code>-L. -l</code> 的方式也可以直接直接要链接的库文件名，如<br/>
<blockquote>
$ gcc -o main main.c libadd.so libsub.a       # 或<br />
$ gcc -o main main.o libadd.so libsub.a
</blockquote>

目标 main.o 中对 add, sub 函数的调用地址是 0，<br/>
<blockquote>
$ objdump -t main.o<br />
......<br />
0000000000000000 *UND* 0000000000000000 add<br />
0000000000000000 *UND* 0000000000000000 sub<br />
......
</blockquote>

这就是连接要做的事情，查看连接好生成的 main 文件<br/>
<blockquote>
$ objdump -t main<br />
......<br />
0000000000000000 F *UND* 0000000000000000 add<br />
......<br />
000000000000119e g F .text 0000000000000012 sub<br />
......
</blockquote>

我们看到调用静态库的 sub 函数已经连接到了正确的函数地址，而调用动态库的 add 函数仍然是 0， 这就是所谓的动态，需要在执行时连接到正确的函数地址。<br/><br/>
现在有了可执行文件 main, 试图执行<br/>
<blockquote>
$ ./main<br />
./main: error while loading shared libraries: libadd.so: cannot open shared object file: No such file or directory
</blockquote>

即例 libadd.so 与 main 处在相同的目录，但 main 不知道从它所在目录加载 libadd.so 文件.<br/><br/>
Linux 下 /etc/ld.so.conf.d/ 目录中的配置文件配置了从哪些目录搜寻加载动态库文件<br/>
<blockquote>
$ ls /etc/ld.so.conf.d/<br />
libc.conf x86_64-linux-gnu.conf
</blockquote>

比如它的内容是<br/>
<blockquote>
$ cat /etc/ld.so.conf.d/libc.conf<br />
# libc default configuration<br />
/usr/local/lib
</blockquote>

按照 /etc/ld.so.conf.d/libc.conf 文件中路径，可以把 libadd.so 丢到 /usr/local/lib 目录中，或是在 /etc/ld.so.conf.d 目录中创建新的文件，在其中加上当前 libadd.so 所在的目录路径。<br/><br/>
或者用 <code>LD_LIBRARY_PATH</code> 环境变量<br/>
<blockquote>
$ export LD_LIBRARY_PATH=/work<br />
$ ./main<br />
5+2=5, 5-2=2
</blockquote>

动态连接成功，程序执行正常。<br/><br/>
查看所链接的库<br/>
<blockquote>
ldd main<br />
linux-vdso.so.1 (0x00007ffe14069000)<br />
libadd.so =&gt; /work/libadd.so (0x00007f673f52d000)<br />
libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f673f364000)<br />
/lib64/ld-linux-x86-64.so.2 (0x00007f673f539000)
</blockquote>

如果是找不到 libadd.so 的情况下，用 ldd main 看到的是<br/>
<blockquote>
ldd main<br />
linux-vdso.so.1 (0x00007fffc9149000)<br />
libadd.so =&gt; not found<br />
libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fc40e465000)<br />
/lib64/ld-linux-x86-64.so.2 (0x00007fc40e635000)
</blockquote>

当前目录下所有文件<br/>
<blockquote>
$ ls<br />
add.c libadd.so libsub.a main main.c main.o sub.c sub.o
</blockquote>

如果连接生成 main 执行文件时不指定 -ladd, 就会找不到 add 函数<br/>
<blockquote>
$ gcc -o main main.o -L. -lsub<br />
/usr/bin/ld: main.o: in function `main':<br />
main.c:(.text+0x13): undefined reference to `add'<br />
collect2: error: ld returned 1 exit status
</blockquote>

没有 <code>-L.</code> 也不行，没有 <code>-lsub</code>  也是不行的。<code>-L.</code> 告诉从当前目录中找动态库或静态库文件，<code>-lsub</code>, <code>-ladd</code>, 表示要从 <code>-L.</code>  指示的目录中查找 <code>libsub.a</code>, <code>libsub.so</code>, <code>libadd.a</code>, 或 <code>libadd.so</code> 文件。
