---
title: Quartz Job Scheduling Framework［翻译］第十章. J2EE 中使用 Quartz (第一部分)
url: /quartz-job-scheduling-framework-10-1/
date: 2007-12-07T11:19:00-06:00
featured: false
draft: false
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/quartz-logo.jpeg"
categories:
  - Quartz
tags: 
  - Quartz
  - 翻译
comment: true
codeMaxLines: 50
# additional
wpPostId: 461 
wpStatus: publish
views: 426
lastmod: 2019-12-11T19:10:14-06:00
---

Java 2 平台企业版定义了基于组件的企业应用开发标准。不管你是否倾向于使用一种开源的 J2EE 服务器，比如 JBoss 或 Geronimo，或者你更希望得到可靠安全的商业服务支持，比如 WebSphere 和 WebLogic，你都能在那些应用服务器中使用几种不同的部署方式使用 Quartz。本章给你示范了在 J2EE 应用服务器中以不同策略部署 Quartz，你也会看到 Quartz 框架更加丰富了 J2EE。</p>
<br/>
<strong>一：假如我有 J2EE，为什么还需要 Quartz?<br />
</strong><br />
自从 20 世纪 90 年代末期 J2EE 首次登上舞台以来，开发人员就被某些规格决议和一些表面看来明显缺失的特征所困惑。这没必要去批判规格的制定者，更多的是说明了当有不同意见和议程的独立团体，在尝试达成统一的优先级时，就像联合国进行决议时那样，并不如所想像的那样好。许多必须的特征获得认可，但是一些关键的特征被略去留待以后加入。其中一个让早期规范遗漏的关键特征就是定时器服务。<!--more--><br/><br/>
<strong>·我需要定时器服务</strong><br/><br/>
许多商业流程需要异步的作业调度。例如，Web 站点通常需要向注册用户发邮件告知他们有新的特性或是邮寄最新期刊。医疗索赔处理公司典型的也是需要在晚上下载医疗数据然后拿来处理后续事情。一个销售多种类型产品公司也许要每个晚上生成销售和佣金信息的数据报表。所有前面的场景都需要一个定时器服务来执行异步的作业。<br/><br/>
Java/J2EE 社区对解决定时器服务作过多次的尝试。在早期，厂商在他们的 J2EE 服务器中加入适当的解决方案。（在本章上，述语 J2EE 服务器和 J2EE 容器是指同一概念。）例如，WebLogic 产品中有一些定制的扩展，在 IBM 的 J2EE 服务器中也这么做的。不幸的是，它们是不能兼容的，你不能把组件从一种服务器迁移到另一种服务器中。后来，WebLogic 和 IBM 还有其他的厂商试着开发一套通用的定时器组件。<br/><br/>
从 Java 1.3 开始，Sun 在 Java 核心中加入了 <span style="color: #800080;">java.util.Timer</span> 和 <span style="color: #800080;">java.util.TimerTask</span> 类来帮助实现基本的定时器功能。尽管<span style="color: #800080;"> Timer</span> 和 <span style="color: #800080;">TimerTask</span> 能满足简单的需求，但有更多的作业调度仅用这两个具体类做不到的，希望你已经明白了这一点。<br/><br/>
<strong>·Quartz/J2EE 部署模型</strong><br/><br/>
现在有两个策略用来在 J2EE 中构架和部署 Quartz。其中之一是，你可以把 Quartz 设计在 J2EE 容器外部作为一个标准的 J2SE 客户端。你很快就会看到，这种方法是最简单的。第二种策略是部署 Quartz 　驻留在 J2EE 容器中作为其客户端。这种场景下，J2EE 客户端就是一个像其他 Web 应用程序一样部署 Web 归档 (WAR) 文件。策略的选择有赖于你确切的需求。每一种策略都有其好处与缺点。<br/><br/>
<strong>·作为 J2SE 客户端运行 Quartz</strong><br/><br/>
假如你正需要调用 Enterprise JavaBean (EJB) 的服务，或者要把消息送入到 JMS 的队列或主题中，最简单的配置方式就是在 J2EE 容器之外作为一个 J2SE 程序运行。这时它的功能就像任何别的在容器外运行的程序一样，只是它需要去调用容器内分布式组件上的方法。<br/><br/>
我们实际上在前面的章节中使用过这种方式，只是未提及调用 EJB 。你可以创建一个 Quartz 应用，包含了 Quartz 库和作业调度信息，并通过 Home 和 Remote 接口连接到 J2EE 服务器。然后你就可以像其他分布式客户端那样调用 EJB 上的方法了。你也可以新建并插入 JMS 消息让容器中运行的消息驱动 Bean (MDB) 来处理它们。在图 10.1 中显示了这种用法。<br/><br/>
<div style="text-align: center;"><strong>图 10.1. Quartz 可作为一个独立的 J2SE 客户端与 J2EE 协同工作</strong></div>
<br/>
{{< bundle-image src="/QuartzFigure10.1.JPG" width="308px" >}}
如果你有已存在的 J2EE 组件需要 Quartz 与其交互，并且你不希望或无法对服务器作任何改变，用这种这种方法很适合。你只需要像我们前面章节介绍的那样构建一个 Quartz 应用，并使用 Quartz 自带的 <span style="color: #800080;">EJBInvokerJob</span>。我们马上就会讨论到 <span style="color: #800080;">EJBInvokerJob</span> 的。<br/><br/>
<strong>·部署 Quartz 到 J2EE 服务器中</strong><br/><br/>
Quartz 也直接能部署在容器中，这样就不需要外部的 Quartz 应用了。这通常被称之为 J2EE 客户端。你选择这种方式也不是之前的方式也许有多个理由。其中之一是你仅需要维护一个应用，而另一种方式需要维护两个应用。中，可以让 Quartz 使用某些容器提供的资源，例如邮件会话、数据源和其他的适配器资源。假如你是在集群环境中使用 J2EE 服务器，这也让部署在容器中的 Quartz 集群更简单和易于管理。图10.2 描绘了 Quartz 如何部署与 J2EE 应用一同部署的。<br/><br/>
<div style="text-align: center;"><strong>图 10.2. Quartz 可与 J2EE 应用一同部署</strong><br />
</div>
{{< bundle-image src="QuartzFigure10.2.JPG" width="149px" >}}
<br/>
当 Quartz 被部署在 J2EE 容器中，你必须清楚并能处理一些兼容性的问题，在论及这个话题之前，让我们来讨论如何部署 Quartz 为 J2SE 客户端并从容器外访问容器。<br/><br/>
<strong>·作为 J2SE 客户端运行 Quartz</strong><br/><br/>
到目前为止，最简单容易的在 J2EE 中使用 Quartz 的方式是把它部署在容器之外。这种方式这所以简单一方面是因为你无需去处理许多问题，比如 Quartz 如何尝试在 J2EE 容器中创建线程并执行他们的；另一方面是因为即使你使用最新的工具和技术，例如 XDoclet 或管理控制台，部署应用到 J2EE 容器中也是让人感到沮丧的。<br/><br/>
<strong>·使用 Quartz 的 EJBInvokerJob 去调用 EJB<br />
</strong><br />
Quartz 框架中包含 <span style="color: #800080;">org.quartz.jobs.ee.ejb.EJBInvokerJob</span> 类，它允许你部署一个 Job 当触发时去调用 EJB 的方法。不管你选择的是哪种 Quartz 部署方式，这个 Job 都很容易建立并使用。我们假定，你有一个像代码 10.1 所列的无状态会话 Bean (SLSB)。<br/><br/>
<div><strong>代码 10.1. 一个无状态会话 Bean 的例子</strong></div>
<br/>
<strong> </strong>
{{< highlight java >}}
import java.rmi.RemoteException;<br/><br/>
import javax.ejb.EJBException;
import javax.ejb.SessionBean;
import javax.ejb.SessionContext;<br/><br/>
public class TestBean implements SessionBean {
     /** The session context */
     private SessionContext context;<br/><br/>
     public TestBean() {
          super();
     }<br/><br/>
     // EJB Lifecycle Methods not shown for brevity<br/><br/>
     public void helloWorld() throws EJBException {
          System.out.println("Hello World");
     }<br/><br/>
     public void helloWorld(String msg) throws EJBException {
          System.out.println("Hello World - " + msg);
     }
}
{{</ highlight >}}
<br/>
把这个 EJB 部署到你所选的 J2EE 应用服务器中并准备就绪，你就可以使用 <span style="color: #800080;">EJBInvokerJob</span> 去调用其中的一个对于远程客户端可见方法 <span style="color: #800080;">helloWorld()</span>。<br/><br/>
你只要像其他的 Job 那般建立 <span style="color: #800080;">EJBInvokerJob</span>。代码10.2 展示了如何用 <span style="color: #800080;">EJBInvokerJob</span> 去调用那个 SLSB 上的 <span style="color: #800080;">helloWorld()</span> 方法。<br/><br/>
<strong>代码 10.2. 一个使用 EJBInvokerJob 的简单例子</strong>
{{< highlight java >}}
package org.cavaness.quartzbook.chapter10;

import java.util.Date;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.quartz.JobDetail;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.Trigger;
import org.quartz.TriggerUtils;
import org.quartz.impl.StdSchedulerFactory;
import org.quartz.jobs.ee.ejb.EJBInvokerJob;

public class Listing_10_2 {
     static Log logger = LogFactory.getLog(Listing_10_2.class);

     public static void main(String[] args) {
          Listing_10_2 example = new Listing_10_2();

          try {
               // Create a Scheduler and schedule the Job
               Scheduler scheduler = example.createScheduler();
               example.scheduleJob(scheduler);

               // Start the Scheduler running
               scheduler.start();

               logger.info("Scheduler started at " + new Date());

          } catch (SchedulerException ex) {
               logger.error(ex);
          }
     }

     // Schedule the EJBInvokerJob
     private void scheduleJob(Scheduler scheduler) throws SchedulerException {

          // Create a JobDetail for the Job
          JobDetail jobDetail = new JobDetail("HelloWorldJob",
                    Scheduler.DEFAULT_GROUP,
                    org.quartz.jobs.ee.ejb.EJBInvokerJob.class);

          loadJobDataMap(jobDetail);

          // Create a trigger that fires every 10 seconds, forever
          Trigger trigger = TriggerUtils.makeSecondlyTrigger(10);
          trigger.setName("helloWorldTrigger");
          // Start the trigger firing from now
          trigger.setStartTime(new Date())

          // Associate the trigger with the job in the scheduler

             scheduler.scheduleJob(jobDetail, trigger);
         }

         /*
          * Configure the EJB parameters in the JobDataMap
          */
         public JobDetail loadJobDataMap(JobDetail jobDetail) {
              jobDetail.getJobDataMap().put(EJBInvokerJob.EJB_JNDI_NAME_KEY,
                        "ejb/HelloWorldSession");

              jobDetail.getJobDataMap().put(EJBInvokerJob.EJB_METHOD_KEY,
                        "helloWorld");

              jobDetail.getJobDataMap().put(EJBInvokerJob.PROVIDER_URL,
                        "t3://localhost:7001");

              jobDetail.getJobDataMap().put(
                   EJBInvokerJob.INITIAL_CONTEXT_FACTORY,
                        "weblogic.jndi.WLInitialContextFactory");

              return jobDetail;

         }

         /*
          * return an instance of the Scheduler from the factory
          */
         public Scheduler createScheduler() throws SchedulerException {
              return StdSchedulerFactory.getDefaultScheduler();
         }
}
{{</ highlight >}}
<br/>
正如你在代码 10.2 中看到的，<span style="color: #800080;">EJBInvokerJob</span> 采用和别的 Job 一样的配置方式。创建了一个相关的 <span style="color: #800080;">JobDetail</span> 和 trigger 并注册到调度器中。需要针对不同的 J2EE 容器来配置 <span style="color: #800080;">JobDataMap</span> 中的参数，才能让 Job 正确的执行。表 10.1 列出了这个 Job 所支持的 <span style="color: #800080;">JobDataMap</span> 参数。<br/><br/>
要往 JobDataMap 中加入什么参数依赖于所使用的 J2EE 服务器和自身的需求。例如，假如你使用的是 BEA 的 WebLogic，你必须至少指定代码 10.1 中所列的参数。显示地，必须替换为你特定环境的参数值。假如你是用的 WebSphere，大部份参数值是不一样的。<br/><br/>
当我们建立好 Job 并在我们的外部 Quartz 应用程序中运行 10.2 中的代码，每隔 10 秒钏 EJB 上的方法 <span style="color: #800080;">helloWorld()</span> 就被调用一次。这种方式好就好在我们不需要为部署 Quartz 应用到 J2EE 容器上而费心。这也强制了 Job 信息与商业处理逻辑的分离。<br/><br/>
<table border="0" width="650">
<caption><strong>表 10.2. <span style="color: #800080;">EJBInvokerJob</span> 所用的参数，具体依赖于特定的 J2EE 服务器</strong></caption>
<tbody>
<tr>
<td><strong>静态常量</strong></td>
<td><strong>字面值<br />
</strong> </td>
</tr>
<tr valign="top">
<td><span style="color: #800080;">EJB_JNDI_NAME_KEY<br />
</span><strong>注：</strong>Bean 的 home 接口的 JNDI 名</td>
<td><span style="color: #800080;">ejb</span></td>
</tr>
<tr valign="top">
<td><span style="color: #800080;">PROVIDER_URL</span><br />
<strong>注：</strong>特定于厂商的 URL，指示哪里能找到服务器</td>
<td><span style="color: #800080;">java.naming.provider.url</span></td>
</tr>
<tr valign="top">
<td><span style="color: #800080;">INITIAL_CONTEXT_FACTORY</span><br />
<strong>注：</strong>特定于厂商的上下文工厂，用于查找资源的</td>
<td><span style="color: #800080;">java.naming.factory.initial</span></td>
</tr>
<tr valign="top">
<td><span style="color: #800080;">EJB_METHOD_KEY</span><br />
<strong>注：</strong>在 EJB 上要调用的方法名称</td>
<td><span style="color: #800080;">method</span></td>
</tr>
<tr valign="top">
<td><span style="color: #800080;">EJB_ARGS_KEY</span><br />
<strong>注：</strong><span style="color: #800080;">Object[]</span> 类型，传递给方法的参数值对象数组(可选，如果不设表明无参数)</td>
<td><span style="color: #800080;">args</span></td>
</tr>
<tr valign="top">
<td><span style="color: #800080;">EJB_ARG_TYPES_KEY</span><br />
注：<span style="color: #800080;">Class[]</span> 类型，传递给方法参数类型的类数组(可选，如果不调表示每个参数的类型都源自于相应参数的 getClass() 返回) </td>
<td><span style="color: #800080;">argsTypes</span></td>
</tr>
<tr valign="top">
<td><span style="color: #800080;">PRINCIPAL</span><br />
<strong>注：</strong>调用 EJB 方法的主体(用户)</td>
<td><span style="color: #800080;">java.naming.security.principal</span></td>
</tr>
<tr valign="top">
<td><span style="color: #800080;">CREDENTIALS</span><br />
<strong>注：</strong>调用 EJB 方法的凭证</td>
<td><span style="color: #800080;">java.naming.security.credentials</span></td>
</tr>
</tbody>
</table>
<br/>
在代码 10.2 所示例子中，在 EJB 上被调用的方法 <span style="color: #800080;">helloWorld()</span> 没有定义任何参数。<span style="color: #800080;">EJBInvokedJob</span> 类允许你通过指定 <span style="color: #800080;">EJB_ARGS_KEY</span> 和 <span style="color: #800080;">EJB_ARG_TYPES_KEY</span> 属性来传递方法参数，见表 10.1。<br/><br/>
代码 10.3 展示了另一个简单的例子，传递一个参数来调用运行在 Apache Geronimo J2EE 服务器中的 EJB  的另一版本的  <span style="color: #800080;">helloWord()</span> 方法。<br/><br/>
代码 10.3 和代码10.2 十分相像，除多包含了 <span style="color: #800080;">EJB_ARGS_KEY</span> 和 <span style="color: #800080;">EJB_ARG_TYPES_KEY</span> 参数设置。还因为 EJB 是运行在 Geronimo J2EE 应用服务器中，所以还需要加上参数 <span style="color: #800080;">PRINCIPAL</span> 和 <span style="color: #800080;">CREDENTIALS</span>。<br/><br/>
<strong>代码 10.3. 使用 <span style="color: #800080;">EJBInvokerJob</span> 的简单例子</strong>
{{< highlight java >}}
package org.cavaness.quartzbook.chapter10;

import java.util.Date;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.quartz.JobDetail;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.Trigger;
import org.quartz.TriggerUtils;
import org.quartz.impl.StdSchedulerFactory;
import org.quartz.jobs.ee.ejb.EJBInvokerJob;

public class Listing_10_3 {
     static Log logger = LogFactory.getLog(Listing_10_3.class);

     public static void main(String[] args) {

          Listing_10_3 example = new Listing_10_3();

          try {

              // Create a Scheduler and schedule the Job
              Scheduler scheduler = example.createScheduler();
              example.scheduleJob(scheduler);

              // Start the Scheduler running
              scheduler.start();

              logger.info("Scheduler started at " + new Date());

          } catch (SchedulerException ex) {
               logger.error(ex);
          }
     }

     // Schedule the EJBInvokerJob
     private void scheduleJob(Scheduler scheduler)
          throws SchedulerException {

          // Create a JobDetail for the Job
          JobDetail jobDetail = new JobDetail("HelloWorldJob",
                    Scheduler.DEFAULT_GROUP,
                    org.quartz.jobs.ee.ejb.EJBInvokerJob.class);

          // Load all of the necessary EJB parameters
          loadJobDataMap(jobDetail);

          // Create a trigger that fires every 10 seconds, forever
          Trigger trigger = TriggerUtils.makeSecondlyTrigger(10);

          trigger.setName("helloWorldTrigger");
          // Start the trigger firing from now
          trigger.setStartTime(new Date());

          // Associate the trigger with the job in the scheduler
          scheduler.scheduleJob(jobDetail, trigger);

     }

     /*
      * Configure the EJB parameters in the JobDataMap
      */
     public JobDetail loadJobDataMap(JobDetail jobDetail) {
          jobDetail.getJobDataMap().put(
               EJBInvokerJob.EJB_JNDI_NAME_KEY, "ejb/Test");

          jobDetail.getJobDataMap().put(EJBInvokerJob.EJB_METHOD_KEY,
                    "helloWorld");

          Object[] args = new Object[1];
          args[0] = " from Quartz";
          jobDetail.getJobDataMap().put(
               EJBInvokerJob.EJB_ARGS_KEY, args);

          Class[] argTypes = new Class[1];
          argTypes[0] = java.lang.String.class;
          jobDetail.getJobDataMap().put(
               EJBInvokerJob.EJB_ARG_TYPES_KEY, argTypes);

          jobDetail.getJobDataMap().put(
               EJBInvokerJob.PROVIDER_URL, "127.0.0.1:4201");

          jobDetail.getJobDataMap().put(
               EJBInvokerJob.INITIAL_CONTEXT_FACTORY,
                         "org.openejb.client.RemoteInitialContextFactory");
          jobDetail.getJobDataMap().put(
               EJBInvokerJob.PRINCIPAL, "system");

          jobDetail.getJobDataMap().put(
               EJBInvokerJob.CREDENTIALS, "manager");

          return jobDetail;
     }

     /*
      * return an instance of the Scheduler from the factory
      */
     public Scheduler createScheduler() throws SchedulerException {
          return StdSchedulerFactory.getDefaultScheduler();
     }
}
{{</ highlight >}}
<br/>
<table style="border: 1px;" border="1" width="70%" align="center">
<tbody>
<tr>
<td><strong><span style="color: #800080;">EJBInvokerJob</span> 参数和序列化<br />
</strong><br />
在论及 Java 和分布式程序时会遇到一个典型的问题就是序列化，你应该尽量的传递 <span style="color: #800080;">String</span> 或原始数据类型给 EJB 的方法。假如你需要传递复杂的类型，你的代码必须使对象在服务端和客户端之间序列化传输。要知道关于 Java 序列化的深层次的信息，请在 <a href="http://java.sun.com/j2se/1.5.0/docs/guide/serialization">http://java.sun.com/j2se/1.5.0/docs/guide/serialization</a> 查看 Sun 的序列化规范。</td>
</tr>
</tbody>
</table>
<br/>
由于 Quartz 需要拿到 EJB 的 home 和远程接口，你必须部署某些 J2EE 客户端 JAR 包到你外部的 Quartz 应用中。需要哪些 JAR 文件依赖于你所用的 J2EE 容器。例如，假如你是用的 WebLogic，则要在 Quartz 应用程序中引入 <span style="color: #800080;">weblogic.jar</span> 包。是 Geronimo 的话，就得引入多个相关包。查看特定应用服务器的文档来确保这一点。
