---
title: Clojure 快速突击(续)
url: /clojure-get-started-1/
date: 2016-07-01T23:57:23-05:00
featured: false
draft: false
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/clojure-logo-120b.png"
categories:
  - Clojure
tags: 
  - Clojure
comment: true
# additional
wpPostId: 7334 
wpStatus: publish
views: 541
lastmod: 2021-05-04T15:31:29-05:00
---

Clojure 确实要比 Python 语义上庞大, 所以无法尽量在一篇之中收纳进来, 只得另立新篇, 也许还会有第三篇笔记. 现在开始学习函数定义</p>
<h3><span style="color: #0000ff;">函数定义</span></h3><br/>
函数用  <code>defn</code> 宏来定义, 函数名与参数列表之间可选的字符串是函数的注释, 相当于 Python 的函数体中第一个字符串,  这个字符串能被 <code>(doc func-name)</code>  列出来, Python 中是用 <code>dir(fun_name</code> 显示函数帮助. 不需要 return 关键字, 和 Groovy/Scala 一样最后一个表达式的值为函数的返回值, 所以函数总是有返回值(或为 nil).<br/><br/>
和 C 语言一样, 函数必须先定义再使用, 否则要用 <code>(declare function-names)</code> 提前声明, 下面代码是在 Clojure 的 REPL 中执行的<br/><br/>
<pre class="lang:default decode:true">user=&gt; (defn say-hello-to
 "say hello to some"
 [name] (str "Hello, " name))
#'user/say-hello-to
user=&gt; (doc say-hello-to)
-------------------------
user/say-hello-to
([name])
 say hello to some
nil
user=&gt;</pre>
<br/>
提一下 Clojure 的命名规则, 变量和函数名用中划线连接的小写单词. <code>defn-</code> 定义的函数是私有, 只对当前名字空间可见, 比如上面的  user 名字空间. 有点像 Python 的下划线变量或函数的可见性约定.<!--more--><br/><br/>
Clojure 支持可变函数(VarArgs), <code>&amp;</code> 之后的参数在一个 list 中, 如<br/><br/>
<pre class="lang:default decode:true">(defn accumulate [first &amp; others]
 (reduce #(+ %1 %2) first others))<br/><br/>
(println (accumulate 1 2 3 4 5 6))   ;-&gt; 21</pre>
<br/>
函数可包含多个参数及对应的方法体, 以此来实现默认参数或重载<br/>
<pre class="lang:default decode:true">(defn sayHello
 ([] (sayHello "World"))       ; 相当于定义了两个函数了, 瞧这里正调用第二个函数
 ([name] (str "Hello " name))
 )<br/><br/>
(println (sayHello))          ; -&gt; Hello World
(println (sayHello "Yanbin")) ; -&gt; Hello Yanbin</pre>
<br/>
匿名函数已在第一篇中讲过了, 它其实就是一个 Lambda 表达式了, #(...), 参数直接用 %(%1), %2, %3 .... 了. Clojure 的这种方式的匿名函数还是很方便的.<br/><br/>
<code>comp</code> 可以把多个函数以管道形式组合起来, 如<br/>
<pre class="lang:default decode:true">(defn times2 [n] (* n 2))
(defn minus3 [n] (- n 3))<br/><br/>
(def my-composition (comp minus3 times2))  ;注释 用的 def, my-composition 是一个函数类型的变量<br/><br/>
(println (my-composition 4))  ;-&gt; 4 * 2 -3 = 5<br/><br/>
(defn my-composition1 [n] (-&gt; (times2 n) minus3))
(println (my-composition1 4)) ; 同样的效果 4 * 2 - 3 = 5 </pre>
<br/>
<code>complement</code> 接受函数为参数求补, <code>partial</code> 给旧的函数制定一个初始值. <br/><br/>
与 Ruby  的约定一样, Clojure 定义谓词型的函数使用问号, 像<br/>
<pre class="lang:default decode:true">(defn teenager? [age] (and (&gt;= age 13) (&lt; age 20)))
(teenager? 15)   ;-&gt; true
(teenager? 20)   ;-&gt; false</pre>
<br/>
<span style="text-decoration: underline; font-size: 12pt;"><span style="color: #ff0000; text-decoration: underline;">学习 Clojure 到现在基本能够体会到它的代码就是数据, 代码中常用的 <code>()</code> 和 <code>[]</code> 怎么变都是 List 和 Vector 的组合, 再多就是把 List 和 Map 加进去. 数据结构就是编程, 谁想到 Lisp 这么一种语言真是太有才了.</span></span><br/><br/>
<strong><span style="color: #0000ff;">发现一个有意思的事情</span></strong>, 下面的代码因为输入有误, 结果是 Cloujure 把结果都算出来了, 再告诉我最后多了一个括号, 可见它的执行机制是能匹配到括号就能行, 多了也不是大事. 可以试下 <code>(def v 123)))))))</code> 再多的括号都能为你把变量 <code>v = 123</code> 正确的定义出来.<br/><br/>
<pre class="lang:default decode:true ">user=&gt; (reduce #(+ %1 %2) [1 2 3 4 5]))
15
RuntimeException Unmatched delimiter: ) clojure.lang.Util.runtimeException (Util.java:221)</pre>
<h3><span style="color: #0000ff;">Java 互操作</span></h3><br/>
Clojure 使用 Java 的东西可没有 Scala 那么简单, 主要了解几个宏 <code>import</code>, <code>.</code>, <code>..</code>, <code>.?.</code>, 以及 <code>doto</code> 函数. Clojure 为同一个操作准备了多种方式, 看似灵活, 其实让人更凌乱. 使用 (doc import), (doc doto) 这样来查看使用方法. 大概用代码罗列一下:<br/>
<pre class="lang:default decode:true">(import ;import 是一个变参函数，它的每一个元素又是一个列表
  '(java.util Calendar GregorianCalendar) //列表第一个元素是包名，其他是各个类
  '(javax.swing JFrame JLabel))<br/>
Calendar/APRIL  ;-&gt;3 如果 Calendar 已导入, 或 (. java.util.Calendar APRIL)  访问类常量
(Math/pow 2 4)  ; 或 (. Math pow 2 4),相当于把 . 当作函数名，Math pow 2 4 分别是它的参数<br/>
(def calendar (GregorianCalendar. 2008 Calendar/APRIL 16)) ;或 ..(new GregorianCalendar 2008 3 16)
(. calendar add Calendar/MONTH 2)
(.get calendar Calendar/MONTH)  ; 两种方式调用实例方法</pre>
<br/>
真正要使用的时候再回过头来看吧, 主要有两点比较新颖: 1) <code>..</code> 能把方法串接起来 2) <code>doto</code> 可用来调用一个对象的多个方法, 方法不要求 <code>return this</code> 也能链接:<br/><br/>
<pre class="brush:clj">(.. calendar getTimeZone getDisplayName) ;相当于 (. (. calendar getTimeZone) getDisplayName), .?. 短路操作,可容错
(doto calendar                  ; doto 在每次调用下面的方法都会返回它的第一个参数 calendar
  (.set Calendar/YEAR 1981)
  (.set Calendar/MONTH Calendar/AUGUST))</pre>
<br/>
所有的  Clojure 方法都实现了 <code>java.lang.Runnable</code> 接口. Clojure 的异常都是运行时异常. 如果要捕获从 Java 代码抛出的检测异常需要用到 <code>try</code>, <code>catch</code>, <code>finally</code>, 和  <code>throw</code> 那些被称作 <code>special forms</code> 的东西.<br/>
<h3><strong><span style="color: #0000ff;">流程控制</span></strong></h3>
<strong><span style="text-decoration: underline;"><span style="color: #000000; text-decoration: underline;">条件处理</span></span>, </strong>special form <span style="color: #666666; font-family: monospace;"><span style="background-color: #fafafa;"><code>if</code>, 宏 <code>when</code>, <code>when-not</code>, 能绑定 binding 变量的宏 <code>if-let</code> 和 <code>when-let</code>, 还有相当于 switch/case 语句的 <code>condp</code> 和 <code>cond</code> 两个宏.<code>do</code> 可以用来包裹多个操作, 方便在单个条件中执行多条语句. 和 Scala 一样, Clojure 的条件语句是有返回值的. 下面一起进到代码里去理解</span></span><br/>
<pre class="lang:default decode:true">(if true                   ;if 可有三个参数, 第一个为条件, 第二个为成立时表达式, 第三个为可选的不成立时的表达式
  (println "play")
  (do (println "work")     ; 有三个条件时, 相当于 ? : 三无操作符
    (println "sleep")))<br/>
(when is-weekend (println "play"))  ;只在条件成立时干什么
(when-not is-weekend (println "work") (println "sleep")<br/>
(if-let [name (first waiting-line)]  ;如果 waiting-line 为空时, first 返回 nil 就代表 false
  (println name "is next")
  (println "no waiting"))
(when-let [head (first coll)] (print head))<br/>
(condp = value  ;第一个参数谓词  =, 第二个参数要比较的值 value, 后面任意多个值-表达式对, 最后为 default
  1 "one"
  2 "two"
  (str "unexpected value, " value)) ;这个是 default<br/>
(cond   ;与 condp 不同的是, 它可以提供不同的比较方式
  (instance? String temperature) :invalide temperature"
  (&lt;= temperature 0) "freezing"
  (&gt;= temperature 100) "boiling"
  true "neither"))</pre>
<br/>
<code>condp</code> 和 <code>cond</code> 匹配不到条件就会抛出 <code>IllegalArgumentException</code>, 每个分支自带 <code>break</code> 功能.<br/><br/>
<strong><span style="text-decoration: underline;">循环</span></strong>, 用宏 <code>dotimes</code> 和 <code>while</code><br/>
<pre class="lang:default decode:true">(dotimes [card-number 3]  ;card-number 是一个本地 binding, 如果用不上就写成 (dotimes [_ 3]), 和 Scala 一样
  (print card-number))  ;-&gt; 012<br/><br/>
(while true (print "."))</pre>
<br/>
宏 <code>for</code>, <code>doseq</code> 和 special form <span style="color: #666666; font-family: monospace;"><span style="background-color: #fafafa;"><code>loop</code>, 它们可以用 <code>:when</code> 或 <code>:while</code> 进行过滤, 例子:</span></span><br/>
<pre class="lang:default decode:true">(def cols "ABCD")
(def rows (range 1 4))<br/>
(dorun  ;dorun 不让 for 循环返回集合, 没有 dorun 的话 for 有返回值 (nil nil nil nil nil nil)
  (for [col cols :when (not= col \B)  ;\B 语法糖表示字符 B
    row rows :while (&lt; row 3)]   ;多重循环只要写在这个 Vector 中就行,单循环为 (for [col cols] (prinltn col))
      (println (str col row))))<br/>
(doseq [col cols :when (not= col \B)
  row rows :while (&lt; row 3)]
    (println (str col row)))</pre>
Clojure 的循环与 Java 的  foreach 写法有点类似.<br/><br/>
往下是递归, Clojure 和 Java 一样也是不支持尾递归优化的, <code>loop/recur</code> 组合可把一个看似递归的调用变成一个迭代, 这是做了尾递归优化该做的事情了.<br/><br/>
已经不想再往下写了, 先了解这些 Clojure 的基础知识了, 剩下的还有一本 "Clojure IN ACTION" 这本书要细细的品读了.<br/><br/>
&nbsp;
