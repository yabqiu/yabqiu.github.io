---
title: 学习 Rust 的工作空间, 包, Crate 和模块管理
url: /study-rust-workspace-package-crate-module/
date: 2025-11-28T22:42:52-06:00
featured: false
draft: false
toc: false
# menu: main
usePageBundles: true
categories:
  - Rust
tags: 
  - Rust
comment: true
codeMaxLines: 50
# additional
wpPostId: 14518 
wpStatus: publish
views: 73
lastmod: 2025-11-28T22:48:54-06:00
---

Rust 项目一旦增大，用 <code>cargo new demo</code> 创建的单一包，单个 src/main.rs 的项目组织方式不能满足需求了</p>

<blockquote>
$ cargo new demo<br />
$ tree demo<br />
demo<br />
├── Cargo.toml<br />
└── src<br />
          └── main.rs
</blockquote>

比如至少要一个 src/lib.rs 文件吧，复杂些还需在  src 目录中创建模块层次的目录; 更大型项目还要在 Package 上边创建 Workspace。<br/><br/>
这里就引出了 Rust 项目的几个概念，即 Package, Crate, 模块，以及 Workspace，再就是如何在代码中引用不同 Package, Crate, 模块中的资源要用到路径。<br/><br/>
比如这个最基本的 demo 项目中<br/><br/>
<ol>
    <li>Package: 一个可以构建，测试和分享 Crate 的单元，它可包含可选的 lib crate 和多个二进制 crate 项。  demo 就是一个 Package，src/main.rs 就是一个二进制 crate, 如果有 src/lib.rs 就是一 个 lib crate, 它只能有一个。其他的放在 src/bin/* 中的多个 *.rs 文件是一个个独立的二进制 crate，它们会被编译成多个执行文件。下面将会演示。</li>
    <li>Crates: Rust 编译器编译的最小单位。每个  crate 会输出一二进制文件或 lib</li>
    <li>Module: crate 内部的代码层次组织结构，由 mod xxx; 或  mod xxx { ... } 定义</li>
    <li>Path: 访问 module, 函数，类型等和路径，分绝对路径(crate::foo::bar::baz, lib::something::func)与相对路径(self::foo::bar, super::baz)</li>
</ol>
<br/>
<!--more-->而 Workspace 是用来组织多个 Package 的，像下面的一个  my-workspace 例子<br/>
{{< highlight text >}}
my-workspace                        # 这是一个 Workspace, 在这里运行 cargo build 将编译所有 Package，相当于类型为 pom 的 Maven 项目
├── Cargo.toml                      # Workspace 有自己的 Cargo.toml, 其中列举了气管理的 Package(account, billing)
├── account                         # 这是一个 Package
│   ├── Cargo.toml                  # Package 也有自己的 Cargo.toml 文件，其下有一个或多个 Crate
│   └── src
│       ├── address                 # 从此开始的三行为 Crate 中模块的组织
│       │   └── mail.rs
│       ├── address.rs              # address.rs 必须与模块目录 address 同名
│       ├── bin                     # bin 目录下的每一个 *.rs 文件对应为一个二进制 crate, 它们都需要有 main 函数
│       │   ├── delete_account.rs   # 编译生成  delete_account 执行文件，Windows 下为 delete_account.exe
│       │   └── show_account.rs     # 编译生成 show_account 执行文件，Windows 下为 show_account.exe
│       ├── lib.rs                  # 可选的 lib crate, 编译后生成 libaccount.rlib
│       └── main.rs                 # 也是可选的，crate 的主二进制 crate, 文件名必须为 main.rs, 编译后生成执行文件 account (Windows 下为 account.exe)
└── billing                         # 另一个 Crate，遵循与 account 的组织形式
    ├── Cargo.toml
    └── src
        └── main.rs
{{</ highlight >}}
上方的注释应该对我们理解 Rust 项目的组织结构有所帮助。<br/><br/>
my-workspace  中的 Cargo.toml 内容为<br/>
{{< highlight toml >}}
[workspace]
resolvers = "3"
members = [
    "account",
    "billing"
]
{{</ highlight >}}
在 my-workspace 目录中运行 <code>cargo build</code> 之后，在 my-workspace/target/debug 中生成的主要文件有可执行文件 account, billing, delete_account, show_account, 以及库 libaccount.rlib.<br/><br/>
进到 my-workspace/account 目录中运行  <code>cargo build</code> 构建生成的产物也是在 my-workspace/target 目录中，而不是在 account/target 中，但在此时只会构建  account 包。<br/><br/>
在 Rust 中，通常 Crate 指的就是库(Library)。Cargo 包中有以几个 Crate 的约定(不需要在 Cargo.toml 中特别配置)<br/><br/>
<ol>
    <li>src/main.rs: 与包同名的二进制 crate 的 crate  根，将生成执行文件 account</li>
    <li>src/lib.rs:  与包同名的库 crate 的 crate 根，将生成库文件 libaccount.rlib</li>
    <li>其余的二进制 crate 只要把 *.rs 文件放在 src/bin 目录下即可，将生成与 *.rs 文件同名的可执行文件。这很方便我们在一个包中创建多个可执行文件。</li>
</ol>
<br/>
src/main.rs 和 src/lib.rs  组成根模块，其余的每一个 *.rs 都可认为是一个模块，有点像 Python 的文件即模块，但 Rust 的每一个模块都需要显式的声明(从根开始)。<br/>
<h3>如何使用 src/lib.rs 中模块和函数</h3><
一个只有  src/main.rs 文件的 Rust 项目见的太多，接下来我们把某些内容移到  src/lib.rs  中，看如何使用。直接贴出 src/lib.rs 和 src/main.rs 的代码<br/><br/>
src/lib.rs<br/>
{{< highlight rust >}}
pub fn get_account_info(_id: &str) -> String {
    "account package, source: lib.rs".to_string()
}
pub mod utils {
    pub fn helper_function() -> String {
        "This is a helper function from account::utils".to_string()
    }
}
{{</ highlight >}}
src/main.rs<br/>

{{< highlight rust >}}
use account::get_account_info;
use account::utils::helper_function;<br/><br/>
fn main() {
    get_account_info("xyz");
    helper_function();
}
{{</ highlight >}}

注意两点：<br/><br/>
<ol>
    <li>写在 src/lib.rs 中的代码属于和包(account) 同名的库，所以用 use account::* 的方式引用</li>
    <li>src/lib.rs 中只有 pub 的模块或函数才允许被  src/main.rs 引用</li>
</ol>
<br/>
或全部内联的写在  src/lib.rs 中<br/>
{{< highlight rust >}}
pub mod address {
    pub mod mail {
        pub fn get_mail(user: &str) {
            println!("Getting mail for user: {}", user);
        }
    }
}
{{</ highlight >}}
在 src/main.rs 中使用<br/>
{{< highlight rust >}}
fn main() {
    account::address::mail::get_mail("xyz")
}
{{</ highlight >}}
但项目就膨胀，必定是不能全写在 src/lib.rs 中了，需要用更多的文件来拆分实现。这就是后面将要学习到的模块与子模块。<br/><br/>
<h3>不使用包为库名，及库文件 src/lib.rs 的约定</h3><br/>
如果不想遵循库文件为 src/lib.rs 以及包(account) 为库名的约定，该如何配置呢？在 account/Cargo.toml 中配置 [lib] 区块的内容为<br/>
{{< highlight toml >}}
[lib]
name = "mylib"            # 命名自己的库名，而非与包同名的库
path = "src/mylib.rs"     # 定义自己的库文件，而非 src/lib.rs
{{</ highlight >}}
现在只要把 src/lib.rs 更名为 src/mylib.rs, 其中的内容保持不变，最后在 src/main.rs 中使用 mylib 库时 use 语句变换为如下<br/>
{{< highlight rust >}}
use mylib::get_account_info;
use mylib::utils::helper_function;
{{</ highlight >}}
当然，编译后在 target/debug 目录中看到就库文件就是 libmylib.rlib, 不再是 libaccount.rlib。<br/>
<h3>使用自定义模块</h3>
src/lib.rs 是一个库 crate, 用起来也像是一个模块，与库 crate 同一级别的，我们可创建自定义的模块，就是前面的 address 模块。<br/><br/>
当 rustc(或 cargo build) 编译时首先从 crate 根文件(如 src/lib.rs 和 src/main.rs) 中寻找要编译的代码。在 crate 根文件中还可以声明自定义模块，Rust 编译寻找模块要从 crate 根文件开始。<br/><br/>
之所以把  src/main.rs 和  src/lib.rs 称之为 crate 根，是因为这两个文件内容在 crate  模块结构的根组成了一个名为  <code>crate</code> 的模块。从后面的路径引用也会发现模块可从 <code>crate::</code> 开始。<br/><br/>
我们将要创建一个 address 模块，首先需要在 crate 根文件(如 src/lib.rs 或 src/main.rs 中) 声明模块 address, 我们以  src/main.rs 为例(为 src/lib.rs  所用的模块就声明在 src/lib.rs 中)，有以下三种方式自定义模块<br/>
<h4>1）内联方式</h4>
直接在  src/main.rs 中声明并定义<br/>
{{< highlight rust >}}
mod address {
    pub fn get_address(_id: &str) -> String {
        todo!()
    }
}
{{</ highlight >}}
虽然写在 src/main.rs 文件中，但在它的 main() 想要调用的话，address::get_address() 函数也必须声明为 pub<br/>
<h4>2）同名文件 src/address.rs 中</h4>
做法是同样需要在根 crate src/main.rs 中声明 address 模块<br/>
{{< highlight rust >}}
mod address;
{{</ highlight >}}
只是实现部分移入到 src/address.rs 中, 内容为<br/>
{{< highlight ruslt >}}
pub fn get_address(_id: &str) -> String {
    todo!()
}
{{</ highlight >}}
<h4>3）或实现写在 src/address/mod.rs 中</h4>
此种方式与前一种方式唯一的不同之处就是把 src/address.rs 的内容放到了  src/address/mod.rs. <br/><br/>
在 src/main.rs 中使用方式为<br/>
{{< highlight rust >}}
fn main() {
    address::get_address("xyz");
}
{{</ highlight >}}
**/mod.rs 是老旧的风格，不过仍然支持，在新项目中不推荐使用该风格。<br/>
<h3>子模块的声明</h3>
子模块为模块的模块，当我们一旦确定了从某一个根 crate(src/main.rs 或  src/lib.rs) 文件中声明的 <code>mod address</code> 引导到了 <code>src/address.rs</code> 后，就可从这里开始声明 address 的子模块，同样的有三种方式(address.rs 中内联模块 mail, 子模块文件 src/address/mail, 或 src/address/mail/mod.rs)。<br/><br/>
我个人觉得可以摒弃 &lt;module&gt;/mod.rs 的方式<br/><br/>
从声明子模块的方式也能帮助我们理解如何声明模块的方式，或者要声明更深层次的子级模块。 下面是一个有子模块 address/mail 的项目结构<br/>
{{< highlight text >}}
account
├── Cargo.toml
└── src
    ├── address
    │   └── mail.rs
    ├── address.rs
    └── main.rs
{{</ highlight >}}
main.rs 的内容<br/>
{{< highlight rust >}}
ub mod address;
fn main() {
    address::mail::get_mail("xyz");  # 使用子模块
}
{{</ highlight >}}

在该根 crate 中用  <code>pub mod address</code>  声明一个模块，它有两个目的<br/>
<ol>
    <li>Rust 编译器由根 crate 由此找到需编译 address 模块</li>
    <li>由声明的 address 定位到 src/address.rs 或 src/address/mod.rs 文件 </li>
</ol>
<br/>
address.rs 内容<br/>
{{< highlight rust >}}
pub mod mail;
{{</ highlight >}}
编译器追踪到了这里，在 address 中又声明了一个子模块 mail, 那就会要求存在文件 src/address/mail.rs 或  src/address/mail/mod.rs 文件。这就是为什么有子模块时 src/address.rs 与目录 src/address 要同名。当我们在 IntelliJ IDEA 中修改 src/address.rs 文件名是，src/address 目录名也跟着变化。<br/><br/>
src/address/mail.rs 的内容<br/>
{{< highlight rust >}}
pub fn get_mail(_id: &str) -> String {
    "mail package, source: address::mail".to_string()
}
{{</ highlight >}}
注意，Rust  默认时模块，函数等的可见性为私有，只有 pub 时才能在其他模块中访问到，这不会是问题，编译器会清楚的提示。<br/><br/>
关于模块或子模块，关键的地方就是要理解 Rust 如何从 crate  根节点(src/main.rs 或 src/lib.rs) 开始通过 mod 声明一路定位到模块实现文件的。<br/><br/>
回顾一下根模块 crate 及整个模块树的结构现在就是<br/>
{{< highlight text >}}
crate            # 由 src/main.rs 和  src/lib.rs 组成，在根文件中声明的 mod address 就会定位到 address 模块 src/address.rs
└── address      # 由 src/address.rs 中声明的 mod mail 进一步定位到 mail 子模块 src/address/mail.rs 文件
    └── mail     # 子模块 mail 的实现
{{</ highlight >}}
在每一级模块都有自己放置实现代码或声明子一级模块的文件，如 src/address.rs 和 src/address/mail.rs。习惯用 mod.rs 的就是 src/address/mod.rs 和 src/address/mail/mod.rs，这会在项目中产生大量的无自描述能力的 mod.rs 文件。<br/>
<h3>关于引用模块树中荐的路径</h3>
记住根模块名为 crate，所以有相应的绝对和相对引用路径， 下面的各种方式多试试就明白了，此路不通必有路。<br/>
{{< highlight rust >}}
use address::mail;
use crate::address::mail;<br/><br/>
super::mail::get_mail(user);
self::get_mail("xyz");
{{</ highlight >}}
<h3>其他一些 use 相关用法</h3>
use as 别名<br/>
<blockquote>
use std::io::Result as IoResult;
</blockquote>
pub use 重导出，私有的模块或函数，并改变外部访问路径<br/><br/>
比如<br/><br/>
src/lib.rs 中<br/>
{{< highlight rust >}}
mod address {
    pub fn get_address(_id: &str) -> String {
        todo!()
    }
}
pub use address::get_address;  # 没有这行，foo() 中无法直接用 get_address("xyz"), 必须用 address::get_address("xyz")
pub fn foo(){
    get_address("xyz");
}
{{</ highlight >}}
<br/>
在 src/main.rs 中<br/>
{{< highlight rust >}}
fn main() {
    account::get_address("xyz");
}
{{</ highlight >}}

没有前面的 <code>pub use</code> 语句，这里用全路径 <code>account::address::get_address("xyz")</code> 也访问不了该方法，因为它是私有的。有了 <code>pub use</code> 语句，还能直接由根模块 account::get_address("xyz")  引用，不同中间的 <code>address</code>。<br/>
<h3>关于 Cargo 工作空间</h3>
前面提到过  Cargo 的 Workspace 就类似于 Maven 中类型为 pom 的项目。同一 Workspace 中的所有 Package 共享同一个 Cargo.lock 文件。<br/><br/>
同一个 Workspace 中并不假定 package 之间是互相依赖的，所以需要显式的声明依赖。例如我们想在 billing 中调用 account/src/lib.rs 中定义的 address::get_address(_id: &amp;str) 函数，首先须在 billing/Cargo.toml 中配置<br/>
{{< highlight  toml >}}
[dependencies]
account = {path = "../account"}
{{</ highlight >}}
然后就能在 billing/src/main.rs 使用了<br/>
{{< highlight rust >}}
use account;<br/><br/>
fn main() {
    account::address::get_address("xyz");
}
{{</ highlight >}}
<br/>
在 Workspace 目录上运行 <code>cargo test --workspace</code> 会执行所有 Package 的测试，要测试特定 Package 中的测试用<br/>
<blockquote>
cargo test -p billing
</blockquote>

与 mvn 命令一样的.<br/>
只构建某一个 Package 用<br/>
<blockquote>
cargo build -p billing
</blockquote>

<h3>用 cargo install 安装二进制文件</h3>
这与本文的内容不相关，只借此地记录一下，一个 Rust  项目有  src/main.rs 会生成与包同名的二进制文件，还有放在 src/bin/ 目录中的 *.rs  会生成对应的二进制文件，如果想把这些二进制文件安装到本地可直接使用的话，以前的  <code>cargo install</code>  会安装到 <code>~/.cargo/bin/</code> 目录中，现在不支持了<br/>
<blockquote>
cargo install<br />
error: Using `cargo install` to install the binaries from the package in current working directory is no longer supported, use `cargo install --path .` instead. Use `cargo build` if you want to simply build the package.
</blockquote>

需显式指定 <code>--path</code>, <code>cargo install --path .</code><br/>
<blockquote>
cargo install --path .<br />
Installing account v0.1.0 (/Users/yanbin.qiu/Desktop/my-workspace/account)<br />
Finished `release` profile [optimized] target(s) in 0.04s<br />
Replacing /Users/yanbin/.cargo/bin/account<br />
Replacing /Users/yanbin/.cargo/bin/delete_account<br />
Replacing /Users/yanbin/.cargo/bin/show_account<br />
Replaced package `account v0.1.0 (/Users/yanbin/my-workspace/account)` with `account v0.1.0 (/Users/yanbin/my-workspace/account)` (executables `account`, `delete_account`, `show_account`)
</blockquote>

在 ~/.cargo/bin 下生成了三个执行文件 account, delete_account  和  show_account, 查看了下环境变量 $PATH, 其中包含了 /Users/yanbin/.cargo/bin，因此在任何地方都能执行它们。<br/><br/>
自定义 Cargo 扩展命令只要求在  $PATH 下有 <code>cargo-something</code> 的二进制文件，就能用 <code>cargo something</code> 的方式执行，像 AWS Lambda 扩展用的 <code>cargo lambda build</code>, 和 git 要求的命令 <code>git-something</code> 相似。<br/><br/>
其余更灵活的用途就是在 Cargo.toml 中自定义使用 lib, 模块等，非特别需求尽量遵循约定就是了。
