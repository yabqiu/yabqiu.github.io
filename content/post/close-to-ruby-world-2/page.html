---
title: 走近 Ruby 的世界(二)
url: /close-to-ruby-world-2/
date: 2012-01-02T08:35:48-06:00
featured: false
thumbnail: "../images/logos/ruby-logo.png"
draft: false
type: post
toc: false
# menu: main
usePageBundles: true
categories:
  - Ruby
tags: 
  - Method
  - ruby
  - operator
comment: true
codeMaxLines: 50
# additional
wpPostId: 4120 
wpStatus: publish
views: 363
lastmod: 2014-01-05T00:06:56-06:00
---

还是零碎的记录，也不知道该为每一篇赋上什么合适的标题，姑且用一、二、三、四 ......&nbsp;往下标吧。<br/>
<br/>
一种编程语 言，Coding&nbsp;时一定要讲求效率的，我向来不认为用记事本来写程序就可被认为是多么的高明。就像测试&nbsp;Java&nbsp;程序我仍然是选用 Eclipse，当然命令行技术是要求掌握的。写&nbsp;Ruby&nbsp;程序可以用&nbsp;NetBeans&nbsp;那样带智能提示的工具，但是 Mac OS&nbsp;下，TextMate&nbsp;的口碑很不多的，它有很好用的&nbsp;Bundle，Cmd＋R&nbsp;就能看到运行结果，查帮助也很方便。<br/>
<br/>
从代码的智能提示来看，TextMate&nbsp;或许只能称之为半智能，但它的效率还是非常的高，且基于其余时候打开 TextMate&nbsp;的频度，我选择 TextMate&nbsp;作为 Ruby&nbsp;的 IDE。<br/>
<br/>
Ruby&nbsp;的表达式和操作符，Ruby&nbsp;的语法是面向表达式的，如在其他语言中的控制结构在&nbsp;Ruby&nbsp;中统统叫做表达式，只是它们的返回值为&nbsp;nil。来看几个较有特色的&nbsp;Ruby&nbsp;运算符：<!--more-->
{{< highlight ruby >}}
puts 2**1024                     #Ruby 支持很大很大的整数，不会那么容易出现放不下的问题
puts "Ruby" + " rocks!"          #连接字符串
puts "Ruby! " * 3                #字符串成以数字就是重复几遍
puts "%d %s" % [3, "rubies"]     #格式化字符串更直白，就是字符串的百分号操作符，参数为数组
{{</ highlight >}}

执行的结果如下图，直接在&nbsp;TextMate&nbsp;中运行后的截屏：<br/>
{{< bundle-image src="ruby-operators.png" >}}
许多的&nbsp;Ruby&nbsp;操作符就是由方法实现的，也就是说上面的运算符也就是方法调用，不信的话，你可以把上面的代码写成下面的形式：</p>

<br/>
{{< highlight ruby >}}
puts 2**(1024)
puts "Ruby" + (" rocks!")
puts "Ruby! " * (3)
puts "%d %s" % ([3, "rubies"])
{{</ highlight >}}

即把第二个操作数当作符号方法调用的参数，得到的是同样的结果。<br/>
<br/>
也就是因为操作符即为相应方法的调用，这说明了&nbsp;Ruby&nbsp;也支持操作符的重载，像&nbsp;Groovy&nbsp;和&nbsp;Scala&nbsp;一样只要重载操作符相对应的方法即重载了该操作符。这比&nbsp;C++&nbsp;中的操作符重载要好理解的多。<br/>
<br/>
有关于操作符的重载，比如，&lt;&lt;&nbsp;符号对于数字类型是移位操作，你可以重载该它使得对于字符串，数组，流等是 append&nbsp;的操作。再如像&nbsp; []&nbsp;这个操作符，通常是下标操作，但你用来 [1,2,3]&nbsp;来定义数组时，其实就重载了该操作符的意义。<br/>
<br/>
<strong>Ruby&nbsp;的方法</strong>，Ruby&nbsp;定义方法是用 def ... end&nbsp;关键字，这与&nbsp;Groovy&nbsp;和&nbsp;Scala&nbsp;是一样的，且最后一个表达式的值就是方法的返回值，这与许多语言是一致的。<br/>
{{< highlight ruby >}}
def square(x)
  x*x     #x*x的值即为该方法的返回值，当然，你也可以显式的用 return x*x 来返回，Ruby 中显得画蛇添足了
end
{{</ highlight >}}

上面定义的是全局方法，如果要定义类或模块的方法，只要加个类或模块的前缀即可，比如给核心的&nbsp;Math&nbsp;模块加个方法：<br/>
{{< highlight ruby >}}
def Math.square(x)
  x*x     #x*x的值即为该方法的返回值，当然，你也可以显式的用 return x*x 来返回，Ruby 中显得画蛇添足了
end       ＃但如果是要在方法的中断直接返回而中断方法的继续执行时，就要用 return 语句了
{{</ highlight >}}

这引出了&nbsp;Ruby&nbsp;的一个关键特征：Ruby&nbsp;的类和模块在运行时对于修改和扩展是开放的，它不需要像在&nbsp;Groovy&nbsp;中对现有类的修改或扩展要借助于&nbsp;MetaClass&nbsp;这样的东西。<br/>
<br/>
Ruby&nbsp;支持并行赋值，像下面那样的赋值写法：<br/>
{{< highlight ruby >}}
x, y = 1, 2           #意为 x=1; y=2
a, b = b, a           #这样实现了交换 a 和 b 的值
x, y, z = [1,2,3]     #数组中的元素分别赋值给 x、y 和 z，
{{</ highlight >}}

如果是&nbsp;x, y, z = [1,2]，右值不够的话，z&nbsp;就为 nil,&nbsp;始果是 x, y = [1,2,3],&nbsp;也不会报错的，只用到前两个元素，脚本语言容错性必须很强的。<br/>
<br/>
看到&nbsp;Ruby&nbsp;的并行赋值，我就会想到在&nbsp;Perl&nbsp;中相应的特性，可以用标量列表来接收数组变量，达到并行赋值的效果，如&nbsp;Perl&nbsp;用这样的代码：<br/>
{{< highlight ruby >}}
@list = ("dog", "cat", "bird", "snake");
($animal1, $animal2, $animal3, $animal4) = @list;
{{</ highlight >}}

不光赋值语句可以并行的，而且方法可以同时多个值，实质就是返回一个数组：<br/>
{{< highlight ruby >}}
def polar(x, y)
  theta = Math.atan2(y, x)
  r = Math.hypot(x, y)
  [r, theta]
end

distance, angle = polar(2, 2)  #调用该方法直接赋值给多个变量，用不着分几步
#tmp=polar(2,2), 再 distance = tmp[0]; angle = tmp[1]
{{</ highlight >}}

前面讲过&nbsp;Ruby&nbsp;的符号操作是调用的方法，就连赋值操作也不例外，比如你的对象定义一个名为 x=&nbsp;的方法，你就可以使用 <strong>o.x = (1)&nbsp;达到与&nbsp;o.x = 1&nbsp;等同的效果</strong>。
