---
title: Quartz Job Scheduling Framework［翻译］附录 A. Quartz 配置参考 (第一部分)
url: /quartz-job-scheduling-framework-appendix-1/
date: 2008-12-19T23:55:00-06:00
featured: false
draft: false
toc: false
# menu: main
usePageBundles: true
categories:
  - Quartz
tags: 
  - Quartz
  - 翻译
comment: true
codeMaxLines: 50
# additional
wpPostId: 306 
wpStatus: publish
views: 1323
lastmod: 2010-08-10T10:40:51-05:00
---

<strong>附录 A. Quartz 配置参考</strong><br/>
<br/>
本附录编写作为配置一个 Quartz 应用的快速参考。尽管这些信息在 Quartz 文档中都有，但是这个附录提供了一种更快的方式来查找配置属性和它们可能的值。<br/>
<br/>
<strong>一. 主要的 Quartz 属性</strong><br/>
<br/>
表 A.1 列出了主要的 Scheduler 属性。它们用于声明和标识 Scheduler 和其他高层次的设置。<!--more--><br/>
<table cellspacing="5" width="720"><caption><strong>表 A.1. 主要的 Quartz Scheduler 属性</strong></caption><br/>
<tbody>

<tr>

<td width="200"><strong>名称</strong></td>

<td width="70"><strong>必须</strong></td>

<td width="80"><strong>类型</strong></td>

<td><strong>默认值</strong></td>

<td></td>

</tr>

<tr>

<td><span style="color: #800080;">org.quartz.scheduler.instanceName</span></td>

<td>否</td>

<td><span style="color: #800080;">String</span></td>

<td><span style="color: #800080;">'QuartzScheduler'</span></td>

<td></td>

</tr>

<tr>

<td><span style="color: #800080;">org.quartz.scheduler.instanceId</span></td>

<td>否</td>

<td><span style="color: #800080;">String</span></td>

<td><span style="color: #800080;">'NON_CLUSTERED'</span></td>

<td></td>

</tr>

<tr>

<td><span style="color: #800080;">org.quartz.scheduler.instanceIdGenerator.class</span></td>

<td>否</td>

<td><span style="color: #800080;">String</span></td>

<td><span style="color: #800080;">org.quartz.simpl.SimpleInstanceIdGenerator</span></td>

<td></td>

</tr>

<tr>

<td><span style="color: #800080;">org.quartz.scheduler.threadName</span></td>

<td>否</td>

<td><span style="color: #800080;">String</span></td>

<td><span style="color: #800080;">instanceName+'_QuartzSchedulerThread'</span></td>

<td></td>

</tr>

<tr>

<td><span style="color: #800080;">org.quartz.scheduler.idleWaitTime</span></td>

<td>否</td>

<td><span style="color: #800080;">Long</span></td>

<td><span style="color: #800080;">30000</span></td>

<td></td>

</tr>

<tr>

<td><span style="color: #800080;">org.quartz.scheduler.dbFailureRetryInterval</span></td>

<td>否</td>

<td><span style="color: #800080;">Long</span></td>

<td><span style="color: #800080;">15000</span></td>

<td></td>

</tr>

<tr>

<td><span style="color: #800080;">org.quartz.scheduler.classLoadHelper.class</span></td>

<td>否</td>

<td><span style="color: #800080;">String</span></td>

<td><span style="color: #800080;">org.quaartz.simpl.CascadingClassLoadHelper</span></td>

<td></td>

</tr>

<tr>

<td><span style="color: #800080;">org.quartz.context.key.SOME_KEY</span></td>

<td>否</td>

<td><span style="color: #800080;">String</span></td>

<td><span style="color: #800080;">None</span></td>

<td></td>

</tr>

<tr>

<td><span style="color: #800080;">org.quartz.scheduler.userTransactionURL</span></td>

<td>否</td>

<td><span style="color: #800080;">String</span></td>

<td><span style="color: #800080;">'java:comp/UserTransaction'</span></td>

<td></td>

</tr>

<tr>

<td><span style="color: #800080;">org.quartz.scheduler.wrapJobExecutionIn<br/>
UserTransaction</span></td>

<td>否</td>

<td><span style="color: #800080;">Boolean</span></td>

<td><span style="color: #800080;">false</span></td>

<td></td>

</tr>

<tr>

<td><span style="color: #800080;">org.quartz.scheduler.jobFactory.class</span></td>

<td>否</td>

<td><span style="color: #800080;">String</span></td>

<td><span style="color: #800080;">org.quartz.simple.SimpleJobFactory</span></td>

<td></td>

</tr>

</tbody>

</table>

<strong><span style="color: #800080;">·org.quartz.scheduler.instanceName</span></strong><br/>
<br/>
每个 Scheduler 必须给定一个名称来标识。当在同一个程序中有多个实例时，这个名称作为客户代码识别是哪个 Scheduler 而用。假如你用到了集群特性，你就必须为集群中的每一个实例使用相同的名称，以使它们成为“逻辑上” 是同一个 Scheduler 。<br/>
<br/>
<strong><span style="color: #800080;">·org.quartz.scheduler.instanceId<br/>
</span></strong><br/>
每个 Quartz Scheduler 必须指定一个唯一的 ID。这个值可以是任何字符串值，只要对于所有的 Scheduler 是唯一的。如果你想要自动生成的 ID，那你可以使用 <span style="color: #800080;">AUTO</span> 作为 <span style="color: #800080;">instanceId</span>。从版本 1.5.1 开始，你能够定制如何自动生成实例 ID。见 <span style="color: #800080;">instanceIDGenerator.class</span> 属性，会在接下来讲到。<br/>
<br/>
<span style="color: #800080;"><strong>·org.quartz.scheduler.instanceIdGenerator.class</strong></span><br/>
<br/>
从版本 1.5.1 开始，这个属性允许你定制instanceId 的生成，这个属性仅被用于属性 <span style="color: #800080;">org.quartz.scheduler.instanceId</span> 设置为 <span style="color: #800080;">AUTO</span> 的情况下。默认是 <span style="color: #800080;">org.quartz.simpl.SimpleInstanceIdGenerator</span>，它会基于主机名和时间戳来产生实例 ID 的。<br/>
<br/>
<strong><span style="color: #800080;">·org.quartz.scheduler.threadName<br/>
</span></strong><br/>
可以是对于 Java 线程来说有效名称的任何字符串。假如这个属性未予指定，线程将会接受 Scheduler 名称 (<span style="color: #800080;">org.quartz.scheduler.instanceName</span>) 前附加上字符串 '<span style="color: #800080;">_QuartzSchedulerThread'</span> 作为名称。<br/>
<br/>
<strong><span style="color: #800080;">·org.quartz.scheduler.idelWaitTime</span></strong><br/>
<br/>
这个属性设置了当 Scheduler 处于空闲时转而再次查询可用 Trigger 时所等待的毫秒数。通常，你无需调整这个参数，除非你正使用 XA 事物，遇到了 Trigger 本该立即触发而发生延迟的问题。<br/>
<br/>
<span style="color: #800080;"><strong>·org.quartz.scheduler.dbFailureRetryInterval</strong></span><br/>
<br/>
这个属性设置 Scheduler 在检测到 JobStore 到某处的连接(比如到数据库的连接) 断开后，再次尝试连接所等待的毫秒数。这个参数在使用 <span style="color: #800080;">RamJobStore</span> 无效。<br/>
<br/>
<strong><span style="color: #800080;">·org.quartz.scheduler.classLoadHelper.class</span></strong><br/>
<br/>
对于多数健状的应用，所使用的默认值为 <span style="color: #800080;">org.quartz.simpl.CascadingClassLoadHelper</span> 类，它会依序使用其他的 <span style="color: #800080;">ClassLoadHelper</span> 类，直到有一个能正常工作为止。你大概没必须为这个属性指定任何其他的类，除非有可能在应用服务器中时。当前所有可能的 <span style="color: #800080;">ClassLoadHelper</span> 实现可在 <span style="color: #800080;">org.quartz.simpl</span> 包中找到。<br/>
<br/>
<strong><span style="color: #800080;">·org.quartz.context.key.SOME_KEY</span></strong><br/>
<br/>
这个属性用于向 "Scheduler 上下文" 中置入一个 名-值 对表示的字符串值。(见 <span style="color: #800080;">Scheduler.getContext()</span>)。因此，比如设置了 <span style="color: #800080;">org.quartz.context.key.MyEmail = </span><a href="mailto:myemail@somehost.com"><span style="color: #800080;">myemail@somehost.com</span></a> 就相当于执行了 <span style="color: #800080;">scheduler.getContext().put("MyEmail", </span><a href="mailto:myemail@somehost.com"><span style="color: #800080;">myemail@somehost.com</span></a><span style="color: #800080;">)</span><br/>
<br/>
<span style="color: #800080;"><strong>·org.quartz.scheduler.userTransactionURL</strong></span><br/>
<br/>
它设置了 Quartz 能在哪里定位到应用服务器的 <span style="color: #800080;">UserTransaction</span> 管理器的 JNDI URL。默认值(未设定的话) 是 <span style="color: #800080;">java:comp/UserTransaction</span>，这几乎能工作于所有的应用服务器中。Websphere 用户也许需要设置这个属性为 <span style="color: #800080;">jta/usertransaction</span>。这个属性仅用于 Quartz 配置使用 <span style="color: #800080;">JobStoreCMT</span> 的情况，并且 <span style="color: #800080;">org.quartz.scheduler.wrapJobExecutionInUserTransaction</span> 被设定成了 <span style="color: #800080;">true</span>。<br/>
<br/>
<strong><span style="color: #800080;">·org.quartz.scheduler.wrapJobExecutionInUserTransaction</span></strong><br/>
<br/>
如果你要 Quartz 在调用你的 Job 的 <span style="color: #800080;">execute</span> 之前启动一个 <span style="color: #800080;">UserTransaction</span> 的话，设置这个属性为 <span style="color: #800080;">true</span>。这个事物将在 Job 的 <span style="color: #800080;">execute</span> 方法完成和 <span style="color: #800080;">JobDataMap</span>(假如是一个 <span style="color: #800080;">StatefulJob</span>) 更新后提交。默认值为 <span style="color: #800080;">false</span>。<br/>
<br/>
<span style="color: #800080;"><strong>·org.quartz.scheduler.jobFactory.class</strong></span><br/>
<br/>
这是所用的 <span style="color: #800080;">JobFactory</span> 的类名称。默认为 <span style="color: #800080;">org.quartz.simpl.SimpleJobFactory</span>。你也可以试试 <span style="color: #800080;">org.quartz.simpl.PropertySettingJobFactory</span>。一个 Job 工厂负责产生 Job 类的实例。<span style="color: #800080;">SimpleFactory</span> 类是调用 Job 类的 <span style="color: #800080;">newInstance()</span> 方法。<span style="color: #800080;">PropertySettingJobFactory</span> 也会调用 <span style="color: #800080;">newInstance()</span>，但还会使用 <span style="color: #800080;">JobDataMap</span> 中的内容以反射方式设置 Job Bean 的属性。<br/>
<br/>
[译者 Unmi 本篇后记] 从正式发布《Quartz Job Scheduling Framework 中文版.chm 》之后到现在又快过去四个月的时间了，正如前面提到的那个 CHM 文件确实包含了绝大部份主体的内容，就差最后一个附录：Quartz 配置参考，说来也是个缺憾。耽搁的太久，每天都会发生很多事情，可是这几个月对我来太不平静，家庭的、个人的、工作上的事故接踵而至。既然想起来了，还是着手完成这个事吧，之后会汇入到先前那个 CHM 文件中的。况且也还不时有人提起关于翻译版权的问题，实际上通过了解确有不对，该如何呢？暂顶顶风了。<br/>
<br/>
<hr />另外，在此提一下 org.quartz.scheduler.jobFactory，因为它简单的调用 Job 类的 newInstance() 方法来得到 Job 实例，所以你的 Job 要有一个无参构造方法。有一个网友使用 Quartz 在 Scheduler 初始化 Job 时碰到这样的错误：<br/>
<br/>
严重: An error occured instantiating job to be executed. job= 'jobDetailGroup1.jobDetail1'<br/>
org.quartz.SchedulerException: Problem instantiating class 'steve.InvokeCmdAction$SimpleQuartzJob' [See nested exception: java.lang.InstantiationException: steve.InvokeCmdAction$SimpleQuartzJob]<br/>
    at org.quartz.simpl.SimpleJobFactory.newJob(SimpleJobFactory.java:57)<br/>
    at org.quartz.core.JobRunShell.initialize(JobRunShell.java:132)<br/>
    at org.quartz.core.QuartzSchedulerThread.run(QuartzSchedulerThread.java:387)<br/>
Caused by: java.lang.InstantiationException: steve.InvokeCmdAction$SimpleQuartzJob<br/>
    at java.lang.Class.newInstance0(Class.java:340)<br/>
    at java.lang.Class.newInstance(Class.java:308)<br/>
    at org.quartz.simpl.SimpleJobFactory.newJob(SimpleJobFactory.java:55)<br/>
    ... 2 more<br/>
<br/>
问题在于 Quartz 的 SimpleFactory 无法实例化 'steve.InvokeCmdAction$SimpleQuartzJob'  这个例，看这个类名，带个 $ 符号，很显然是写 InvokeCmdAction.java 文件中的，后来他把 SimpleQuartzJob 单独写在 SimpleQuartzJob.java 文件中问题即得到解决。如若有兴趣的话，定制自己的 JobFactory 配置给 org.quartz.scheduler.jobFactory 属性，那对于 'steve.InvokeCmdAction$SimpleQuartzJob'  Job 类也是可以成功实例化的。
