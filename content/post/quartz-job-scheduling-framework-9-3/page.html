---
title: Quartz Job Scheduling Framework［翻译］第九章. 使用 Quartz 的远程方式 (第三部分)
url: /quartz-job-scheduling-framework-9-3/
date: 2007-11-26T10:50:00-06:00
featured: false
draft: false
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/quartz-logo.jpeg"
categories:
  - Quartz
tags: 
  - Quartz
  - 翻译
comment: true
codeMaxLines: 50
# additional
wpPostId: 466 
wpStatus: publish
views: 778
lastmod: 2021-05-02T23:55:24-05:00
---

<strong>6. 创建 RMI 客户端<br />
</strong></p>
<br/>
你需要创建一个客户端，用来调用远程 Quartz 调度器上的方法。客户端会同 RMI 注册服务器进行通信，进而定位到远程调度器对象，然后就能够调用其上的方法了。这些方法包括有暂停和停止调度器、部署和卸下 Job，和执行所有其他对与远程客户端可见的方法。<br/><br/>
<strong>·配置 Quartz RMI 客户端<br />
</strong><br />
类似于表 9.1 所示服务端的配置，表 9.2 所列出的属性也是必须加到 Quartz RMI 客户端的。这两份属性列表必须分别应用到服务端和客户端的。<!--more--><br/><br/>
<table border="0" width="650">
<caption><strong>表 9.2 Quartz RMI 客户端所必须的属性</strong></caption>
<tbody>
<tr>
<td><strong>属性</strong></td>
<td width="25%"><strong>默认值</strong></td>
</tr>
<tr>
<td><span style="color: #800080;">org.quartz.scheduler.rmi.registryHost<br />
</span><br />
<strong>注：</strong>这是运行 RMI 注册服务所在的主机</td>
<td><span style="color: #800080;">localhost</span></td>
</tr>
<tr>
<td><span style="color: #800080;">org.quartz.scheduler.rmi.registryPort<br />
</span><br />
<strong>注：</strong>这是运行 RMI 注册服务所监听的端口(通常是 1099)</td>
<td><span style="color: #800080;">1099</span></td>
</tr>
<tr>
<td><span style="color: #800080;">org.quartz.scheduler.rmi.proxy<br />
</span><br />
<strong>注：</strong>假如你希望连接到远程服务端的调度器，设置 <span style="color: #800080;">org.quartz.scheduler.rmi.proxy</span> 标志为 <span style="color: #800080;">true</span>。你同时必须指定 RMI 注册服务进程的主机和端口号。</td>
<td><span style="color: #800080;">false</span></td>
</tr>
</tbody>
</table>
<br/>
为了能让客户端定位到服务对象，它需要知道 RMI 注册服务运行在哪里，以便能查找到远程对象。<span style="color: #800080;">org.quartz.scheduler.rmi.registryHost</span> 和 <span style="color: #800080;">org.quartz.scheduler.rmi.registryPort</span> 属性必须是运行着 RMI 注册服务的主机和端口。假如你配置了 Quartz RMI 服务端自动启动注册服务，那么 RMI 注册服务器与 RMI 服务端就是同在一个机器上的。<br/><br/>
因为你想要客户端能联系到远程调度器去部署 Job，你必须设置属性 <span style="color: #800080;">org.quartz.scheduler.rmi.proxy</span> 为 <span style="color: #800080;">true</span>。<br/><br/>
代码 9.3 就是一个 RMI 客户端用来与服务器进行通信的 <span style="color: #800080;">quartz.properties</span> 示例文件<br/><br/>
<strong>代码 9.3 一个用于 Quartz RMI 客户端的 <span style="color: #800080;">quartz.properties</span> 文件例子<br />
</strong>
{{< highlight java-properties >}}
#=============================================================
# Configure Main Scheduler Properties
#=============================================================
org.quartz.scheduler.instanceName = RMIScheduler
#org.quartz.scheduler.instanceId = AUTO

#==============================================================
#Configure RMI Properties
#==============================================================
org.quartz.scheduler.rmi.registryHost=localhost
org.quartz.scheduler.rmi.registryPort=1099
org.quartz.scheduler.rmi.proxy= true
{{</ highlight >}}
<br/>
除了上面所说的三个 RMI 属性之外，你曾经见过像代码 9.3 所示的 <span style="color: #800080;">quartz.properties</span> 属性文件。<br/><br/>
<table style="border: 1px;" border="1" width="70%" align="center">
<tbody>
<tr>
<td><strong>客户端和服务器的实例名必须相匹配<br />
</strong><br />
属性 <span style="color: #800080;">org.quartz.scheduler.instanceName</span> 在 RMI 客户端和服务端必须一致。不然，客户将无法在注册服务中查找到服务对象，会收一个客户端无法获取到远程调度器句柄的异常。</td>
</tr>
</tbody>
</table>
<br/>
<strong>·创建 RMI 客户端类<br />
</strong><br />
在为客户端配置好了属性文件之后，你需要构建一个客户端 Java 类，去获取指向远程调度器的句柄并据此做点什么。创建这个类并不用我们做太多的事情，正如创建服务端类那般，我们把 <span style="color: #800080;">quartz.properties</span> 文件更名为 <span style="color: #800080;">client.properties</span> 并且告诉客户端从更名后的文件中加载属性。同样的，这样做的目的只是有助于我们清楚的知道是加载的哪一个属性文件以免产生混乱。除了这点这改变之外，你已经是多次的在前面章节中看到像代码 9.4 那样的配置了。<br/><br/>
<strong>代码 9.4. 通过远程调度器部署一个 Job 的 Quartz RMI 客户端的例子<br />
</strong>
{{< highlight java >}}
package org.cavaness.quartzbook.chapter9;

import java.util.Date;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.quartz.CronTrigger;
import org.quartz.JobDataMap;
import org.quartz.JobDetail;
import org.quartz.Scheduler;
import org.quartz.impl.StdSchedulerFactory;

public class RMITestClient {

     public void run() throws Exception {

          Log log = LogFactory.getLog(RMITestClient.class);

          // Use this properties file instead of quartz.properties
          System.setProperty("org.quartz.properties",
                "client.properties");

          // Get a reference to the remote scheduler
          Scheduler scheduler =
               StdSchedulerFactory.getDefaultScheduler();

          // Define the job to add
          JobDetail job = new JobDetail("remotelyAddedJob", "default",
                    SimpleJob.class);
          JobDataMap map = new JobDataMap();
          map.put("msg", "Your remotely added job has executed!");
          job.setJobDataMap(map);
          CronTrigger trigger =
               new CronTrigger("remotelyAddedTrigger",
                  "default", "remotelyAddedJob", "default", new
                        Date(), null, "/5 * * ? * *");

         // schedule the remote job
         scheduler.scheduleJob(job, trigger);

         log.info("Remote job scheduled.");
    }

    public static void main(String[] args) throws Exception {
         RMITestClient example = new RMITestClient();
         example.run();
    }
}
{{</ highlight >}}
<br/>
我们观察到一件有趣的事，也近乎魔术般的就是根本不用告诉工厂类我们想要的是一个远程调度器。工厂类是依据我们告诉它所加载的 <span style="color: #800080;">client.properties</span> 文件知道这么做的。明确的讲就是，设置了 RMI 属性导引着工厂类创建了一个远程调度器：<br/><br/>
<span style="color: #800080;">org.quartz.scheduler.rmi.proxy = true</span><br/><br/>
下面是 <span style="color: #800080;">StdSchedulerFactory</span> 的一个代码片断，它们决定了客户端去连接到一个远程调度器<br/>
{{< highlight java >}}
if (rmiProxy) {

    if (autoId)
        schedInstId = DEFAULT_INSTANCE_ID;

    schedCtxt = new SchedulingContext();
    schedCtxt.setInstanceId(schedInstId);

    String uid = QuartzSchedulerResources.getUniqueIdentifier(
            schedName, schedInstId);

    RemoteScheduler remoteScheduler = new RemoteScheduler(schedCtxt,
            uid, rmiHost, rmiPort);

    schedRep.bind(remoteScheduler);

    return remoteScheduler;
}
{{</ highlight >}}
<br/>
以上代码出现在 <span style="color: #800080;">StdSchedulerFactory</span> 的 <span style="color: #800080;">instantiate()</span> 方法中。在这段代码中，工厂类检查为客户端设置的 <span style="color: #800080;">rmiProxy</span> 是否为 <span style="color: #800080;">true</span>。如果为 <span style="color: #800080;">true</span>，一个新的 <span style="color: #800080;">RemoteScheduler</span> 将被初始化并返回。这就是为什么我们的客户端并不需做任何特别的事情就行。返回到我们客户端的调度器实例实质上就是一个远程调度器(<span style="color: #800080;">RemoteScheduler</span>) 实例，因为 <span style="color: #800080;">RemoteScheduler</span> 实现了 <span style="color: #800080;">Scheduler</span> 接口，所以客户端代码可以对此毫不知情。<br/><br/>
<strong>7. 测试 RMI 服务端和客户端<br />
</strong><br />
我们最后终于来到了可以运行客户端和服务端去测试 RMI 配置的时刻了。第一件要做的事情是启动 Quartz RMI 服务端。除了确保基本的 Quartz JAR 包和 <span style="color: #800080;">server.properties</span> 文件包含在 classpath 下之外，不用去做其他特别的事情了。运行 RMI 用不着附加的 JAR 文件，只是需要运行任何一个 Quartz 程序所必须的包而已。<br/><br/>
<strong>·运行 Quartz RMI 服务端<br />
</strong><br />
要运行 Quartz RMI 服务端，仅仅是像运行别的 Java 类一样运行 <span style="color: #800080;">QuartzRMIServer</span> 类。就在前面提到过，要确保 classpath 下包含了所需的 JAR 文件和 <span style="color: #800080;">server.properties</span> 文件。要完成这个，最简单的方式就是创建一个批处理文件(或shell 脚本)，把需要的东西写在其中。代码 9.4 就是一个用来启动服务端的简单的批处理文件。<br/><br/>
<strong>代码 9.4. 一个简单的用来启动 Quartz RMI 服务端的 <span style="color: #800080;">startserver.bat</span> 批处理文件</strong><br/><br/>
<span style="color: #800080;">java org.cavaness.quartzbook.chapter9.QuartzRMIServer<span style="color: #800080;"><span style="color: #800080;"> </span></span></span><br/><br/>
<span style="color: #000000;">你还需要在代码9.4 的命令行中包含所需的 JAR 文件到 classpath 上才能正常工作。这包括有 quartz.jar、commons-logging.jar、commons-logging-api.jar、commons-collections3.1.jar、beanutils.jar、commons-beanutils-bean-collections.jar、commons-beanutils-core.jar。
<br/><br/>
<strong>·运行 Quartz RMI 客户端<br />
</strong><br />
当服务端运行起来之后，你就可以运行 RMI 客户端了。客户端能以与服务端同样的方式运行--创建一个批处理文件或 shell 脚本。当启动客户端后，假如一切正常的话，你将不仅仅能看到从客户端控制台输出了一个远程 Job 被部署了的消息，还能看到在服务端控制台打印出一条消息，是说接收到了远程 Job 并部署运行。</span><br/><br/>
尽管这个 RMI 客户端被设计为部署一个 Job 后就退出，Quartz RMI 服务端被设计为持续运行直到键入 <span style="color: #800080;">exit</span> 为止。服务端可以写成是接收到一个远程 Job，进行部署，然后执行自己的逻辑去等待更多的客户连接。这就意味着你能多次的运行客户端，像这样的设计应该才是你想要的。<br/><br/>
当你完成了运行这个例子之后，只要键入 <span style="color: #800080;">exit</span> 即可。<br/><br/>
<strong>·接下来是什么？</strong><br/><br/>
<span style="color: #000000;"><span style="color: #000000;">本章介绍了与 Quartz 调度器打交道的一种新的方式，这在之前是不可能的。在 Quartz 中使用 RMI，允许你构建组件分离的程序并能分布在跨平台的机器中。这是一个非常好的概念，因为它在没有增加额外开发工作量的情况下提供了更好的可伸缩性。 </span></span><br/><br/>
&nbsp;<br/><br/>
&nbsp;
