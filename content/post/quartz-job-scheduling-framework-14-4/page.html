---
title: Quartz Job Scheduling Framework［翻译］第十四章. 工作流中使用 Quartz (第四部分)
url: /quartz-job-scheduling-framework-14-4/
date: 2008-08-19T02:35:00-05:00
featured: false
draft: false
toc: false
# menu: main
usePageBundles: true
categories:
  - Quartz
tags: 
  - 翻译
comment: true
codeMaxLines: 50
# additional
wpPostId: 345 
wpStatus: publish
views: 526
lastmod: 2021-09-02T14:28:43-05:00
---

<strong>四. 创建一个工作流 Job<br />
</strong></p>
<br/>
最后，我们需要介绍启动工作流的 Quartz Job 。当 Scheduler 调用了它，Quartz Job 就查找工作流的名字，并启动、运行相应的工作流。如果没有在 <span style="color: #800080;">JobDataMap</span> 中配置工作流的名字，Job 就会直接退出。<br/><br/>
代码 14.13 显示了 <span style="color: #800080;">WorkflowJob</span>.<!--more--><br/><br/>
<strong>代码 14.13. Quartz <span style="color: #800080;">WorkflowJob</span> 设计为调用一个 <span style="color: #800080;">OSWorkflowJob</span><br />
</strong>
{{< highlight java >}}
public class WorkflowJob implements Job {
     static Log logger = LogFactory.getLog(WorkflowJob.class);

     /**
      * Called by the scheduler to execute a workflow
      */
     public void execute(JobExecutionContext context)
               throws JobExecutionException {
          JobDataMap jobDataMap = context.getJobDataMap();

          String wfName = jobDataMap.getString("WORKFLOW_NAME");
          if (wfName != null && wfName.length() > 0) {
               try {
                    executeWorkflow(wfName, jobDataMap);
               } catch (Exception ex) {
                    logger.error(ex);
                         throw new
                              JobExecutionException(ex.getMessage());
               }
          } else {
               logger.error("No Workflow name in JobDataMap");
          }
     }

     protected void executeWorkflow(String workflowName,
          JobDataMap jobDataMap) throws WorkflowException {

          // Create the inputs for the workflow from JobDataMap
          Map workflowInputs = new HashMap();
          Iterator iter = jobDataMap.keySet().iterator();
          while (iter.hasNext()) {
               String key = (String) iter.next();
               Object obj = jobDataMap.get(key);
               workflowInputs.put(key, obj);
          }
          // Create and execute the workflow
          Workflow workflow = new BasicWorkflow("someuser");
          workflow.setConfiguration(new DefaultConfiguration());

          long workflowId = workflow.initialize(workflowName, 1, workflowInputs);

          workflow.doAction(workflowId, 1, workflowInputs);
      }
}
{{</ highlight >}}
<br/>
这个工作流实际是在代码 14.13 的 <span style="color: #800080;">executeWorkflow()</span> 方法中启动的。一个新的工作流实例被创建了。它通过从 <span style="color: #800080;">JobDataMap</span> 中读取到的工作流名字来初始化的。工作流实例的 <span style="color: #800080;">initialize()</span> 和 <span style="color: #800080;">doAction()</span> 方法用了一个 <span style="color: #800080;">java.util.Map</span> 作为第三个参数。Map 中的值会通过 <span style="color: #800080;">transientVars</span> 参数传递到工作流的每一个函数中。如果你回头看看代码 14.11，你会看到 SCAN_DIR 是如何从 <span style="color: #800080;">transientVars</span> 抽取出来的。这个数据最初是在 <span style="color: #800080;">JobDataMap</span> 的。<br/><br/>
本例中，我们从 Quartz Job 中获得 <span style="color: #800080;">JobDataMap</span> 并传值到工作流中。这是集成这两个框架的其中一种方式，简单也很直截。<br/><br/>
最后，代码 14.14 显示了 Scheduler 的代码，它用于部署 <span style="color: #800080;">WorkflowJob</span> 并把工作流名称和 <span style="color: #800080;">SCAN_DIR</span> 存入到 <span style="color: #800080;">JobDataMap</span> 中。<br/><br/>
<strong>代码 14.14. <span style="color: #800080;">WorkflowJob</span> 以正常方式部署，但必须存工作流名称到 <span style="color: #800080;">JobDataMap</span> 中</strong>
{{< highlight java >}}
public class WorkflowScheduler {
     static Log logger = LogFactory.getLog(WorkflowScheduler.class);

     public static void main(String[] args) {

          try {
               // Create and start the Scheduler
               Scheduler scheduler =
                    StdSchedulerFactory.getDefaultScheduler();
               scheduler.start();

               JobDetail jobDetail =
                    new JobDetail("WorkflowJob", null,
                         WorkflowJob.class);
               // Store the scan directory and workflow name
               JobDataMap dataMap = jobDetail.getJobDataMap();
               dataMap.put("SCAN_DIR", "c:\\quartz-book\\input");
               dataMap.put("WORKFLOW_NAME", "data-import");

               // Create a simple trigger
               Trigger trigger =
                    TriggerUtils.makeSecondlyTrigger(30000, -1);
               trigger.setName("WorkflowTrigger");
               trigger.setStartTime(new Date());

               // schedule the job
               scheduler.scheduleJob(jobDetail, trigger);

          } catch (SchedulerException ex) {
               logger.error(ex);
          }
     }
}
{{</ highlight >}}
<br/>
你看到代码 14.14 时不应感到惊讶。唯一要注意的事情是我们存储了工作流名称到 JobDataMap 中。和本章前面的 Job 串联例子一样，假如你想使用 <span style="color: #800080;">JobInitializationPlugin</span>，你可以简单的在文件中指定工作流的名称。<br/><br/>
<strong>五. 小结</strong><br/><br/>
我们从本章中学到了什么？首先，Job 串联可由 Quartz 框架实现。你可用所介绍的两种方法，只是不借助于监听器实现的方式或许会让你有些头疼。我希望你带走的另一课是 Job 串联并非工作流。它也许看起来像工作流，你可能还对此存有疑虑，只要回到前面从头至尾构建一个自己的例子就能清楚了。一定要读一读 OSWorkflow 的文档并找出我们未提及的特性。你就能明白工作流比 Job 串联丰富多了。<br/><br/>
最后，你应该了解到了同 Quartz 一同使用 OSWorkflow 实际是颇为简单的。所有要用到的就是几个二进制包，几个配置文件和一些工作流函数。把它们同工作流定义文件打包到一块，你就大功告成了。很快，你就将构建出一个可重用的函数库和一连串工作流来运行你的业务。不久，你就会有一个为之自豪的精致小巧的应用程序。
