---
title: Quartz Job Scheduling Framework［翻译］第三章. Hello Quartz (第三部分)
url: /quartz-job-scheduling-framework-3/
date: 2007-11-17T02:25:00-06:00
featured: false
draft: false
toc: false
# menu: main
usePageBundles: true
thumbnail: "../images/logos/https://yanbin.blog/wp-content/uploads/2007/10/quartz-logo.jpeg"
categories:
  - Quartz
tags: 
  - Quartz
  - 翻译
comment: true
codeMaxLines: 50
# additional
wpPostId: 472 
wpStatus: publish
views: 541
lastmod: 2021-05-02T23:53:03-05:00
---

<strong>3. 声明式部署一个 Job</strong></p>
<br/>
前面我们讨论过，尽可能的用声明式处理软件配置，其次才才虑编程式。再来看代码  3.6，如果我们要在 Job 启动之后改变它的执行时间和频度，必须去修改源代码重新编译。这种方式只适用于小的例子程序，但是对于一个大且复杂的系统，这就成了一个问题了。因此，假如能以声明式部署 Quart Job 时，并且也是需求允许的情况下，你应该每次都选择这种方式。<br/><br/>
<strong>·配置 quartz.properties 文件</strong><br/><br/>
文件 <span style="color: #800080;">quartz.properties</span> 定义了 Quartz 应用运行时行为，还包含了许多能控制 Quartz 运转的属性。本章只会讲到它的基本配置；更多的高级设置将在以后讨论。在现阶段也不用太深入到每一项配置有效值的细节。<!--more--><br/><br/>
现在我们来看看最基础的 <span style="color: #800080;">quartz.properties</span> 文件，并讨论其中一些设置。代码 3.7 是一个修剪版的 <span style="color: #800080;">quartz.propertis</span> 文件。<br/><br/>
<table style="border: 1px;" border="0" width="70%" align="center">
<tbody>
<tr>
<td><strong>注<br />
</strong><br />
 Quartz 框架会为几乎所有的这些属性设定默认值。</td>
</tr>
</tbody>
</table>
<br/>
<strong>代码 3.7. 基本的 Quartz Properties 文件</strong><br/>
{{< highlight java-properties >}}
#===============================================================
#Configure Main Scheduler Properties
#===============================================================
org.quartz.scheduler.instanceName = QuartzScheduler
org.quartz.scheduler.instanceId = AUTO

#===============================================================
#Configure ThreadPool
#===============================================================
org.quartz.threadPool.threadCount =  5
org.quartz.threadPool.threadPriority = 5
org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool

#===============================================================
#Configure JobStore
#===============================================================
org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore

#===============================================================
#Configure Plugins
#===============================================================
org.quartz.plugin.jobInitializer.class = org.quartz.plugins.xml.JobInitializationPlugin

org.quartz.plugin.jobInitializer.overWriteExistingJobs = true
org.quartz.plugin.jobInitializer.failOnFileNotFound = true
org.quartz.plugin.jobInitializer.validating=false
{{</ highlight >}}
<br/>
在代码 3.7 所示的 <span style="color: #800080;">quartz.properties</span> 文件中，属性被逻辑上分为了四部分。属性在写法上无须要求分组或按特定的顺序。有 # 的行是注释行。<br/><br/>
<table style="border: 1px;" border="0" width="70%" align="center">
<tbody>
<tr>
<td><strong>注<br />
</strong><br />
这里讨论的并没有涉及到所有可能的设置，仅仅是一些基本的设置。也是你需要去熟悉的，能使声明式例子运转起来的必须的设置项。<span style="color: #800080;">quartz.properties</span> 中的所有属性配置将会分散在本书中的各章节中依据所在章节涉及内容详细讨论。</td>
</tr>
</tbody>
</table>
<br/>
<strong>·调度器属性</strong><br/><br/>
第一部分有两行，分别设置调度器的实例名(<span style="color: #800080;">instanceName</span>) 和实例 ID (<span style="color: #800080;">instanceId</span>)。属性 <span style="color: #800080;">org.quartz.scheduler.instanceName</span> 可以是你喜欢的任何字符串。它用来在用到多个调度器区分特定的调度器实例。多个调度器通常用在集群环境中。(Quartz 集群将会在第十一章，“Quartz 集群”中讨论)。现在的话，设置如下的一个字符串就行：<br/><br/>
<span style="color: #800080;">org.quartz.scheduler.instanceName = QuartzScheduler</span><br/><br/>
实际上，这也是当你没有该属性配置时的默认值。<br/><br/>
代码 3.7 中显示的调度器的第二个属性是 <span style="color: #800080;">org.quartz.scheduler.instanceId</span>。和 <span style="color: #800080;">instaneName</span> 属性一样，<span style="color: #800080;">instanceId</span> 属性也允许任何字符串。这个值必须是在所有调度器实例中是唯一的，尤其是在一个集群当中。假如你想 Quartz 帮你生成这个值的话，可以设置为 <span style="color: #800080;">AUTO</span>。如果 Quartz 框架是运行在非集群环境中，那么自动产生的值将会是 <span style="color: #800080;">NON_CLUSTERED</span>。假如是在集群环境下使用 Quartz，这个值将会是主机名加上当前的日期和时间。大多情况下，设置为 <span style="color: #800080;">AUTO</span> 即可。<br/><br/>
<strong>·线程池属性</strong><br/><br/>
接下来的部分是设置有关线程必要的属性值，这些线程在 Quartz 中是运行在后台担当重任的。<span style="color: #800080;">threadCount </span>属性控制了多少个工作者线程被创建用来处理 Job。原则上是，要处理的 Job 越多，那么需要的工作者线程也就越多。<span style="color: #800080;">threadCount </span>的数值至少为 <span style="color: #800080;">1</span>。Quartz 没有限定你设置工作者线程的最大值，但是在多数机器上设置该值超过100的话就会显得相当不实用了，特别是在你的 Job 执行时间较长的情况下。这项没有默认值，所以你必须为这个属性设定一个值。<br/><br/>
<span style="color: #800080;">threadPriority</span> 属性设置工作者线程的优先级。优先级别高的线程比级别低的线程更优先得到执行。threadPriority 属性的最大值是常量 <span style="color: #800080;">java.lang.Thread.MAX_PRIORITY</span>，等于10。最小值为常量 <span style="color: #800080;">java.lang.Thread.MIN_PRIORITY</span>，为1。这个属性的正常值是 <span style="color: #800080;">Thread.NORM_PRIORITY</span>，为5。大多情况下，把它设置为5，这也是没指定该属性的默认值。<br/><br/>
最后一个要设置的线程池属性是 <span style="color: #800080;">org.quartz.threadPool.class</span>。这个值是一个实现了 <span style="color: #800080;">org.quartz.spi.ThreadPool</span> 接口的类的全限名称。Quartz 自带的线程池实现类是 <span style="color: #800080;">org.quartz.smpl.SimpleThreadPool</span>，它能够满足大多数用户的需求。这个线程池实现具备简单的行为，并经很好的测试过。它在调度器的生命周期中提供固定大小的线程池。你能根据需求创建自己的线程池实现，如果你想要一个随需可伸缩的线程池时也许需要这么做。这个属性没有默认值，你必须为其指定值。<br/><br/>
<strong>·作业存储设置</strong><br/><br/>
作业存储部分的设置描述了在调度器实例的生命周期中，Job 和 Trigger 信息是如何被存储的。我们还没有谈论到作业存储和它的目的；因为对当前例子是非必的，所以我们留待以后说明。现在的话，你所要了解的就是我们存储调度器信息在内存中而不是在关系型数据库中就行了。<br/><br/>
把调度器信息存储在内存中非常的快也易于配置。当调度器进程一旦被终止，所有的 Job 和 Trigger 的状态就丢失了。要使 Job 存储在内存中需通过设置  <span style="color: #800080;">org.quartz.jobStrore.class</span> 属性为 <span style="color: #800080;">org.quartz.simpl.RAMJobStore</span>，就像在代码 3.7 所做的那样。假如我们不希望在 JVM 退出之后丢失调度器的状态信息的话，我们可以使用关系型数据库来存储这些信息。这需要另一个作业存储(JobStore) 实现，我们在后面将会讨论到。第五章“Cron Trigger 和其他”和第六章“作业存储和持久化”会提到你需要用到的不同类型的作业存储实现。<br/><br/>
<strong>·插件配置<br />
</strong><br />
在这个简单的 <span style="color: #800080;">quartz.properties</span> 文件中最后一部分是你要用到的 Quart 插件的配置。插件常常在别的开源框架上使用到，比如 Apache 的 Struts 框架(见 <a href="http://struts.apache.org">http://struts.apache.org</a>)。<br/><br/>
一个声明式扩框架的方法就是通过新加实现了 <span style="color: #800080;">org.quartz.spi.SchedulerPlugin</span> 接口的类。<span style="color: #800080;">SchedulerPlugin</span>  接口中有给调度器调用的三个方法。<br/><br/>
<table style="border: 1px;" border="0" width="70%" align="center">
<tbody>
<tr>
<td><strong>注<br />
</strong><br />
Quartz 插件会在第八章“使用 Quartz 插件”中详细讨论</td>
</tr>
</tbody>
</table>
<br/>
要在我们的例子中声明式配置调度器信息，我们会用到一个 Quartz 自带的叫做 <span style="color: #800080;">org.quartz.plugins.xml.JobInitializationPlugin</span> 的插件。<br/><br/>
默认时，这个插件会在 classpath 中搜索名为 quartz_jobs.xml 的文件并从中加载 Job 和 Trigger 信息。<br/><br/>
在下一节中讨论 <span style="color: #800080;">quartz_jobs.xml</span> 文件，这是我们所参考的非正式的 Job 定义文件。<br/><br/>
<table style="border: 1px;" border="0" width="70%" align="center">
<tbody>
<tr>
<td><strong>注<br />
</strong><br />
默认时，插件 <span style="color: #800080;">JobInitializationPlugin</span> 在 classpath 中寻找 <span style="color: #800080;">quartz_jobs.xml</span> 文件。你可以覆盖相应设置强制这个插件使用不同的文件名查找。要做到这个，你必须设置上一节讨论的 <span style="color: #800080;">quartz.properties</span> 中的文件名。目前，我们就使用默认的文件名 <span style="color: #800080;">quartz_jobs.xml</span>，至于如何修改 <span style="color: #800080;">quartz.properties</span> 中相应设置会在本章中后面讲到。</td>
</tr>
</tbody>
</table>
<br/>
<strong>·使用 <span style="color: #800080;">quartz_jobx.xml</span> 文件<br />
</strong><br />
代码 3.8 就是目录扫描例子的 Job 定义的 XML 文件。正如代码 3.5 所示例子那样，这里我们用的是声明式途径来配置 Job 和 Trigger 信息的。<br/><br/>
<div><strong>代码 3.8. ScanDirectory Job 的 quartz_jobs.xml</strong></div>
<br/>

{{< highlight xml >}}
<?xml version='1.0' encoding='utf-8'?>

<quartz>

  <job>
    <job-detail>
     <name>ScanDirectory</name>
     <group>DEFAULT</group>
     <description>
          A job that scans a directory for files
     </description>
     <job-class>
            org.cavaness.quartzbook.chapter3.ScanDirectoryJob
     </job-class>
     <volatility>false</volatility>
     <durability>false</durability>
     <recover>false</recover>
     <job-data-map allows-transient-data="true">
         <entry>
         <key>SCAN_DIR</key>
         <value>c:\quartz-book\input</value>
       </entry>
     </job-data-map>
    </job-detail>

    <trigger>
     <simple>
       <name>scanTrigger</name>
       <group>DEFAULT</group>
       <job-name>ScanDirectory</job-name>
       <job-group>DEFAULT</job-group>
       <start-time>2005-06-10 6:10:00 PM</start-time>
       <!-- repeat indefinitely every 10 seconds -->
       <repeat-count>-1</repeat-count>
       <repeat-interval>10000</repeat-interval>
     </simple>
    </trigger>

  </job>
</quartz>
{{</ highlight >}}
<br/>
<span style="color: #800080;">&lt;job&gt;</span> 元素描述了一个要注册到调度器上的 Job，相当于我们在前面章节中使用 <span style="color: #800080;">scheduleJob()</span> 方法那样。你所看到的<span style="color: #800080;">&lt;job-detail&gt;</span> 和  <span style="color: #800080;">&lt;trigger&gt;</span> 这两个元素就是我们在代码 3.5 中以编程式传递给方法 <span style="color: #800080;">schedulerJob()</span> 的参数。前面本质上是与这里一样的，只是现在用的是一种较流行声明的方式。你还可以对照着代码 3.5 中的例子来看在代码3.8 中我们是如何设置 <span style="color: #800080;">SCAN_DIR</span> 属性到 <span style="color: #800080;">JobDataMap</span> 中的。<br/><br/>
<span style="color: #800080;">&lt;trigger&gt;</span>元素也是非常直观的：它使用前面同样的属性，但更简单的建立一个 <span style="color: #800080;">SimpleTrigger</span>。因此代码 3.8 仅仅是一种不同的(可论证的且更好的)方式做了代码 3.5 中同样的事情。显然，你也可以支持多个 Job。在代码3.6 中我们编程的方式那么做的，也能用声明的方式来支持。代码 3.9 显示了与代码 3.6 可比较的版本<br/><br/>
<strong>代码 3.9. 你能在一个 quartz_jobs.xml 文件中指定多个 Job<br />
</strong><br/>
{{< highlight xml >}}
<?xml version='1.0' encoding='utf-8'?>

<quartz>
  <job>
    <job-detail>
     <name>ScanDirectory1</name>
     <group>DEFAULT</group>
     <description>
           A job that scans a directory for files
     </description>
     <job-class>
           org.cavaness.quartzbook.chapter3.ScanDirectoryJob
     </job-class>
     <volatility>false</volatility>
     <durability>false</durability>
     <recover>false</recover>

     <job-data-map allows-transient-data="true">
     <entry>
       <key>SCAN_DIR</key>
         <value>c:\quartz-book\input1</value>
     </entry>
    </job-data-map>
  </job-detail>

  <trigger>
    <simple>
     <name>scanTrigger1</name>
     <group>DEFAULT</group>
     <job-name>ScanDirectory1</job-name>
     <job-group>DEFAULT</job-group>
     <start-time>2005-07-19 8:31:00 PM</start-time>
     <!-- repeat indefinitely every 10 seconds -->
     <repeat-count>-1</repeat-count>
     <repeat-interval>10000</repeat-interval>
    </simple>
  </trigger>
</job>

<job>
  <job-detail>
    <name>ScanDirectory2</name>
    <group>DEFAULT</group>
    <description>
          A job that scans a directory for files
    </description>
    <job-class>
          org.cavaness.quartzbook.chapter3.ScanDirectoryJob
    </job-class>
    <volatility>false</volatility>
    <durability>false</durability>
    <recover>false</recover>

    <job-data-map allows-transient-data="true">
      <entry>
       <key>SCAN_DIR</key>
       <value>c:\quartz-book\input2</value>
     </entry>
    </job-data-map>
  </job-detail>

  <trigger>
    <simple>
     <name>scanTrigger2</name>
     <group>DEFAULT</group>
     <job-name>ScanDirectory2</job-name>
     <job-group>DEFAULT</job-group>
     <start-time>2005-06-10 6:10:00 PM</start-time>
     <!-- repeat indefinitely every 15 seconds -->
     <repeat-count>-1</repeat-count>
     <repeat-interval>15000</repeat-interval>
    </simple>
  </trigger>
 </job>
</quartz>
{{</ highlight >}}
<br/>
<strong>·为插件修改 <span style="color: #800080;">quartz.properties</span> 配置</strong><br/><br/>
在本章前面，告诉过你的是，<span style="color: #800080;">JobInitializationPlugin</span> 找寻 <span style="color: #800080;">quartz_jobs.xml</span> 来获得声明的 Job 信息。假如你想改变这个文件名，你需要修改 <span style="color: #800080;">quartz.properties</span> 来告诉插件去加载那个文件。例如，假如你想要 Quartz 从名为 <span style="color: #800080;">my_quartz_jobs.xml</span> 的 XML 文件中加载 Job 信息，你不得不为插件指定这一文件名。代码 3.10 显示了怎么完成这个配置；我们现在是最后一次在这里重复说明这一插件部分。<br/>
<strong>代码 3.10. 为 <span style="color: #800080;">JobInitializationPlugin</span> 修改 <span style="color: #800080;">quartz.properties</span></strong><br/><br/>
{{< highlight java-properties >}}
org.quartz.plugin.jobInitializer.class = org.quartz.plugins.xml.JobInitializationPlugin

org.quartz.plugin.jobInitializer.fileName = my_quartz_jobs.xml

org.quartz.plugin.jobInitializer.overWriteExistingJobs = true
org.quartz.plugin.jobInitializer.validating = false
org.quartz.plugin.jobInitializer.overWriteExistingJobs = false
org.quartz.plugin.jobInitializer.failOnFileNotFound = true
{{</ highlight >}}
<br/>
在代码 3.10中，我们添加了属性 <span style="color: #800080;">org.quartz.plugin.jobInitializer.fileName</span> 并设置该属性值为我们想要的文件名。这个文件名要对 classloader 可见，也就是说要在 classpath 下。<br/><br/>
当 Quartz 启动后读取 <span style="color: #800080;">quartz.properties</span> 文件，然后初始化插件。它会传递上面配置的所有属性给插件，这时候插件也就得到通知去搜寻不同的文件。<br/><br/>
译者后记：<br />
想了又想，关于动词的 “Schedule” 还是选择“部署”，此前用的是“安排”，感觉不那么正式。当然英语中“部署”基本都用“Deploy”对应，平时与同事交流 Quartz 方面的技术都是说“往调度器上部署一个 Job”的，只要词能达意就行。<br/><br/>
对于 “register with the Scheduler”，有时候是用的“通过调度器来注册”，有时候是“注册到调度器上”，意思基本一致的。<br/><br/>
&nbsp;
